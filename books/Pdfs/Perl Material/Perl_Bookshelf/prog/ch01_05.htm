<HTML
><HEAD
>
<TITLE>[Chapter 1] 1.5 Operators</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:20Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. An Overview of Perl"><LINK
REL="prev"
HREF="ch01_04.htm"
TITLE="1.4 Filehandles"><LINK
REL="next"
HREF="ch01_06.htm"
TITLE="1.6 Control Structures"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_04.htm"
TITLE="1.4 Filehandles"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.4 Filehandles"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. An Overview of Perl"
>Chapter 1<BR>An Overview of Perl</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_06.htm"
TITLE="1.6 Control Structures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.6 Control Structures"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5"
>1.5 Operators</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH01.OP"
></A
>As we alluded to earlier, Perl is also a mathematical language.  This is
true at several levels, from low-level bitwise logical operations, up
through number and set manipulation, on up to larger predicates and
abstractions of various sorts.  And as we all know from studying math in
school, mathematicians love strange symbols.  What's worse, computer
scientists have come up with their own versions of these strange
symbols.  Perl has a number of these strange symbols too, but take
heart, most are borrowed directly from C, FORTRAN, <EM
CLASS="emphasis"
>sed</EM
>(1) or
<EM
CLASS="emphasis"
>awk</EM
>(1), so
they'll at least be familiar to users of those languages.</P
><P
CLASS="para"
>Perl's built-in operators may be classified by number of operands into
unary, binary, and trinary operators.  They may be classified by whether
they're infix operators or prefix operators.  They may also be
classified by the kinds of objects they work with, such as numbers,
strings, or files.  Later, we'll give you a table of all the operators,
but here are some to get you started.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.1"
>1.5.1 Arithmetic Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-846"
></A
><A
CLASS="indexterm"
NAME="AUTOID-848"
></A
>Arithmetic operators do exactly what you would expect from learning them
in school.  They perform some sort of mathematical function on numbers.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PERL2-CH-1-TAB-2"
>Table 1.2: Some Binary Arithmetic Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Name</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Result</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a + $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Addition</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Sum of <CODE
CLASS="literal"
>$a</CODE
> and <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a * $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Multiplication</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Product of <CODE
CLASS="literal"
>$a</CODE
> and <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a % $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Modulus</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Remainder of <CODE
CLASS="literal"
>$a</CODE
> divided by <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a ** $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Exponentiation</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a</CODE
> to the power of <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Yes, we left subtraction and division out of <A
CLASS="xref"
HREF="ch01_05.htm#PERL2-CH-1-TAB-2"
TITLE="Some Binary Arithmetic Operators"
>Table 1.2</A
>.  But we suspect
you can figure out how they should work.  Try them and see if you're
right.  (Or cheat and look in the index.)  Arithmetic operators are
evaluated in the order your math teacher taught you (exponentiation before multiplication, and multiplication before
addition).  You can always use parentheses to make it come out differently.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.2"
>1.5.2 String Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-893"
></A
><A
CLASS="indexterm"
NAME="AUTOID-896"
></A
><A
CLASS="indexterm"
NAME="AUTOID-898"
></A
><A
CLASS="indexterm"
NAME="AUTOID-901"
></A
>There is also an &quot;addition&quot; operator for strings that does concatenation.
Unlike some languages that confuse this with numeric addition, Perl defines a
separate operator (<CODE
CLASS="literal"
>.</CODE
>) for string concatenation:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = 123;
$b = 456;
print $a + $b;     # prints 579
print $a . $b;     # prints 123456</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-908"
></A
><A
CLASS="indexterm"
NAME="AUTOID-910"
></A
><A
CLASS="indexterm"
NAME="AUTOID-913"
></A
><A
CLASS="indexterm"
NAME="AUTOID-915"
></A
>There's also a &quot;multiply&quot; operation for strings, also called the <EM
CLASS="emphasis"
>repeat</EM
>
operator.  Again, it's a separate operator (<B
CLASS="emphasis.bold"
>x</B
>) to keep it distinct
from numeric multiplication:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = 123;
$b = 3;
print $a * $b;     # prints 369
print $a x $b;     # prints 123123123</PRE
></P
><P
CLASS="para"
>These string operators bind as tightly as their corresponding
arithmetic operators.  The repeat operator is a bit unusual in taking a
string for its left argument but a number for its right argument.  Note
also how Perl is automatically converting from numbers to strings. You could have put all the literal numbers above in quotes, and it
would still have produced the same output.  Internally though, it would
have been converting in the opposite direction (that is, from strings to
numbers).</P
><P
CLASS="para"
>A couple more things to think about.  String concatenation is
also implied by the interpolation that happens in double-quoted strings.
When you print out a list of values, you're also effectively concatenating
strings.  So the following three statements produce the same output:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print $a . ' is equal to ' . $b . &quot;\n&quot;;    # dot operator
print $a, ' is equal to ', $b, &quot;\n&quot;;       # list
print &quot;$a is equal to $b\n&quot;;               # interpolation</PRE
></P
><P
CLASS="para"
>Which of these you use in any particular situation is entirely up to you.</P
><P
CLASS="para"
>The <B
CLASS="emphasis.bold"
>x</B
> operator may seem relatively
worthless at first glance, but it is quite useful at times, especially
for things like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print &quot;-&quot; x $scrwid, &quot;\n&quot;;</PRE
></P
><P
CLASS="para"
>which draws a line across your screen, presuming your screen width
is in <CODE
CLASS="literal"
>$scrwid</CODE
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.3"
>1.5.3 Assignment Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-935"
></A
><A
CLASS="indexterm"
NAME="AUTOID-937"
></A
>Although it's not exactly a mathematical operator, we've already made
extensive use of the simple assignment operator, <CODE
CLASS="literal"
>=</CODE
>.  Try to remember
that <CODE
CLASS="literal"
>=</CODE
> means &quot;gets set to&quot; rather than &quot;equals&quot;.  (There is also a
mathematical equality operator <CODE
CLASS="literal"
>==</CODE
> that means &quot;equals&quot;, and if you
start out thinking about the difference between them now, you'll save
yourself a lot of headache later.)</P
><P
CLASS="para"
>Like the operators above, assignment operators are binary infix
operators, which means they have an operand on either side of the
operator.  The right operand can be any expression you like, but the
left operand must be a valid <EM
CLASS="emphasis"
>lvalue</EM
> (which, when translated to
English, means a valid storage location like a variable, or a location
in an array).  The most common assignment operator is simple assignment.
It determines the value of the expression on its right side, and sets
the variable on the left side to that value:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = $b;
$a = $b + 5;
$a = $a * 3;</PRE
></P
><P
CLASS="para"
>Notice the last assignment refers to the same variable twice; once
for the computation, once for the assignment.  There's nothing wrong with that, but it's a common enough operation that there's a
shortcut for it (borrowed from C).  If you say:</P
><PRE
CLASS="programlisting"
>lvalue operator= expression</PRE
><P
CLASS="para"
>it is evaluated as if it were:</P
><PRE
CLASS="programlisting"
>lvalue = lvalue operator expression</PRE
><P
CLASS="para"
>except that the lvalue is not computed twice.  (This only makes a
difference if evaluation of the lvalue has side effects.  But when it
<EM
CLASS="emphasis"
>does</EM
> make a difference, it usually does what you want.  So don't sweat it.)</P
><P
CLASS="para"
>So, for example, you could write the above as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a *= 3;</PRE
></P
><P
CLASS="para"
>which reads &quot;multiply <CODE
CLASS="literal"
>$a</CODE
> by 3&quot;.  You can do this with almost any
binary operator in Perl, even some that you can't do it with in C:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$line .= &quot;\n&quot;;  # Append newline to $line.
$fill x= 80;    # Make string $fill into 80 repeats of itself.
$val ||= &quot;2&quot;;   # Set $val to 2 if it isn't already set.</PRE
></P
><P
CLASS="para"
>Line 6 of our grade example contains two string concatenations, one
of which is an assignment operator.  And line 14 contains a <CODE
CLASS="literal"
>+=</CODE
>.</P
><P
CLASS="para"
>Regardless of which kind of assignment operator you use, the final value
is returned as the value of the assignment as a whole.  (This is unlike,
say, Pascal, in which assignment is a statement and has no value.)
This is why we could say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>chop($number = &lt;STDIN&gt;);</PRE
></P
><P
CLASS="para"
>and have it chop the final value of <CODE
CLASS="literal"
>$number</CODE
>.  You also frequently see
assignment as the condition of a <B
CLASS="emphasis.bold"
>while</B
> loop, as in line 4 of our grade
example.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.4"
>1.5.4 Autoincrement and Autodecrement Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-971"
></A
><A
CLASS="indexterm"
NAME="AUTOID-973"
></A
><A
CLASS="indexterm"
NAME="AUTOID-975"
></A
><A
CLASS="indexterm"
NAME="AUTOID-978"
></A
><A
CLASS="indexterm"
NAME="AUTOID-981"
></A
>As if <CODE
CLASS="literal"
>$variable += 1</CODE
> weren't short enough, Perl borrows from C
an even shorter way to increment a variable.  The autoincrement and
autodecrement operators simply add (or subtract) one from the value of the
variable.  They can be placed on either side of the variable, depending on
when you want them to be evaluated (see <A
CLASS="xref"
HREF="ch01_05.htm#PERL2-CH-1-TAB-3"
TITLE="Unary Arithmetic Operators"
>Table 1.3</A
>).</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PERL2-CH-1-TAB-3"
>Table 1.3: Unary Arithmetic Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Name</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Result</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>++$a, $a++</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Autoincrement</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Add 1 to <CODE
CLASS="literal"
>$a</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>--$a, $a--</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Autodecrement</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Subtract 1 from <CODE
CLASS="literal"
>$a</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If you place one of the auto operators before the variable, it is known as
a pre-incremented (pre-decremented) variable.  Its value will be changed
before it is referenced.  If it is placed 
after the variable, it is known
as a post-incremented (post-decremented) variable and its value is changed
after it is used.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = 5;        # $a is assigned 5
$b = ++$a;     # $b is assigned the incremented value of $a, 6
$c = $a--;     # $c is assigned 6, then $a is decremented to 5</PRE
></P
><P
CLASS="para"
>Line 15 of our grade example increments the number of scores by one, so
that we'll know how many scores we're averaging the grade over.  It uses
a post-increment operator (<CODE
CLASS="literal"
>$scores++</CODE
>), but in this case it doesn't
matter, since the expression is in a void context, which is just a funny
way of saying that the expression is being evaluated only for the side
effect of incrementing the variable.  The value returned is being thrown
away.[<A
CLASS="footnote"
HREF="#AUTOID-1012"
>21</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-1012"
>[21]</A
> The optimizer will notice this and optimize the
post-increment into a pre-increment, because that's a little more
efficient to execute.  (You didn't need to know that, but we
hoped it would cheer you up.)</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.5"
>1.5.5 Logical Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1017"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1020"
></A
>Logical operators, also known as &quot;short-circuit&quot; operators, allow the
program to make decisions based on multiple criteria, without using
nested conditionals.  They are known as short-circuit because they skip
evaluating their right argument if evaluating their left argument is
sufficient to determine the overall value.</P
><P
CLASS="para"
>Perl actually has two sets of logical operators, a crufty old set
borrowed from C, and a nifty new set of ultralow-precedence operators
that parse more like people expect them to parse, and are also easier to
read.  (Once they're parsed, they behave identically though.) See
<A
CLASS="xref"
HREF="ch01_05.htm#PERL2-CH-1-TAB-4"
TITLE="Logical Operators"
>Table 1.4</A
> for examples of logical operators.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PERL2-CH-1-TAB-4"
>Table 1.4: Logical Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Name</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Result</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a &amp;&amp; $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>And</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> is false, 
<CODE
CLASS="literal"
>$b</CODE
> otherwise</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a || $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Or</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> 
is true, <CODE
CLASS="literal"
>$b</CODE
> otherwise</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>! $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Not</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> is not true</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a and $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>And</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> is false,
<CODE
CLASS="literal"
>$b</CODE
> otherwise</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a or $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Or</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> 
is true, <CODE
CLASS="literal"
>$b</CODE
> otherwise</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>not $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Not</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> is not true</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Since the logical operators &quot;short circuit&quot; the way they do, they're
often used to conditionally execute code.  The following line (from our
grade example) tries to open the file <EM
CLASS="emphasis"
>grades</EM
>.</P
><PRE
CLASS="programlisting"
>open(GRADES, &quot;grades&quot;) or die &quot;Can't open file grades: $!\n&quot;;</PRE
><P
CLASS="para"
>If it opens the file,
it will jump to the next line of the program.  If it can't open the
file, it will provide us with an error message and then stop execution.</P
><P
CLASS="para"
>Literally, the above message means &quot;Open <EM
CLASS="emphasis"
>grades</EM
> or die!&quot;  Besides being another example of
natural language, the short-circuit operators preserve the visual flow.
Important actions are listed down the left side of the screen, and
secondary actions are hidden off to the right.  (The <B
CLASS="emphasis.bold"
>$!</B
> variable
contains the error message returned by the operating system&nbsp;- see
&quot;Special Variables&quot; in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
>).
Of course, these logical operators can also be used within the more
traditional kinds of conditional constructs, such as the <B
CLASS="emphasis.bold"
>if</B
> and <B
CLASS="emphasis.bold"
>while</B
>
statements.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.6"
>1.5.6 Comparison Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1095"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1097"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1100"
></A
><A
CLASS="indexterm"
NAME="AUTOID-1103"
></A
>Comparison, or relational, operators tell us how two scalar values
(numbers or strings) relate to each other.  There are two sets of
operators&nbsp;- one does numeric comparison and the other
does string comparison.  (In either case, the arguments will be &quot;coerced&quot;
to have the appropriate type first.)  <A
CLASS="xref"
HREF="ch01_05.htm#PERL2-CH-1-TAB-5"
TITLE="Some Numeric and String Comparison Operators"
>Table 1.5</A
> assumes <CODE
CLASS="literal"
>$a</CODE
>
and <CODE
CLASS="literal"
>$b</CODE
> are the left and right arguments, respectively.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PERL2-CH-1-TAB-5"
>Table 1.5: Some Numeric and String Comparison Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Comparison</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Numeric</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>String</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Return Value</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Equal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>==</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>eq</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> is equal to <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Not equal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>!=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ne</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> is not equal to <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>lt</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> is less than <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&gt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>gt</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> is greater than <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than or equal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>le</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if <CODE
CLASS="literal"
>$a</CODE
> not greater than <CODE
CLASS="literal"
>$b</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Comparison</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;=&gt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>cmp</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>0 if equal, 1 if <CODE
CLASS="literal"
>$a</CODE
> greater, -1 if <CODE
CLASS="literal"
>$b</CODE
> greater</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The last pair of operators (<CODE
CLASS="literal"
>&lt;=&gt;</CODE
> and <CODE
CLASS="literal"
>cmp</CODE
>)
are entirely redundant. However,
they're incredibly useful in <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>
subroutines (see <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>).[<A
CLASS="footnote"
HREF="#AUTOID-1178"
>22</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-1178"
>[22]</A
> Some folks feel that such redundancy is evil because it keeps a language
from being minimalistic, or orthogonal.  But Perl isn't an orthogonal
language; it's a diagonal language.  By which we mean that Perl doesn't
force you to always go at right angles.  Sometimes you just want
to follow the hypotenuse of the triangle to get where you're going.
TMTOWTDI is about shortcuts.  Shortcuts are about efficiency.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-5.7"
>1.5.7 File Test Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1183"
></A
>The file test operators allow you to test whether certain file attributes are
set before you go and blindly muck about with the files.  For example, it
would be very nice to know that the file <EM
CLASS="emphasis"
>/etc/passwd</EM
> already exists
before you go and open it as a new file, wiping out everything that was in
there before. See <A
CLASS="xref"
HREF="ch01_05.htm#PERL2-CH-1-TAB-6"
TITLE="Some File Test Operators"
>Table 1.6</A
> for examples of file test operators.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PERL2-CH-1-TAB-6"
>Table 1.6: Some File Test Operators</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Name</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Result</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-e $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Exists</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if file named in <CODE
CLASS="literal"
>$a</CODE
> exists</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-r $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Readable</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if file named in <CODE
CLASS="literal"
>$a</CODE
> is readable</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-w $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Writable</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if file named in <CODE
CLASS="literal"
>$a</CODE
> is writable</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-d $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Directory</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if file named in <CODE
CLASS="literal"
>$a</CODE
> is a directory</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-f $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if file named in <CODE
CLASS="literal"
>$a</CODE
> is a regular file</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-T $a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Text File</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>True if file named in <CODE
CLASS="literal"
>$a</CODE
> is a text file</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Here are some examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>-e &quot;/usr/bin/perl&quot; or warn &quot;Perl is improperly installed\n&quot;;
-f &quot;/vmunix&quot; and print &quot;Congrats, we seem to be running BSD Unix\n&quot;;</PRE
></P
><P
CLASS="para"
>Note that a regular file is not the same thing as a text file.  Binary
files like <EM
CLASS="emphasis"
>/vmunix</EM
> are regular files, but they aren't text files.
Text files are the opposite of binary files, while regular files are the
opposite of irregular files like directories and devices.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-1239"
></A
>There are a lot of file test operators, many of which we didn't list.
Most of the file tests are unary Boolean operators: they take only one
operand, a scalar that evaluates to a file or a filehandle, and they
return either a true or false value.  A few of them return something fancier,
like the file's size or age, but you can look those up when you need them.<A
CLASS="indexterm"
NAME="AUTOID-1242"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_04.htm"
TITLE="1.4 Filehandles"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.4 Filehandles"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_06.htm"
TITLE="1.6 Control Structures"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.6 Control Structures"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.4 Filehandles</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.6 Control Structures</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
