<HTML
><HEAD
>
<TITLE>[Chapter 1] 1.4 Filehandles</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:17Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. An Overview of Perl"><LINK
REL="prev"
HREF="ch01_03.htm"
TITLE="1.3 A Grade Example"><LINK
REL="next"
HREF="ch01_05.htm"
TITLE="1.5 Operators"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_03.htm"
TITLE="1.3 A Grade Example"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.3 A Grade Example"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. An Overview of Perl"
>Chapter 1<BR>An Overview of Perl</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_05.htm"
TITLE="1.5 Operators"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.5 Operators"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-4"
>1.4 Filehandles</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH01.IOF1"
></A
><A
CLASS="indexterm"
NAME="CH01.IOF2"
></A
><A
CLASS="indexterm"
NAME="CH01.FH"
></A
>Unless you're using artificial intelligence to model a solipsistic philosopher,
your program needs some way to communicate with the outside world.  In
lines 3 and 4 of our grade example you'll see the word <CODE
CLASS="literal"
>GRADES</CODE
>, which
exemplifies another of Perl's data types, the <EM
CLASS="emphasis"
>filehandle</EM
>.  A filehandle is
just a name you give to a file, device, socket, or pipe to help you
remember which one you're talking about, and to hide some of the
complexities of buffering and such.  (Internally, filehandles are
similar to streams from a language like C++, or I/O channels from
BASIC.) </P
><P
CLASS="para"
>Filehandles make it easier
for you to get input from and send
output to many different places.  Part of what makes Perl a good glue
language is that it can talk to many files and processes at once.
Having nice symbolic names for various external objects is just part of
being a good glue language.[<A
CLASS="footnote"
HREF="#AUTOID-765"
>17</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-765"
>[17]</A
> Some of the other things that make Perl a good glue language are: it's
8-bit clean, it's embeddable, and you can embed other things in it via
extension modules.  It's concise, and networks easily.  It's
environmentally conscious, so to speak.  You can invoke it in many
different ways (as we saw earlier).  But most of all, the language
itself is not so rigidly structured that you can't get it to &quot;flow&quot;
around your problem.  It comes back to that TMTOWTDI thing again.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-768"
></A
><A
CLASS="indexterm"
NAME="AUTOID-771"
></A
><A
CLASS="indexterm"
NAME="AUTOID-773"
></A
>You create a filehandle and attach it to a file by using the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
>
function.  <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> takes two parameters: the filehandle and the filename
you want to associate it with.  Perl also gives you some predefined (and
preopened) filehandles.  <CODE
CLASS="literal"
>STDIN</CODE
> is your program's normal input
channel, while <CODE
CLASS="literal"
>STDOUT</CODE
> is your program's normal output channel.  And
<CODE
CLASS="literal"
>STDERR</CODE
> is an additional output channel so that your program can make
snide remarks off to the side while it transforms (or attempts to
transform) your input into your output.[<A
CLASS="footnote"
HREF="#AUTOID-780"
>18</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-780"
>[18]</A
> These filehandles are typically attached to your terminal, so you can
type to your program and see its output, but they may also be attached to
files (and such).  Perl can give you these predefined handles because
your operating system already provides them, one way or another.  Under
UNIX, processes inherit standard input, output, and error from their
parent process, typically a shell.  One of the duties of a shell is to
set up these I/O streams so that the child process doesn't need to worry
about them.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Since you can use the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> function to create filehandles for various
purposes (input, output, piping), you need to be able to specify which
behavior you want.  As you would do on the UNIX command line, you
simply add characters to the filename.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>open(SESAME, &quot;filename&quot;);               # read from existing file
open(SESAME, &quot;&lt;filename&quot;);              #   (same thing, explicitly)
open(SESAME, &quot;&gt;filename&quot;);              # create file and write to it
open(SESAME, &quot;&gt;&gt;filename&quot;);             # append to existing file
open(SESAME, &quot;| output-pipe-command&quot;);  # set up an output filter
open(SESAME, &quot;input-pipe-command |&quot;);   # set up an input filter</PRE
></P
><P
CLASS="para"
>As you can see, the name you pick is arbitrary.
Once opened, the filehandle <CODE
CLASS="literal"
>SESAME</CODE
> can be used to access the file or pipe
until it is explicitly closed (with, you guessed it, <CODE
CLASS="literal"
>close(SESAME)</CODE
>),
or the filehandle is attached to another file by a subsequent <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
>
on the same filehandle.[<A
CLASS="footnote"
HREF="#AUTOID-790"
>19</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-790"
>[19]</A
> Opening an already opened filehandle implicitly closes the first file,
making it inaccessible to the filehandle, and opens a different file.  You
must be careful that this is what you really want to do.  Sometimes
it happens accidentally, like when you say <CODE
CLASS="literal"
>open($handle,$file)</CODE
>, and
<CODE
CLASS="literal"
>$handle</CODE
> happens to contain the null string.  Be sure to set <CODE
CLASS="literal"
>$handle</CODE
> to
something unique, or you'll just open a new file on the null filehandle.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Once you've opened a filehandle for input (or if you want to use
<CODE
CLASS="literal"
>STDIN</CODE
>), you can read a line using the line reading operator,
<CODE
CLASS="literal"
>&lt;&gt;</CODE
>.  This is also known as the angle operator, because of its
shape.  The angle operator encloses the filehandle (<CODE
CLASS="literal"
>&lt;SESAME&gt;</CODE
>)
you want to read lines from.[<A
CLASS="footnote"
HREF="#AUTOID-799"
>20</A
>]
An example using the <CODE
CLASS="literal"
>STDIN</CODE
> filehandle to read an answer supplied
by the user would look something like this:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-799"
>[20]</A
> The empty angle operator, <CODE
CLASS="literal"
>&lt;&gt;</CODE
>, will read lines from all the files
specified on the command line, or <CODE
CLASS="literal"
>STDIN</CODE
>, if none were specified.  (This
is standard behavior for many UNIX filter programs.)</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print STDOUT &quot;Enter a number: &quot;;          # ask for a number
$number = &lt;STDIN&gt;;                        # input the number
print STDOUT &quot;The number is $number\n&quot;;   # print the number</PRE
></P
><P
CLASS="para"
>Did you see what we just slipped by you?  What's the <CODE
CLASS="literal"
>STDOUT</CODE
> doing in
those <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> statements there?  Well, that's one of the ways you can use
an output filehandle.  A filehandle may be supplied as the first
argument to the <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> statement, and if present, tells the output
where to go.  In this case, the filehandle is redundant, because the
output would have gone to <CODE
CLASS="literal"
>STDOUT</CODE
> anyway.  Much as <CODE
CLASS="literal"
>STDIN</CODE
> is the
default for input, <CODE
CLASS="literal"
>STDOUT</CODE
> is the default for output.  (In line 18 of
our grade example, we left it out, to avoid confusing you up till now.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-814"
></A
><A
CLASS="indexterm"
NAME="AUTOID-817"
></A
><A
CLASS="indexterm"
NAME="AUTOID-819"
></A
>We also did something else to trick you.  If you try the above
example, you may notice that you get an extra blank line.  This
happens because the read does not automatically remove the newline
from your input line (your input would be, for example,
&quot;<CODE
CLASS="literal"
>9\n</CODE
>&quot;).  For those times when you do want to remove
the newline, Perl provides the <A
CLASS="xref"
HREF="ch03_014.htm"
TITLE="chop"
><B
CLASS="xref.cmd"
>chop</B
></A
> and
<A
CLASS="xref"
HREF="ch03_013.htm"
TITLE="chomp"
><B
CLASS="xref.cmd"
>chomp</B
></A
> functions.  <A
CLASS="xref"
HREF="ch03_014.htm"
TITLE="chop"
><B
CLASS="xref.cmd"
>chop</B
></A
> will indiscriminately remove (and return)
the last character passed to it, while <A
CLASS="xref"
HREF="ch03_013.htm"
TITLE="chomp"
><B
CLASS="xref.cmd"
>chomp</B
></A
> will only remove the end of record marker
(generally, &quot;<CODE
CLASS="literal"
>\n</CODE
>&quot;), and return the number of
characters so removed.  You'll often see this idiom for inputting a
single line:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>chop($number = &lt;STDIN&gt;);    # input number and remove newline</PRE
></P
><P
CLASS="para"
>which means the same thing as</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$number = &lt;STDIN&gt;;          # input number
chop($number);              # remove newline</PRE
><A
CLASS="indexterm"
NAME="AUTOID-832"
></A
><A
CLASS="indexterm"
NAME="AUTOID-833"
></A
><A
CLASS="indexterm"
NAME="AUTOID-834"
></A
></P
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_03.htm"
TITLE="1.3 A Grade Example"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.3 A Grade Example"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_05.htm"
TITLE="1.5 Operators"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.5 Operators"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.3 A Grade Example</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.5 Operators</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
