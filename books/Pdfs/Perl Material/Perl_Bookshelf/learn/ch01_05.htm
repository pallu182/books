<HTML
><HEAD
>
<TITLE>[Chapter 1] 1.5 A Stroll Through Perl</TITLE>
<META
NAME="DC.title"
CONTENT="Learning Perl"><META
NAME="DC.creator"
CONTENT="Randal Schwartz, Tom Christiansen &amp; Larry Wall"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:08Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-284-0"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction"><LINK
REL="prev"
HREF="ch01_04.htm"
TITLE="1.4 Basic Concepts"><LINK
REL="next"
HREF="ch01_06.htm"
TITLE="1.6 Exercise"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Learning Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Learning Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/lsrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_04.htm"
TITLE="1.4 Basic Concepts"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.4 Basic Concepts"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction"
>Chapter 1<BR>Introduction</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_06.htm"
TITLE="1.6 Exercise"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.6 Exercise"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-39405"
>1.5 A Stroll Through Perl</A
></H2
><P
CLASS="para"
>We begin our journey through Perl by taking a little stroll. This stroll presents a number of different features by hacking on a small application. The explanations here are extremely brief; each subject area is discussed in <EM
CLASS="emphasis"
>much</EM
> greater detail later in this book. But this little stroll should give you a quick taste for the language, and you can decide if you really want to finish this book rather than read some more Usenet news or run off to the <A
CLASS="indexterm"
NAME="ch01-idx-868854-0"
></A
>ski slopes.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869099"
>1.5.1 The "Hello, World" Program</A
></H3
><P
CLASS="para"
>Let's look at a little program that actually <EM
CLASS="emphasis"
>does</EM
> something. Here is your basic <A
CLASS="indexterm"
NAME="ch01-idx-868855-0"
></A
>"Hello, world" program:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
<A
CLASS="indexterm"
NAME="ch01-idx-868856-0"
></A
>print (&quot;Hello, world!\n&quot;);</PRE
><P
CLASS="para"
>The first line is the incantation that says this is a Perl program. It's also a comment for Perl; remember that a comment is anything from a pound sign to the end of that line, as in many interpreter programming languages. Unlike all other comments in the program, the one on the first line is special: Perl looks at that line for any optional arguments. In this case, the <KBD
CLASS="command"
>-w</KBD
> switch was used. This very important switch tells Perl to produce extra warning messages about potentially dangerous constructs. You should always develop your programs under <KBD
CLASS="command"
>-w</KBD
>.</P
><P
CLASS="para"
>The second line is the entire executable part of this program. Here we see a <CODE
CLASS="literal"
>print</CODE
> function. The built-in function <CODE
CLASS="literal"
>print</CODE
> starts it off, and in this case has just one argument, a C-like text string. Within this string, the character combination <CODE
CLASS="literal"
>\n</CODE
> stands for a newline character. The <CODE
CLASS="literal"
>print</CODE
> statement is terminated by a semicolon (<CODE
CLASS="literal"
>;</CODE
>). As in C, all simple statements in Perl are terminated by a <A
CLASS="indexterm"
NAME="ch01-idx-868857-0"
></A
>semicolon.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869681"
>3</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869681"
>[3]</A
> The semicolon can be omitted when the statement is the last statement of a block or file or <CODE
CLASS="literal"
>eval</CODE
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>When you invoke this program, the kernel fires up a Perl interpreter, which parses the entire program (all two lines of it, counting the first, comment line) and then executes the compiled form. The first and only operation is the execution of the <CODE
CLASS="literal"
>print</CODE
> function, which sends its arguments to the output. After the program has completed, the Perl process exits, returning back a successful exit code to the parent shell.</P
><P
CLASS="para"
>Soon you'll see Perl programs where <CODE
CLASS="literal"
>print</CODE
> and other functions are sometimes called with parentheses, other times without them. The rule is simple: in Perl, parentheses for built-in functions are never required nor forbidden. Their use can help or hinder clarity, so use your own judgment.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869100"
>1.5.2 Asking Questions and Remembering the Result</A
></H3
><P
CLASS="para"
>Let's add a bit more sophistication. The <CODE
CLASS="literal"
>Hello,</CODE
> <CODE
CLASS="literal"
>world</CODE
> greeting is a touch cold and inflexible. Let's have the program call you by your name. To do this, we need a place to hold the name, a way to ask for the name, and a way to get a response.</P
><P
CLASS="para"
>One kind of place to hold values (like a name) is a <A
CLASS="indexterm"
NAME="ch01-idx-868858-0"
></A
><EM
CLASS="emphasis"
>scalar variable</EM
>. For this program, we'll use the scalar variable <CODE
CLASS="literal"
>$name</CODE
> to hold your name. We'll go into more detail in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="Scalar Data"
>Chapter 2, <CITE
CLASS="chapter"
>Scalar Data</CITE
></A
>, about what these variables can hold, and what you can do with them. For now, assume that you can hold a single number or string (sequence of characters) in a scalar variable.</P
><P
CLASS="para"
>The program needs to ask for the name. To do that, we need a way to <A
CLASS="indexterm"
NAME="ch01-idx-868859-0"
></A
>prompt and a way to accept input. The previous program showed us how to prompt: use the <CODE
CLASS="literal"
>print</CODE
> function. And the way to get a line from the terminal is with the <CODE
CLASS="literal"
>&lt;STDIN&gt;</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868860-0"
></A
> construct, which (as we're using it here) grabs one line of input. We assign this input to the <CODE
CLASS="literal"
>$name</CODE
> variable. This gives us the program:</P
><PRE
CLASS="programlisting"
>print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;</PRE
><P
CLASS="para"
>The value of <CODE
CLASS="literal"
>$name</CODE
> at this point has a terminating newline (<CODE
CLASS="literal"
>Randal</CODE
> comes in as <CODE
CLASS="literal"
>Randal\n</CODE
>). To get rid of that, we use the <A
CLASS="indexterm"
NAME="ch01-idx-868861-0"
></A
><CODE
CLASS="literal"
>chomp</CODE
> function, which takes a scalar variable as its sole argument and removes the trailing newline (record separator), if present, from the string value of the variable:</P
><PRE
CLASS="programlisting"
>chomp ($name);</PRE
><P
CLASS="para"
>Now all we need to do is say <CODE
CLASS="literal"
>Hello,</CODE
> followed by the value of the <CODE
CLASS="literal"
>$name</CODE
> variable, which we can do in a shell-like fashion by embedding the variable inside the <A
CLASS="indexterm"
NAME="ch01-idx-868862-0"
></A
>quoted string:</P
><PRE
CLASS="programlisting"
>print &quot;Hello, $name!\n&quot;;</PRE
><P
CLASS="para"
>As with the shell, if we want a dollar sign rather than a scalar variable reference, we can precede the dollar sign with a backslash.</P
><P
CLASS="para"
>Putting it all together, we get:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
print &quot;Hello, $name!\n&quot;;</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869020"
>1.5.3 Adding Choices</A
></H3
><P
CLASS="para"
>Now, let's say we have a special greeting for Randal, but want an ordinary greeting for anyone else. To do this, we need to compare the name that was entered with the string <CODE
CLASS="literal"
>Randal</CODE
>, and if it's the same, do something special. Let's add a C-like <A
CLASS="indexterm"
NAME="ch01-idx-868863-0"
></A
><EM
CLASS="emphasis"
>if-then-else</EM
> branch and a comparison to the program:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name eq &quot;Randal&quot;) {
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
}</PRE
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch01-idx-868864-0"
></A
><CODE
CLASS="literal"
>eq</CODE
> operator compares two strings. If they are equal (character-for-character, and have the same length), the result is true. (There's no comparable operator[<A
CLASS="footnote"
HREF="#ch01-pgfId-1665"
>4</A
>] in C or C++.)</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-1665"
>[4]</A
> Well, OK, there's a standard <CODE
CLASS="literal"
>libc</CODE
> subroutine. But that's not an operator.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>if</CODE
> statement selects which <A
CLASS="indexterm"
NAME="ch01-idx-868865-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868865-1"
></A
><EM
CLASS="emphasis"
>block</EM
> of statements (between matching curly braces) is executed; if the expression is true, it's the first block, otherwise it's the second block.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-18448"
>1.5.4 Guessing the Secret Word</A
></H3
><P
CLASS="para"
>Well, now that we have the name, let's have the person running the program guess a <A
CLASS="indexterm"
NAME="ch01-idx-868866-0"
></A
>secret word. For everyone except Randal, we'll have the program repeatedly ask for guesses until the person guesses properly. First the program, and then an explanation:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
$secretword = &quot;llama&quot;; # the secret word
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Randal&quot;) {
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
  }
}</PRE
><P
CLASS="para"
>First, we define the secret word by putting it into another scalar variable, <CODE
CLASS="literal"
>$secretword</CODE
>. After the greeting the (non-Randal) person is asked (with another <CODE
CLASS="literal"
>print</CODE
>) for the guess. The guess is compared with the secret word using the <A
CLASS="indexterm"
NAME="ch01-idx-868867-0"
></A
><CODE
CLASS="literal"
>ne</CODE
> operator, which returns true if the strings are not equal (this is the logical opposite of the <CODE
CLASS="literal"
>eq</CODE
> operator). The result of the comparison controls a <A
CLASS="indexterm"
NAME="ch01-idx-868868-0"
></A
><CODE
CLASS="literal"
>while</CODE
> loop, which executes the block as long as the comparison is true.</P
><P
CLASS="para"
>Of course, this is not a very secure program, because anyone who is tired of guessing can merely interrupt the program and get back to the prompt, or even look at the source to determine the word. But, we weren't trying to write a security system, just an example for this section.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869132"
>1.5.5 More than One Secret Word</A
></H3
><P
CLASS="para"
>Let's see how we can modify this to allow more than one valid secret word. Using what we've already seen, we could compare the guess repeatedly against a series of good answers stored in separate scalar variables. However, such a list would be hard to modify or read in from a file or compute based on the day of the week.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-868869-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868869-1"
></A
>A better solution is to store all possible answers in a data structure called a <EM
CLASS="emphasis"
>list</EM
>, or (preferably) an <EM
CLASS="emphasis"
>array</EM
>. Each <EM
CLASS="emphasis"
>element</EM
> of the array is a separate scalar variable that can be independently set or accessed. The entire array can also be given a value in one fell swoop. We can <A
CLASS="indexterm"
NAME="ch01-idx-868870-0"
></A
>assign a value to the entire array named <CODE
CLASS="literal"
>@words</CODE
> so that it contains three possible good passwords:</P
><PRE
CLASS="programlisting"
>@words = (&quot;camel&quot;,&quot;llama&quot;,&quot;alpaca&quot;);</PRE
><P
CLASS="para"
>Array variable names begin with <A
CLASS="indexterm"
NAME="ch01-idx-868871-0"
></A
><CODE
CLASS="literal"
>@</CODE
>, so they are distinct from scalar variable names. Another way to write this so that we don't have to put all those quote marks there is with the <CODE
CLASS="literal"
>qw()</CODE
> operator, like so:</P
><PRE
CLASS="programlisting"
>@words = qw(camel llama alpaca);</PRE
><P
CLASS="para"
>These mean exactly the same thing; the <CODE
CLASS="literal"
>qw</CODE
> makes it as if we had quoted each of three strings.</P
><P
CLASS="para"
>Once the array is assigned, we can <A
CLASS="indexterm"
NAME="ch01-idx-868872-0"
></A
>access each element using a <A
CLASS="indexterm"
NAME="ch01-idx-868873-0"
></A
>subscript reference. So <CODE
CLASS="literal"
>$words[0]</CODE
> is <CODE
CLASS="literal"
>camel</CODE
>, <CODE
CLASS="literal"
>$words[1]</CODE
> is <CODE
CLASS="literal"
>llama</CODE
>, and <CODE
CLASS="literal"
>$words[2]</CODE
> is <CODE
CLASS="literal"
>alpaca</CODE
>. The subscript can be an expression as well, so if we set <CODE
CLASS="literal"
>$i</CODE
> to 2, then <CODE
CLASS="literal"
>$words[$i]</CODE
> is <CODE
CLASS="literal"
>alpaca</CODE
>. (Subscript references start with <CODE
CLASS="literal"
>$</CODE
> rather than <CODE
CLASS="literal"
>@</CODE
> because they refer to a single element of the array rather than the whole array.) Going back to our previous example:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
@words = qw(camel llama alpaca);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name eq &quot;Randal&quot;) {
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;;        # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    $i = 0; # try this word first
    $correct = &quot;maybe&quot;;             # is the guess correct or not?
    while ($correct eq &quot;maybe&quot;) {   # keep checking til we know
        if ($words[$i] eq $guess) { # right?
            $correct = &quot;yes&quot;;       # yes!
        } elsif ($i &lt; 2) {          # more words to look at?
            $i = $i + 1;            # look at the next word next time
        } else {                    # no more words, must be bad
            print &quot;Wrong, try again. What is the secret word?&quot;;
            $guess = &lt;STDIN&gt;;
            chomp ($guess);
            $i = 0;            # start checking at the first word again
        }
    } # end of while not correct
} # end of &quot;not Randal&quot;</PRE
><P
CLASS="para"
>You'll notice we're using the scalar variable <CODE
CLASS="literal"
>$correct</CODE
> to indicate that we are either still looking for a good password or that we've found one.</P
><P
CLASS="para"
>This program also shows the <A
CLASS="indexterm"
NAME="ch01-idx-868814-0"
></A
><CODE
CLASS="literal"
>elsif</CODE
> block of the <CODE
CLASS="literal"
>if-then-else</CODE
> statement. This exact construct is not present in all programming languages; it's an abbreviation of the <CODE
CLASS="literal"
>else</CODE
> block together with a new <CODE
CLASS="literal"
>if</CODE
> condition, but without nesting inside yet another pair of curly braces. It's a very Perl-like thing to compare a set of conditions in a cascaded <CODE
CLASS="literal"
>if-elsif-elsif-elsif-else</CODE
> chain. Perl doesn't really have the equivalent of C's "switch" or Pascal's "case" statement, although you can build one yourself without too much trouble. See <A
CLASS="olink"
HREF="../prog/ch02_01.htm"
>Chapter 2</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
> or the <EM
CLASS="emphasis"
>perlsyn </EM
>(1) manpage for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869163"
>1.5.6 Giving Each Person a Different Secret Word</A
></H3
><P
CLASS="para"
>In the previous program, any person who comes along could guess any of the three words and be successful. If we want the secret word to be different for each person, we'll need a table that matches up people with words:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Person</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Secret Word</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fred</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>camel</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Barney</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>llama</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Betty</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>alpaca</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Wilma</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>alpaca</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Notice that both Betty and Wilma have the same secret word. This is fine.</P
><P
CLASS="para"
>The easiest way to store such a table in Perl is with a <A
CLASS="indexterm"
NAME="ch01-idx-868874-0"
></A
><EM
CLASS="emphasis"
>hash</EM
>. Each element of the hash holds a separate scalar value (just like the other type of array), but the hashes are referenced by a <A
CLASS="indexterm"
NAME="ch01-idx-868875-0"
></A
><EM
CLASS="emphasis"
>key</EM
>, which can be any scalar value (any string or number, including noninteger and negative values). To create a hash called <CODE
CLASS="literal"
>%words</CODE
> (notice the <A
CLASS="indexterm"
NAME="ch01-idx-868876-0"
></A
><CODE
CLASS="literal"
>%</CODE
> rather than <CODE
CLASS="literal"
>@</CODE
>) with the keys and values given in the table above, we <A
CLASS="indexterm"
NAME="ch01-idx-868877-0"
></A
>assign a value to <CODE
CLASS="literal"
>%words</CODE
> (much as we did earlier with the array):</P
><PRE
CLASS="programlisting"
>%words = qw(
    fred       camel
    barney     llama
    betty      alpaca
    wilma      alpaca
);</PRE
><P
CLASS="para"
>Each pair of values in the list represents one key and its corresponding value in the hash. Note that we broke this assignment over many lines without any sort of line-continuation character, because whitespace is generally insignificant in a Perl program.</P
><P
CLASS="para"
>To find the secret word for Betty, we need to use Betty as the key in a reference to the hash <CODE
CLASS="literal"
>%words</CODE
>, via some expression such as <CODE
CLASS="literal"
>$words{&quot;betty&quot;}</CODE
>. The value of this reference is <CODE
CLASS="literal"
>alpaca</CODE
>, similar to what we had before with the other array. Also as before, the key can be any expression, so setting <CODE
CLASS="literal"
>$person</CODE
> to <CODE
CLASS="literal"
>betty</CODE
> and evaluating <CODE
CLASS="literal"
>$words{$person}</CODE
> gives <CODE
CLASS="literal"
>alpaca</CODE
> as well.</P
><P
CLASS="para"
>Putting all this together, we get a program like this:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
%words = qw(
    fred        camel
    barney      llama
    betty       alpaca
    wilma       alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name eq &quot;Randal&quot;) {
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;;     # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><P
CLASS="para"
>Note the lookup of the secret word. If the name is not found, the value of <CODE
CLASS="literal"
>$secretword</CODE
> will be an empty string,[<A
CLASS="footnote"
HREF="#ch01-pgfId-869272"
>5</A
>] which we can then check for if we want to define a default secret word for everyone else. Here's how that looks:<PRE
CLASS="programlisting"
>[... rest of program deleted ...]
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) {     # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
    }
    print &quot;What is the secret word? &quot;;
[... rest of program deleted ...]</PRE
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869272"
>[5]</A
> Well, OK, it's the <CODE
CLASS="literal"
>undef</CODE
> value, but it looks like an empty string to the <CODE
CLASS="literal"
>eq</CODE
> operator. You'd get a warning about this if you used <B
CLASS="emphasis.bold"
>-w</B
> on the command line, which is why we omitted it here.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869224"
>1.5.7 Handling Varying Input Formats</A
></H3
><P
CLASS="para"
>If I enter <CODE
CLASS="literal"
>Randal</CODE
> <CODE
CLASS="literal"
>L.</CODE
> <CODE
CLASS="literal"
>Schwartz</CODE
> or <CODE
CLASS="literal"
>randal</CODE
> rather than <CODE
CLASS="literal"
>Randal</CODE
>, I'm lumped in with the rest of the users, because the <CODE
CLASS="literal"
>eq</CODE
> comparison is an exact equality. Let's look at one way to handle that.</P
><P
CLASS="para"
>Suppose I wanted to look for any string that began with <CODE
CLASS="literal"
>Randal</CODE
>, rather than just a string that was equal to <CODE
CLASS="literal"
>Randal</CODE
>. I could do this in <EM
CLASS="emphasis"
>sed</EM
>, <EM
CLASS="emphasis"
>awk</EM
>, or <EM
CLASS="emphasis"
>grep</EM
> with a <A
CLASS="indexterm"
NAME="ch01-idx-868878-0"
></A
>regular expression: a template that defines a collection of strings that match. As<EM
CLASS="emphasis"
> </EM
>in<EM
CLASS="emphasis"
> sed</EM
>, <EM
CLASS="emphasis"
>awk</EM
>, or <EM
CLASS="emphasis"
>grep</EM
>, the regular expression in Perl that matches any string that begins with <CODE
CLASS="literal"
>Randal</CODE
> is <CODE
CLASS="literal"
>^Randal</CODE
>. To match this against the string in <CODE
CLASS="literal"
>$name</CODE
>, we use the <A
CLASS="indexterm"
NAME="ch01-idx-868879-0"
></A
>match operator as follows:</P
><PRE
CLASS="programlisting"
>if ($name =~ /^Randal/) {
    ## yes, it matches
} else {
    ## no, it doesn't
}</PRE
><P
CLASS="para"
>Note that the regular expression is delimited by slashes. Within the slashes, spaces and other whitespace are significant, just as they are within strings.</P
><P
CLASS="para"
>This almost does it, but it doesn't handle selecting <CODE
CLASS="literal"
>randal</CODE
> or rejecting <CODE
CLASS="literal"
>Randall</CODE
>. To accept <CODE
CLASS="literal"
>randal</CODE
>, we add the <A
CLASS="indexterm"
NAME="ch01-idx-868880-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868880-1"
></A
><EM
CLASS="emphasis"
>ignore-case</EM
> option, a small <CODE
CLASS="literal"
>i</CODE
> appended after the closing slash. To reject <CODE
CLASS="literal"
>Randall</CODE
>, we add a <A
CLASS="indexterm"
NAME="ch01-idx-868881-0"
></A
><EM
CLASS="emphasis"
>word boundary</EM
> special marker (similar to <EM
CLASS="emphasis"
>vi</EM
> and some versions of <EM
CLASS="emphasis"
>grep</EM
>) in the form of <CODE
CLASS="literal"
>\b</CODE
> in the regular expression. This ensures that the character following the first <CODE
CLASS="literal"
>l</CODE
> in the regular expression is not another letter. This changes the regular expression to be <CODE
CLASS="literal"
>/^randal\b/i</CODE
>, which means "<CODE
CLASS="literal"
>randal</CODE
> at the beginning of the string, no letter or digit following, and OK to be in either case."</P
><P
CLASS="para"
>When put together with the rest of the program, it looks like this:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
%words = qw(
    fred        camel
    barney      llama
    betty       alpaca
    wilma       alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^randal\b/i) {
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) { # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
    }
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><P
CLASS="para"
>As you can see, the program is a far cry from the simple <CODE
CLASS="literal"
>Hello,</CODE
> <CODE
CLASS="literal"
>world</CODE
>, but it's still very small and workable, and does quite a bit for being so short. This is The Perl Way.</P
><P
CLASS="para"
>Perl provides every regular expression feature found in every standard UNIX utility (and even some nonstandard ones). Not only that, but the way Perl handles string matching is about the fastest on the planet, so you don't lose performance. (A <A
CLASS="indexterm"
NAME="ch01-idx-868882-0"
></A
><EM
CLASS="emphasis"
>grep</EM
>-like program written in Perl often beats the vendor-supplied[<A
CLASS="footnote"
HREF="#ch01-pgfId-869628"
>6</A
>] C-coded <EM
CLASS="emphasis"
>grep</EM
> for most inputs. This means that <EM
CLASS="emphasis"
>grep</EM
> doesn't even do its one thing very well.)</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869628"
>[6]</A
> GNU <EM
CLASS="emphasis"
>egrep</EM
> tends to be much faster than Perl at this.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869113"
>1.5.8 Making It Fair for the Rest</A
></H3
><P
CLASS="para"
>So, now I can enter <CODE
CLASS="literal"
>Randal</CODE
> or <CODE
CLASS="literal"
>randal</CODE
> or <CODE
CLASS="literal"
>Randal</CODE
> <CODE
CLASS="literal"
>L.</CODE
> <CODE
CLASS="literal"
>Schwartz</CODE
>, but what about everyone else? Barney still has to say exactly <CODE
CLASS="literal"
>barney</CODE
> (not even <CODE
CLASS="literal"
>barney</CODE
> followed by a space).</P
><P
CLASS="para"
>To be fair to Barney, we need to grab the first word of whatever's entered, and then <A
CLASS="indexterm"
NAME="ch01-idx-868883-0"
></A
>convert it to lowercase <EM
CLASS="emphasis"
>before</EM
> we look up the name in the table. We do this with two operators: the <EM
CLASS="emphasis"
>substitute</EM
><A
CLASS="indexterm"
NAME="ch01-idx-868884-0"
></A
> operator, which finds a regular expression and replaces it with a string, and the <EM
CLASS="emphasis"
>translate</EM
><A
CLASS="indexterm"
NAME="ch01-idx-868885-0"
></A
> operator, to put the string in lowercase.</P
><P
CLASS="para"
>First, the substitute operator: we want to take the contents of <CODE
CLASS="literal"
>$name</CODE
>, find the first nonword character, and zap everything from there to the end of the string.          <CODE
CLASS="literal"
>/\W.*/</CODE
> is the <A
CLASS="indexterm"
NAME="ch01-idx-868886-0"
></A
>regular expression we are looking for: the <CODE
CLASS="literal"
>\W</CODE
> stands for a nonword character (something besides a letter, digit, or underscore), and <CODE
CLASS="literal"
>.*</CODE
> means any characters from there to the end of the line. Now, to zap these characters away, we need to take whatever part of the string matches this regular expression and replace it with nothing:</P
><PRE
CLASS="programlisting"
>$name =~ s/\W.*//;</PRE
><P
CLASS="para"
>We're using the same <A
CLASS="indexterm"
NAME="ch01-idx-868887-0"
></A
><CODE
CLASS="literal"
>=~</CODE
> operator that we did before, but now on the right we have a substitute operator: the letter <CODE
CLASS="literal"
>s</CODE
> followed by a slash-delimited regular expression and string. (The string in this example is the empty string between the second and third slashes.) This operator looks and acts very much like the substitutions of the various editors.</P
><P
CLASS="para"
>Now, to get whatever's left into lowercase, we translate the string using the <A
CLASS="indexterm"
NAME="ch01-idx-868888-0"
></A
><CODE
CLASS="literal"
>tr</CODE
> operator.[<A
CLASS="footnote"
HREF="#ch01-pgfId-870177"
>7</A
>] It looks a lot like a UNIX <EM
CLASS="emphasis"
>tr</EM
> command, taking a list of characters to find and a list of characters to replace them with. For our example, to put the contents of <CODE
CLASS="literal"
>$name</CODE
> in lowercase, we use:<PRE
CLASS="programlisting"
>$name =~ tr/A-Z/a-z/;</PRE
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-870177"
>[7]</A
> This doesn't work for characters with accent marks, although the <CODE
CLASS="literal"
>uc</CODE
> function would. See the <EM
CLASS="emphasis"
>perllocale </EM
>(1) manpage first distributed with the 5.004 release of Perl for details.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The slashes delimit the searched-for and replacement character lists. The dash between <CODE
CLASS="literal"
>A</CODE
> and <CODE
CLASS="literal"
>Z</CODE
> stands for all the characters in between, so we have two lists that are each 26 characters long. When the <CODE
CLASS="literal"
>tr</CODE
> operator finds a character from the string in the first list, the character is replaced with the corresponding character in the second list. So all uppercase A's become lowercase a's, and so on.[<A
CLASS="footnote"
HREF="#ch01-pgfId-870188"
>8</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-870188"
>[8]</A
> Experts will note that we could have also constructed something like   <CODE
CLASS="literal"
>s/(\S*).*/\L$1/</CODE
> to do this all in one fell swoop, but experts probably won't be reading this section.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Putting that together with everything else results in:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
%words = qw(
    fred        camel
    barney      llama
    betty       alpaca
    wilma       alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
$original_name = $name; #save for greeting
$name =~ s/\W.*//; # get rid of everything after first word
$name =~ tr/A-Z/a-z/; # lowercase everything
if ($name eq &quot;randal&quot;) { # ok to compare this way now
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $original_name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) { # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
    }
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><P
CLASS="para"
>Notice how the regular expression match for <CODE
CLASS="literal"
>Randal</CODE
> became a simple comparison again. After all, both <CODE
CLASS="literal"
>Randal</CODE
> <CODE
CLASS="literal"
>L.</CODE
> <CODE
CLASS="literal"
>Schwartz</CODE
> and <CODE
CLASS="literal"
>Randal</CODE
> become <CODE
CLASS="literal"
>randal</CODE
> after the substitution and translation. And everyone else gets a fair ride, because <CODE
CLASS="literal"
>Fred</CODE
> and <CODE
CLASS="literal"
>Fred</CODE
> <CODE
CLASS="literal"
>Flintstone</CODE
> both become <CODE
CLASS="literal"
>fred</CODE
>; <CODE
CLASS="literal"
>Barney</CODE
> <CODE
CLASS="literal"
>Rubble</CODE
> and <CODE
CLASS="literal"
>Barney,</CODE
> <CODE
CLASS="literal"
>the</CODE
> <CODE
CLASS="literal"
>little</CODE
> <CODE
CLASS="literal"
>guy</CODE
> become <CODE
CLASS="literal"
>barney</CODE
>, and so on.</P
><P
CLASS="para"
>With just a few statements, we've made the program much more user-friendly. You'll find that expressing complicated string manipulation with a few keystrokes is one of Perl's many strong points.</P
><P
CLASS="para"
>However, hacking away at the name so that we could compare it and look it up in the table destroyed the name that was entered. So, before the program hacks on the name, it saves it in <CODE
CLASS="literal"
>$original_name</CODE
>. (Like C symbols, Perl <A
CLASS="indexterm"
NAME="ch01-idx-868889-0"
></A
>variable names consist of letters, digits, and underscores and can be of nearly unlimited length.) We can then make references to <CODE
CLASS="literal"
>$original_name</CODE
> later.</P
><P
CLASS="para"
>Perl has many ways to monitor and mangle strings. You'll find out about most of them in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="Regular Expressions"
>Chapter 7, <CITE
CLASS="chapter"
>Regular Expressions</CITE
></A
>, and <A
CLASS="xref"
HREF="ch15_01.htm"
TITLE="Other Data Transformation"
>Chapter 15, <CITE
CLASS="chapter"
>Other Data Transformation</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869299"
>1.5.9 Making It a Bit More Modular</A
></H3
><P
CLASS="para"
>Now that we've added so much to the code, we have to scan through many detailed lines before we can get the overall flow of the program. What we need is to separate the high-level logic (asking for a name, looping based on entered secret words) from the details (comparing a secret word to a known good word). We might do this for clarity, or maybe because one person is writing the high-level part and another is writing (or has already written) the detailed parts.</P
><P
CLASS="para"
>Perl provides <A
CLASS="indexterm"
NAME="ch01-idx-868890-0"
></A
><EM
CLASS="emphasis"
>subroutines</EM
> that have <A
CLASS="indexterm"
NAME="ch01-idx-868891-0"
></A
><EM
CLASS="emphasis"
>parameters</EM
> and <A
CLASS="indexterm"
NAME="ch01-idx-868892-0"
></A
><EM
CLASS="emphasis"
>return values</EM
>. A subroutine is defined once in a program, and can be used repeatedly by being invoked from within any expression.</P
><P
CLASS="para"
>For our small-but-rapidly-growing program, let's create a subroutine called <CODE
CLASS="literal"
>good_word</CODE
> that takes a name and a guessed word, and returns <EM
CLASS="emphasis"
>true</EM
> if the word is correct and <EM
CLASS="emphasis"
>false</EM
> if not. The definition of such a subroutine looks like this:</P
><PRE
CLASS="programlisting"
>sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # get rid of everything after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;randal&quot;) { # should not need to guess
        return 1; # return value is true
    } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
    } else {
        return 0; # return value is false
    }
}</PRE
><P
CLASS="para"
>First, the definition of a subroutine consists of the reserved word <A
CLASS="indexterm"
NAME="ch01-idx-868894-0"
></A
><CODE
CLASS="literal"
>sub</CODE
> followed by the subroutine name followed by a <A
CLASS="indexterm"
NAME="ch01-idx-868895-0"
></A
>block of code (delimited by curly braces). This <A
CLASS="indexterm"
NAME="ch01-idx-868947-0"
></A
>definition can go anywhere in the program file, though most people put it at the end.</P
><P
CLASS="para"
>The first line within this particular definition is an assignment that copies the values of the two parameters of this subroutine into two local variables named <CODE
CLASS="literal"
>$somename</CODE
> and <CODE
CLASS="literal"
>$someguess</CODE
>. (The <CODE
CLASS="literal"
>my()</CODE
> defines the two variables as private to the enclosing block&nbsp;- in this case, the entire subroutine&nbsp;- and the parameters are initially in a special local array called <A
CLASS="indexterm"
NAME="ch01-idx-868948-0"
></A
><CODE
CLASS="literal"
>@_</CODE
>.)</P
><P
CLASS="para"
>The next two lines clean up the name, just like the previous version of the program.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>if-elsif-else</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868897-0"
></A
> statement decides whether the guessed word (<CODE
CLASS="literal"
>$someguess</CODE
>) is correct for the name (<CODE
CLASS="literal"
>$somename</CODE
>). <CODE
CLASS="literal"
>Randal</CODE
> should not make it into this subroutine, but even if it does, whatever word was guessed is OK.</P
><P
CLASS="para"
>A return statement can be used to make the subroutine immediately return to its caller with the supplied value. In the absence of an explicit return statement, the last expression evaluated in a subroutine is the return value. We'll see how the return value is used after we finish describing the subroutine definition.</P
><P
CLASS="para"
>The test for the <CODE
CLASS="literal"
>elsif</CODE
> part looks a little complicated; let's break it apart:</P
><PRE
CLASS="programlisting"
>($words{$somename} || &quot;groucho&quot;) eq $someguess</PRE
><P
CLASS="para"
>The first thing inside the parentheses is our familiar hash lookup, yielding some value from <CODE
CLASS="literal"
>%words</CODE
> based on a key of <CODE
CLASS="literal"
>$somename</CODE
>. The operator between that value and the string <CODE
CLASS="literal"
>groucho</CODE
> is the <A
CLASS="indexterm"
NAME="ch01-idx-872693-0"
></A
><CODE
CLASS="literal"
>||</CODE
> (logical-or) operator similar to that used in C and <EM
CLASS="emphasis"
>awk</EM
> and the various shells. If the lookup from the hash has a value (meaning that the key <CODE
CLASS="literal"
>$somename</CODE
> was in the hash), the value of the expression is that value. If the key could not be found, the string of <CODE
CLASS="literal"
>groucho</CODE
> is used instead. This is a very Perl-like thing to do: specify some expression, and then provide a <A
CLASS="indexterm"
NAME="ch01-idx-870214-0"
></A
>default value using <CODE
CLASS="literal"
>||</CODE
> in case the expression turns out to be false.</P
><P
CLASS="para"
>In any case, whether it's a value from the hash, or the default value <CODE
CLASS="literal"
>groucho</CODE
>, we compare it to whatever was guessed. If the comparison is true, we return 1, otherwise we return 0.</P
><P
CLASS="para"
>So, expressed as a rule, if the name is <CODE
CLASS="literal"
>randal</CODE
>, or the guess matches the lookup in <CODE
CLASS="literal"
>%words</CODE
> based on the name (with a default of <CODE
CLASS="literal"
>groucho</CODE
> if not found), then the subroutine returns 1, otherwise it returns 0.</P
><P
CLASS="para"
>Now let's integrate all this with the rest of the program:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
%words = qw(
    fred        camel
    barney      llama
    betty       alpaca
    wilma       alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^randal\b/i) { # back to the other way :-)
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}
[... insert definition of good_word() here ...]</PRE
><P
CLASS="para"
>Notice that we've gone back to the <A
CLASS="indexterm"
NAME="ch01-idx-868899-0"
></A
>regular expression to check for <CODE
CLASS="literal"
>Randal</CODE
>, because now there's no need to pull apart the first name and convert it to lowercase, as far as the main program is concerned.</P
><P
CLASS="para"
>The big difference is the <A
CLASS="indexterm"
NAME="ch01-idx-868900-0"
></A
><CODE
CLASS="literal"
>while</CODE
> loop containing the subroutine <CODE
CLASS="literal"
>good_word</CODE
>. Here, we see an invocation of the subroutine, passing it two parameters, <CODE
CLASS="literal"
>$name</CODE
> and <CODE
CLASS="literal"
>$guess</CODE
>. Within the subroutine, the value of <CODE
CLASS="literal"
>$somename</CODE
> is set from the first parameter, in this case <CODE
CLASS="literal"
>$name</CODE
>. Likewise, <CODE
CLASS="literal"
>$someguess</CODE
> is set from the second parameter, <CODE
CLASS="literal"
>$guess</CODE
>.</P
><P
CLASS="para"
>The value returned by the subroutine (either 1 or 0, recalling the definition given earlier) is logically inverted with the prefix <A
CLASS="indexterm"
NAME="ch01-idx-868949-0"
></A
><CODE
CLASS="literal"
>!</CODE
> (logical not) operator. This operator returns true if the expression following is false, and returns false if the expression following is true. The result of this negation controls the <CODE
CLASS="literal"
>while</CODE
> loop. You can read this as "while it's not a good word...". Many well-written Perl programs read very much like English, provided you take a few liberties with either Perl or English. (But you certainly won't win a Pulitzer that way.)</P
><P
CLASS="para"
>Note that the subroutine assumes that the value of the <CODE
CLASS="literal"
>%words</CODE
> hash is set by the main program. </P
><P
CLASS="para"
>Such a cavalier approach to global variables doesn't scale very well, of course. Generally speaking, variables not created with <CODE
CLASS="literal"
>my</CODE
> are global to the whole program, while those <CODE
CLASS="literal"
>my</CODE
> creates last only until the block in which they were declared exits. Don't worry: Perl does in fact support a rich variety of other kinds of variables, including those private to a file (or package), as well as variables private to a function that retain their values between invocations, which is what we could really use here. However, at this stage in your Perl education, explaining these would only complicate your life. When you're ready for it, check out what <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
> has to say about scoping, subroutines, modules, and objects, or see the online documentation in the <EM
CLASS="emphasis"
>perlsub </EM
> (1), <EM
CLASS="emphasis"
>perlmod </EM
> (1), <EM
CLASS="emphasis"
>perlobj</EM
>  (1), and <EM
CLASS="emphasis"
>perltoot</EM
>  (1) manpages.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869115"
>1.5.10 Moving the Secret Word List into a Separate File</A
></H3
><P
CLASS="para"
>Suppose we wanted to share the secret word list among three programs. If we store the word list as we have done already, we will need to change all three programs when Betty decides that her secret word should be <CODE
CLASS="literal"
>swine</CODE
> rather than <CODE
CLASS="literal"
>alpaca</CODE
>. This can get to be a hassle, especially if Betty changes her mind often.</P
><P
CLASS="para"
>So, let's put the word list into a file and then read the file to get the word list into the program. To do this, we need to create an I/O channel called a <A
CLASS="indexterm"
NAME="ch01-idx-868902-0"
></A
><EM
CLASS="emphasis"
>filehandle</EM
>. Your Perl program automatically gets three filehandles called <A
CLASS="indexterm"
NAME="ch01-idx-868903-0"
></A
><CODE
CLASS="literal"
>STDIN</CODE
>, <CODE
CLASS="literal"
>STDOUT</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868904-0"
></A
>, and <A
CLASS="indexterm"
NAME="ch01-idx-868905-0"
></A
><CODE
CLASS="literal"
>STDERR</CODE
>, corresponding to the three standard I/O channels in most programming environments. We've already been using the <CODE
CLASS="literal"
>STDIN</CODE
> handle to read data from the person running the program. Now, it's just a matter of getting another handle attached to a file of our own choice.</P
><P
CLASS="para"
>Here's a small chunk of code to do that:</P
><PRE
CLASS="programlisting"
>sub init_words {
    open (WORDSLIST, &quot;wordslist&quot;);
    while ($name = &lt;WORDSLIST&gt;) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
        $words{$name} = $word;
    }
    close (WORDSLIST);
}</PRE
><P
CLASS="para"
>We're putting it into a subroutine so that we can keep the main part of the program uncluttered. This also means that at a later time (hint: a few revisions down in this stroll), we can change where the word list is stored, or even the format of the list.</P
><P
CLASS="para"
>The arbitrarily chosen format of the word list is one item per line, with names and words, alternating. So, for our current database, we'd have something like this:</P
><PRE
CLASS="programlisting"
>fred
camel
barney
llama
betty
alpaca
wilma
alpaca</PRE
><P
CLASS="para"
>The <EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch01-idx-868906-0"
></A
><CODE
CLASS="literal"
>open </CODE
> function initializes a <A
CLASS="indexterm"
NAME="ch01-idx-868956-0"
></A
>filehandle named <CODE
CLASS="literal"
>WORDSLIST</CODE
> by associating it with a file named <CODE
CLASS="literal"
>wordslist</CODE
> in the current directory. Note that the filehandle doesn't have a funny character in front of it as the three variable types do. Also, filehandles are generally <A
CLASS="indexterm"
NAME="ch01-idx-868957-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868957-1"
></A
>uppercase&nbsp;- although they aren't required to be&nbsp;- for reasons detailed later.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>while</CODE
> loop reads lines from the <CODE
CLASS="literal"
>wordslist</CODE
> file (via the <CODE
CLASS="literal"
>WORDSLIST</CODE
> filehandle) one line at a time. Each line is stored into the <CODE
CLASS="literal"
>$name</CODE
> variable. At the <A
CLASS="indexterm"
NAME="ch01-idx-868907-0"
></A
>end of the file, the value returned by the <CODE
CLASS="literal"
>&lt;WORDSLIST&gt;</CODE
> operation is the empty string,[<A
CLASS="footnote"
HREF="#ch01-pgfId-869371"
>9</A
>] which looks false to the <CODE
CLASS="literal"
>while</CODE
> loop, and terminates it. That's how we get out at the end.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869371"
>[9]</A
> Well, technically it's <CODE
CLASS="literal"
>undef</CODE
>, but close enough for this discussion.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>If you were running with <KBD
CLASS="command"
>-w</KBD
>, you would have to check that the return value read in was actually defined. The empty string returned by the <CODE
CLASS="literal"
>&lt;WORDLIST&gt;</CODE
> operation isn't merely empty: it's <CODE
CLASS="literal"
>undef</CODE
> again. The <CODE
CLASS="literal"
>defined</CODE
> function is how you test for <CODE
CLASS="literal"
>undef</CODE
> when this matters. When reading lines from a file, you'd do the test this way:</P
><PRE
CLASS="programlisting"
> while ( defined ($name = &lt;WORDLIST&gt;) ) { </PRE
><P
CLASS="para"
>But if you were being that careful, you'd probably also have checked to make  sure that <CODE
CLASS="literal"
>open</CODE
> returned a true value. You know, that's probably not a bad idea either. The built-in <CODE
CLASS="literal"
>die</CODE
> function is frequently used to exit the program with an error message in case something goes wrong. We'll see an example of it in the next revision of the program.</P
><P
CLASS="para"
>On the other hand, the normal case is that we've read a line (including the newline) into <CODE
CLASS="literal"
>$name</CODE
>. First, off comes the newline using the <A
CLASS="indexterm"
NAME="ch01-idx-868908-0"
></A
><CODE
CLASS="literal"
>chomp</CODE
> function. Then, we have to read the next line to get the secret word, holding that in the <CODE
CLASS="literal"
>$word</CODE
> variable. It, too, gets the newline hacked off.</P
><P
CLASS="para"
>The final line of the <CODE
CLASS="literal"
>while</CODE
> loop puts <CODE
CLASS="literal"
>$word</CODE
> into <CODE
CLASS="literal"
>%words</CODE
> with a key of <CODE
CLASS="literal"
>$name</CODE
>, so that the rest of the program can access it later.</P
><P
CLASS="para"
>Once the file has been read, the filehandle can be recycled with the <A
CLASS="indexterm"
NAME="ch01-idx-868909-0"
></A
><CODE
CLASS="literal"
>close</CODE
> function. (Filehandles are automatically closed anyway when the program exits, but we're trying to be tidy. If we were really tidy, we'd even check for a true return value from <CODE
CLASS="literal"
>close</CODE
> in case the disk partition the file was on went south, its network filesystem became unreachable, or some other catastrophe occurred. Yes, these things really do happen. Murphy will always be with us.)</P
><P
CLASS="para"
>This subroutine definition can go after or before the other one. And we invoke the subroutine instead of setting <CODE
CLASS="literal"
>%words</CODE
> in the beginning of the program, so one way to wrap up all of this might look like:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
init_words();
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name =~ /^randal\b/i) { # back to the other way :-)
    print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}
## subroutines from here down
sub init_words {
    open (WORDSLIST, &quot;wordslist&quot;) || 
                              die &quot;can't open wordlist: $!&quot;;
    while ( defined ($name = &lt;WORDSLIST&gt;)) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp $word;
        $words{$name} = $word;
    }
    close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
}
sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//;         # delete everything after
                                   # first word
    $somename =~ tr/A-Z/a-z/;      # lowercase everything
    if ($somename eq &quot;randal&quot;) {   # should not need to guess
        return 1;                  # return value is true
    } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1;                  # return value is true
    } else {
        return 0;                  # return value is false
    }
}</PRE
><P
CLASS="para"
>Now it's starting to look like a full grown program. Notice the first executable line is an invocation of <CODE
CLASS="literal"
>init_words()</CODE
>. The return value is not used in a further calculation, which is good because we didn't return anything remarkable. In this case, it's guaranteed to be a true value (the value 1, in particular), because if the <CODE
CLASS="literal"
>close</CODE
> had failed, the <CODE
CLASS="literal"
>die</CODE
> would have printed a message to <CODE
CLASS="literal"
>STDERR</CODE
> and exited the program. The <CODE
CLASS="literal"
>die</CODE
> function is fully explained in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10, <CITE
CLASS="chapter"
>Filehandles and File Tests</CITE
></A
>, but because it's essential to check the return values of anything that might fail, we'll get into the habit of using it right from the start. The <CODE
CLASS="literal"
>$!</CODE
> variable (also explained in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10</A
>), contains the system error message explaining why the system call failed.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>open </CODE
> function is also used to open files for output, or open programs as files (demonstrated shortly). The full scoop on <CODE
CLASS="literal"
>open</CODE
> comes much later in this book, however, in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869405"
>1.5.11 Ensuring a Modest Amount of Security</A
></H3
><P
CLASS="para"
>"That secret word list has got to change at least once a week!" cries the Chief Director of Secret Word Lists. Well, we can't force the list to be different, but we can at least issue a warning if the secret word list has not been modified in more than a week.</P
><P
CLASS="para"
>The best place to do this is in the <CODE
CLASS="literal"
>init_words()</CODE
> subroutine; we're already looking at the file there. The Perl operator <A
CLASS="indexterm"
NAME="ch01-idx-868911-0"
></A
><CODE
CLASS="literal"
>-M</CODE
> returns the <A
CLASS="indexterm"
NAME="ch01-idx-868959-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868959-1"
></A
>age in days since a file or filehandle has last been modified, so we just need to see whether this is greater than seven for the <CODE
CLASS="literal"
>WORDSLIST</CODE
> filehandle:</P
><PRE
CLASS="programlisting"
>sub init_words {
    open (WORDSLIST, &quot;wordslist&quot;) || 
                               die &quot;can't open wordlist: $!&quot;;
    if (-M WORDSLIST &gt;= 7.0) { # comply with bureaucratic policy
        die &quot;Sorry, the wordslist is older than seven days.&quot;;
    }
    while ($name = &lt;WORDSLIST&gt;) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
        $words{$name} = $word;
    }
    close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
}</PRE
><P
CLASS="para"
>The value of <CODE
CLASS="literal"
>-M</CODE
> <CODE
CLASS="literal"
>WORDSLIST</CODE
> is compared to seven, and if greater, bingo, we've violated policy. </P
><P
CLASS="para"
>The rest of the program remains unchanged, so in the interest of saving a few trees, I won't repeat it here.</P
><P
CLASS="para"
>Besides getting the age of a file, we can also find out its owner, size, access time, and everything else that the system maintains about a file. More on that in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869118"
>1.5.12 Warning Someone When Things Go Astray</A
></H3
><P
CLASS="para"
>Let's see how much we can bog down the system by sending a piece of email each time someone guesses their secret word incorrectly. We need to modify only the <CODE
CLASS="literal"
>good_word()</CODE
> subroutine (thanks to modularity) because we have all the information right there.</P
><P
CLASS="para"
>The mail will be sent to you if you type your own mail address where the code says "YOUR_ADDRESS_HERE." Here's what we have to do: just before we return 0 from the subroutine, we create a filehandle that is actually a process (<EM
CLASS="emphasis"
>mail</EM
><A
CLASS="indexterm"
NAME="ch01-idx-868963-0"
></A
> ), like so:</P
><PRE
CLASS="programlisting"
>sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//;         # get rid of stuff after
                                   # first word
    $somename =~ tr/A-Z/a-z/;      # lowercase everything
    if ($somename eq &quot;randal&quot;) {   # should not need to guess
        return 1;                  # return value is true
    } elsif (($words{$somename}||&quot;groucho&quot;) eq $someguess) {
        return 1;                  # return value is true
    } else {
        open MAIL,&quot;|mail YOUR_ADDRESS_HERE&quot;;
        print MAIL &quot;bad news: $somename guessed $someguess\n&quot;;
        close MAIL;
        return 0;                  # return value is false
    }
}</PRE
><P
CLASS="para"
>The first new statement here is <EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch01-idx-868914-0"
></A
><CODE
CLASS="literal"
>open</CODE
>, which has a <A
CLASS="indexterm"
NAME="ch01-idx-868961-0"
></A
>pipe symbol (<CODE
CLASS="literal"
>|</CODE
>) at the beginning of its second argument. This is a special indication that we are opening a command rather than a file. Because the pipe is at the beginning of the command, we are opening a command so that we can write to it. (If you put the pipe at the end rather than the beginning, you can read the output of a command instead.)</P
><P
CLASS="para"
>The next statement, a <CODE
CLASS="literal"
>print</CODE
>, shows that a <A
CLASS="indexterm"
NAME="ch01-idx-868962-0"
></A
>filehandle between the <A
CLASS="indexterm"
NAME="ch01-idx-868915-0"
></A
><CODE
CLASS="literal"
>print</CODE
> keyword and the values to be printed selects that filehandle for output, rather than <CODE
CLASS="literal"
>STDOUT</CODE
>.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869470"
>10</A
>] This means that the message will end up as the input to the <EM
CLASS="emphasis"
>mail</EM
> command.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869470"
>[10]</A
> Well, technically, the currently selected filehandle. That's covered much later, though.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Finally, we close the filehandle, which starts <EM
CLASS="emphasis"
>mail</EM
> sending its data merrily on its way.</P
><P
CLASS="para"
>To be proper, we could have sent the correct response as well as the error response, but then someone reading over my shoulder (or lurking in the mail system) while I'm reading my mail might get too much useful information.</P
><P
CLASS="para"
>Perl can also open filehandles, invoke commands with precise control over argument lists, or even fork off a copy of the current program, and execute two (or more) copies in parallel. <A
CLASS="indexterm"
NAME="ch01-idx-868964-0"
></A
>Backquotes (like the shell's backquotes) give an easy way to grab the output of a command as data. All of this gets described in <A
CLASS="xref"
HREF="ch14_01.htm"
TITLE="Process Management"
>Chapter 14, <CITE
CLASS="chapter"
>Process Management</CITE
></A
>, so keep reading.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869121"
>1.5.13 Many Secret Word Files in the Current Directory</A
></H3
><P
CLASS="para"
>Let's change the definition of the secret word filename slightly. Instead of just the file named <CODE
CLASS="literal"
>wordslist</CODE
>, let's look for anything in the current directory that ends in <CODE
CLASS="literal"
>.secret</CODE
>. To the shell, we say</P
><PRE
CLASS="programlisting"
>echo *.secret</PRE
><P
CLASS="para"
>to get a brief listing of all of these names. As you'll see in a moment, Perl uses a similar wildcard-name syntax.</P
><P
CLASS="para"
>Pulling out the <CODE
CLASS="literal"
>init_words()</CODE
> definition again:</P
><PRE
CLASS="programlisting"
>sub init_words {
    while ( defined($filename = glob(&quot;*.secret&quot;)) ) {
    open (WORDSLIST, $filename) || 
                              die &quot;can't open wordlist: $!&quot;;
        if (-M WORDSLIST &lt; 7.0) {
            while ($name = &lt;WORDSLIST&gt;) {
                chomp $name;
                $word = &lt;WORDSLIST&gt;;
                chomp $word;
                $words{$name} = $word;
             }
         }
         close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
     }
}</PRE
><P
CLASS="para"
>First, we've wrapped a new <A
CLASS="indexterm"
NAME="ch01-idx-868919-0"
></A
><CODE
CLASS="literal"
>while</CODE
> loop around the bulk of the routine from the previous version. The new thing here is the <CODE
CLASS="literal"
>glob</CODE
> function. This is called a <A
CLASS="indexterm"
NAME="ch01-idx-868916-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868916-1"
></A
><EM
CLASS="emphasis"
>filename glob</EM
>, for historical reasons. It works much like <CODE
CLASS="literal"
>&lt;STDIN&gt;</CODE
>, in that each time it is accessed, it returns the next value: successive filenames that match the shell pattern, in this case <CODE
CLASS="literal"
>*.secret</CODE
>. When there are no additional filenames to be returned, the filename glob returns an empty string.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869495"
>11</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869495"
>[11]</A
> Yeah, yeah, <CODE
CLASS="literal"
>undef</CODE
> again.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>So if the current directory contains <CODE
CLASS="literal"
>fred.secret</CODE
> and <CODE
CLASS="literal"
>barney.secret</CODE
>, then <CODE
CLASS="literal"
>$filename</CODE
> is <CODE
CLASS="literal"
>barney.secret</CODE
> on the first pass through the <CODE
CLASS="literal"
>while</CODE
> loop (the names come out in alphabetically sorted order). On the second pass, <CODE
CLASS="literal"
>$filename</CODE
> is <CODE
CLASS="literal"
>fred.secret</CODE
>. And there is no third pass because the glob returns an empty string the third time it is called, perceived by the <CODE
CLASS="literal"
>while</CODE
> loop to be false, causing an exit from the subroutine.</P
><P
CLASS="para"
>Within the <CODE
CLASS="literal"
>while</CODE
> loop, we open the file and verify that it is recent enough (less than seven days since the last modification). For the recent-enough files, we scan through as before.</P
><P
CLASS="para"
>Note that if there are no files that match <CODE
CLASS="literal"
>*.secret</CODE
> and are less than seven days old, the subroutine will exit without having set any secret words into the <CODE
CLASS="literal"
>%words</CODE
> array. That means that everyone will have to use the word <CODE
CLASS="literal"
>groucho</CODE
>. Oh well. (For <EM
CLASS="emphasis"
>real</EM
> code, I would have added some check on the number of entries in <CODE
CLASS="literal"
>%words</CODE
> before returning, and <A
CLASS="indexterm"
NAME="ch01-idx-868966-0"
></A
><CODE
CLASS="literal"
>die</CODE
>'d if it weren't good. See the <CODE
CLASS="literal"
>keys</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868965-0"
></A
> function when we get to hashes in <A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Hashes"
>Chapter 5, <CITE
CLASS="chapter"
>Hashes</CITE
></A
>.)</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-870411"
>1.5.14 Listing the Secret Words</A
></H3
><P
CLASS="para"
>Well, the Chief Director of Secret Word Lists wants a <A
CLASS="indexterm"
NAME="ch01-idx-868923-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868923-1"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868923-2"
></A
>report of all the secret words currently in use and how old they are. If we set aside the secret word program for a moment, we'll have time to write a reporting program for the Director.</P
><P
CLASS="para"
>First, let's get all of the secret words, by stealing some code from the <CODE
CLASS="literal"
>init_words()</CODE
> subroutine:</P
><PRE
CLASS="programlisting"
>while ( defined($filename = glob(&quot;*.secret&quot;)) ) {
open (WORDSLIST, $filename) || die &quot;can't open wordlist: $!&quot;;
if (-M WORDSLIST &lt; 7.0) {
    while ($name = &lt;WORDSLIST&gt;) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
 ### new stuff will go here
        }
    }
    close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
}</PRE
><P
CLASS="para"
>At the point marked "new stuff will go here," we know three things: the name of the file (in <CODE
CLASS="literal"
>$filename</CODE
>), someone's name (in <CODE
CLASS="literal"
>$name</CODE
>), and that person's secret word (in <CODE
CLASS="literal"
>$word</CODE
>). Here's a place to use Perl's report generating tools. We define a <A
CLASS="indexterm"
NAME="ch01-idx-868924-0"
></A
>format somewhere in the program (usually near the end, like a subroutine):</P
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch01-idx-868968-0"
></A
>format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.</PRE
><P
CLASS="para"
>The format definition begins with <CODE
CLASS="literal"
>format</CODE
> <CODE
CLASS="literal"
>STDOUT</CODE
> <CODE
CLASS="literal"
>=</CODE
>, and ends with a single period. The two lines between are the format itself. The first line of this format is a <A
CLASS="indexterm"
NAME="ch01-idx-868925-0"
></A
><EM
CLASS="emphasis"
>field definition line</EM
> that specifies the number, length, and type of the fields. For this format, we have three fields. The line following a field definition line is always a <A
CLASS="indexterm"
NAME="ch01-idx-868926-0"
></A
><EM
CLASS="emphasis"
>field value line</EM
>. The value line gives a list of expressions that will be evaluated when this format is used, and the results of those expressions will be plugged into the fields defined in the previous line.</P
><P
CLASS="para"
>We invoke this format with the <A
CLASS="indexterm"
NAME="ch01-idx-868927-0"
></A
><CODE
CLASS="literal"
>write</CODE
> function, like so:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
while ( defined($filename = glob(&quot;*.secret&quot;)) ) {
    open (WORDSLIST, $filename) || die &quot;can't open wordlist: $!&quot;;
    if (-M WORDSLIST &lt; 7.0) {
        while ($name = &lt;WORDSLIST&gt;) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
            chomp ($word);
            write; # invoke format STDOUT to STDOUT
        }
    }
    close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
}
format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.</PRE
><P
CLASS="para"
>When the format is invoked, Perl evaluates the field expressions and generates a line that it sends to the <CODE
CLASS="literal"
>STDOUT</CODE
> filehandle. Because <CODE
CLASS="literal"
>write</CODE
> is invoked once each time through the loop, we'll get a series of lines with text in columns, one line for each secret word entry.</P
><P
CLASS="para"
>Hmm. We haven't labeled the <A
CLASS="indexterm"
NAME="ch01-idx-868969-0"
></A
>columns. That's easy enough. We just need to add a <A
CLASS="indexterm"
NAME="ch01-idx-868928-0"
></A
>top-of-page format, like so:</P
><PRE
CLASS="programlisting"
>format STDOUT_TOP =
Page @&lt;&lt;
$%

Filename         Name       Word
================ ========== ============
.</PRE
><P
CLASS="para"
>This format is named <CODE
CLASS="literal"
>STDOUT_TOP</CODE
>, and will be used initially at the first invocation of the <CODE
CLASS="literal"
>STDOUT</CODE
> format, and again every time 60 lines of output to <CODE
CLASS="literal"
>STDOUT</CODE
> have been generated. The column headings here line up with the columns from the <CODE
CLASS="literal"
>STDOUT</CODE
> format, so everything comes out tidy.</P
><P
CLASS="para"
>The first line of this format shows some constant text (<CODE
CLASS="literal"
>Page</CODE
>) along with a three-character field definition. The following line is a field value line, here with one expression. This expression is the <A
CLASS="indexterm"
NAME="ch01-idx-868929-0"
></A
><CODE
CLASS="literal"
>$%</CODE
> variable,[<A
CLASS="footnote"
HREF="#ch01-pgfId-870450"
>12</A
>] which holds the number of pages printed&nbsp;- a very useful value in top-of-page formats.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-870450"
>[12]</A
> More mnemonic aliases for these predefined scalar variables are available via the English module.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The third line of the format is blank. Because this line does not contain any fields, the line following it is not a field value line. This blank line is copied directly to the output, creating a blank line between the page number and the column headers below.</P
><P
CLASS="para"
>The last two lines of the format also contain no fields, so they are copied as is directly to the output. So this format generates four lines, one of which has a part that changes from page to page.</P
><P
CLASS="para"
>Just tack this definition onto the previous program to get it to work. Perl notices the top-of-page format automatically.</P
><P
CLASS="para"
>Perl also has fields that are centered or right-justified, and supports a <EM
CLASS="emphasis"
>filled paragraph area</EM
> as well. More on this when we get to formats in <A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="Formats"
>Chapter 11, <CITE
CLASS="chapter"
>Formats</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869613"
>1.5.15 Making Those Old Word Lists More Noticeable</A
></H3
><P
CLASS="para"
>As we are scanning through the <CODE
CLASS="literal"
>*.secret</CODE
> files in the current directory, we may find files that are too old. So far, we are simply skipping over those files. Let's go one step more: we'll <A
CLASS="indexterm"
NAME="ch01-idx-868930-0"
></A
>rename them to <CODE
CLASS="literal"
>*.secret.old</CODE
> so that a directory listing will quickly show us which files are too old, simply by name.</P
><P
CLASS="para"
>Here's how the <CODE
CLASS="literal"
>init_words()</CODE
> subroutine looks with this modification:</P
><PRE
CLASS="programlisting"
>sub init_words {
    while ( defined($filename = glob(&quot;*.secret&quot;)) ) {
        open (WORDSLIST, $filename) || 
                              die &quot;can't open wordlist: $!&quot;;
        if (-M WORDSLIST &lt; 7.0) {
            while ($name = &lt;WORDSLIST&gt;) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
            }
        } else { # rename the file so it gets noticed
            rename ($filename,&quot;$filename.old&quot;) || 
                die &quot;can't rename $filename to $filename.old: $!&quot;;
        }
        close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
    }
}</PRE
><P
CLASS="para"
>Notice the new <CODE
CLASS="literal"
>else</CODE
> part of the file age check. If the file is older than seven days, it gets renamed with the <A
CLASS="indexterm"
NAME="ch01-idx-868931-0"
></A
><CODE
CLASS="literal"
>rename</CODE
> function. This function takes two parameters, renaming the file named by the first parameter to the name given in the second parameter.</P
><P
CLASS="para"
>Perl has a complete range of file manipulation operators; anything you can do to a file from a C program, you can also do from Perl.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869617"
>1.5.16 Maintaining a Last-Good-Guess Database</A
></H3
><P
CLASS="para"
>Let's keep track of when the most recent correct guess has been made for each user. One data structure that might seem to work at first glance is a hash. For example, the statement</P
><PRE
CLASS="programlisting"
>$last_good{$name} = <A
CLASS="indexterm"
NAME="ch01-idx-868932-0"
></A
>time;</PRE
><P
CLASS="para"
>assigns the current time in internal format (some large integer above 800 million, incrementing one number per second) to an element of <CODE
CLASS="literal"
>%last_good</CODE
> that has the name for a key. Over time, this would seem to give us a database indicating the most recent time the secret word was guessed properly for each of the users who had invoked the program.</P
><P
CLASS="para"
>But, the hash doesn't have an existence between invocations of the program. Each time the program is invoked, a new hash is formed. So at most, we create a one-element hash and then immediately forget it when the program exits.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch01-idx-868933-0"
></A
><CODE
CLASS="literal"
>dbmopen</CODE
> function[<A
CLASS="footnote"
HREF="#ch01-pgfId-870471"
>13</A
>] maps a hash out into a disk file (actually a pair of disk files) known as a <A
CLASS="indexterm"
NAME="ch01-idx-868934-0"
></A
><EM
CLASS="emphasis"
>DBM</EM
>. It's used like this:<PRE
CLASS="programlisting"
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                             die &quot;can't dbmopen lastdb: $!&quot;;
$last_good{$name} = time;
dbmclose (%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;</PRE
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-870471"
>[13]</A
> Or using the more low-level <CODE
CLASS="literal"
>tie</CODE
> function on a specific database, as detailed in Chapters 5 and 7 of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>, or in the <EM
CLASS="emphasis"
>perltie </EM
> (1) and <EM
CLASS="emphasis"
>AnyDBM_File</EM
>  (3) manpages.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The first statement performs the mapping, using the disk filenames of <CODE
CLASS="literal"
>lastdb.dir</CODE
> and <CODE
CLASS="literal"
>lastdb.pag</CODE
> (these names are the normal names for a DBM called <CODE
CLASS="literal"
>lastdb</CODE
>). The file permissions used for these two files if the files must be created (as they will the first time through) is <CODE
CLASS="literal"
>0666</CODE
>.[<A
CLASS="footnote"
HREF="#ch01-pgfId-871066"
>14</A
>] This mode means that anyone can read or write the files. If you're on a UNIX system, file permission bits are described in the <EM
CLASS="emphasis"
>chmod  </EM
>(2) manpage. On non-UNIX systems, <EM
CLASS="emphasis"
>chmod  </EM
>( ) may or may not work the same way. For example, under MS-DOS, files have no permissions, whereas under WindowsNT, they do. See your port's release notes about this if you're unsure.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-871066"
>[14]</A
> The actual permissions of the files will be the logical AND of 0666 and your process's current umask.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The second statement shows that we use this mapped hash just like a normal hash. However, creating or updating an element of the hash automatically updates the disk files that form the DBM. And, when the hash is later accessed, the values within the hash come directly from the disk image. This gives the hash a life beyond the current invocation of the program&nbsp;- a persistence of its own.</P
><P
CLASS="para"
>The third statement disconnects the hash from the DBM, much like a file <CODE
CLASS="literal"
>close</CODE
> operation.</P
><P
CLASS="para"
>Although the inserted statements maintain the database just fine (and even create it the first time), we don't have any way of examining the information yet. To do that, we can create a separate little program that looks something like this:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl -w
dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                                die &quot;can't dbmopen lastdb: $!&quot;;
foreach $name (sort keys (%last_good)) {
    $when = $last_good{$name};
    $hours = (time() - $when) / 3600; # compute hours ago
    write;
}

format STDOUT =
User @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: last correct guess was @&lt;&lt;&lt; hours ago.
$name, $hours
.</PRE
><P
CLASS="para"
>We've got a few new operations here: a <CODE
CLASS="literal"
>foreach</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868935-0"
></A
> loop, sorting a list, and getting the keys of an array.</P
><P
CLASS="para"
>First, the <A
CLASS="indexterm"
NAME="ch01-idx-868936-0"
></A
><CODE
CLASS="literal"
>keys</CODE
> function takes a hash name as an argument and returns a list of all the keys of that hash in some unspecified order. For the <CODE
CLASS="literal"
>%words</CODE
> hash defined earlier, the result is something like <CODE
CLASS="literal"
>fred</CODE
>, <CODE
CLASS="literal"
>barney</CODE
>, <CODE
CLASS="literal"
>betty</CODE
>, <CODE
CLASS="literal"
>wilma</CODE
>, in some unspecified order. For the <CODE
CLASS="literal"
>%last_good</CODE
> hash, the result will be a list of all users who have guessed their own secret word successfully.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch01-idx-868937-0"
></A
><CODE
CLASS="literal"
>sort</CODE
> function sorts the list alphabetically (just as if you passed a text file through the <EM
CLASS="emphasis"
>sort</EM
> command). This makes sure that the list processed by the <CODE
CLASS="literal"
>foreach</CODE
> statement is always in alphabetical order.</P
><P
CLASS="para"
>Finally, the Perl <A
CLASS="indexterm"
NAME="ch01-idx-868938-0"
></A
><CODE
CLASS="literal"
>foreach</CODE
> statement is a lot like the C-shell <CODE
CLASS="literal"
>foreach</CODE
> statement. It takes a list of values and assigns each one in turn to a scalar variable (here, <CODE
CLASS="literal"
>$name</CODE
>) executing the body of the loop (a block) once for each value. So, for five names in the <CODE
CLASS="literal"
>%last_good</CODE
> list, we get five passes through the loop, with <CODE
CLASS="literal"
>$name</CODE
> being a different value each time.</P
><P
CLASS="para"
>The body of the <CODE
CLASS="literal"
>foreach</CODE
> loop loads up a couple of variables used within the <CODE
CLASS="literal"
>STDOUT</CODE
> format and invokes the format. Note that we figure out the age of the entry by subtracting the stored system <A
CLASS="indexterm"
NAME="ch01-idx-868939-0"
></A
>time (in the array) from the current time (as returned by <CODE
CLASS="literal"
>time</CODE
>) and then divide that by 3600 (to convert seconds to hours).</P
><P
CLASS="para"
>Perl also provides easy ways to create and maintain text-oriented databases (like the Password file) and fixed-length-record databases (like the "last login" database maintained by the <EM
CLASS="emphasis"
>login</EM
> program). These are described in <A
CLASS="xref"
HREF="ch17_01.htm"
TITLE="User Database Manipulation"
>Chapter 17, <CITE
CLASS="chapter"
>User Database Manipulation</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-871077"
>1.5.17 The Final Programs</A
></H3
><P
CLASS="para"
>Here are the programs from this stroll in their final form so you can play with them.</P
><P
CLASS="para"
>First, the "say hello" program:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
init_words();
print &quot;what is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp($name);
<A
CLASS="indexterm"
NAME="ch01-idx-868979-0"
></A
>if ($name =~ /^randal\b/i) { # back to the other way :-)
  <A
CLASS="indexterm"
NAME="ch01-idx-868972-0"
></A
>  print &quot;Hello, Randal! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = <A
CLASS="indexterm"
NAME="ch01-idx-868973-0"
></A
>&lt;STDIN&gt;;
  <A
CLASS="indexterm"
NAME="ch01-idx-868974-0"
></A
>  chomp $guess;
    while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp $guess;
    }
}
<A
CLASS="indexterm"
NAME="ch01-idx-868975-0"
></A
>dbmopen (%last_good,&quot;lastdb&quot;,0666);
$last_good{$name} = time;
<A
CLASS="indexterm"
NAME="ch01-idx-868976-0"
></A
>dbmclose (%last_good);
<A
CLASS="indexterm"
NAME="ch01-idx-868977-0"
></A
>sub init_words {
  <A
CLASS="indexterm"
NAME="ch01-idx-868978-0"
></A
>  while ($filename = &lt;*.secret&gt;) {
        <A
CLASS="indexterm"
NAME="ch01-idx-868980-0"
></A
>open (WORDSLIST, $filename)|| 
                              die &quot;can't open $filename: $!&quot;;
        if (-M WORDSLIST &lt; 7.0) {
            while ($name = &lt;WORDSLIST&gt;) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
            }
        } else { # rename the file so it gets noticed
      <A
CLASS="indexterm"
NAME="ch01-idx-868981-0"
></A
>      rename ($filename,&quot;$filename.old&quot;) || 
                          die &quot;can't rename $filename: $!&quot;;
        }
    <A
CLASS="indexterm"
NAME="ch01-idx-868982-0"
></A
>    close WORDSLIST;
    }
}
sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ <A
CLASS="indexterm"
NAME="ch01-idx-868983-0"
></A
>s/\W.*//; # delete everything after first word
    $somename =~ <A
CLASS="indexterm"
NAME="ch01-idx-868984-0"
></A
>tr/A-Z/a-z/; # lowercase everything
    if ($somename <A
CLASS="indexterm"
NAME="ch01-idx-868985-0"
></A
>eq &quot;randal&quot;) { # should not need to guess
        return 1; # <A
CLASS="indexterm"
NAME="ch01-idx-868986-0"
></A
>return value is true
    } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
    } else {
    <A
CLASS="indexterm"
NAME="ch01-idx-868987-0"
></A
>    open (MAIL, &quot;|mail YOUR_ADDRESS_HERE&quot;);
        print MAIL &quot;bad news: $somename guessed $someguess\n&quot;;
        close MAIL;
        return 0; # return value is false
    }
}</PRE
><P
CLASS="para"
>Next, we have the secret word lister:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
while ($filename = &lt;*.secret&gt;) {
    open (WORDSLIST, $filename) || 
                             die &quot;can't open $filename: $!&quot;;

    if (-M WORDSLIST &lt; 7.0) {
        while ($name = &lt;WORDSLIST&gt;) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
            chomp ($word);
      <A
CLASS="indexterm"
NAME="ch01-idx-868988-0"
></A
>      write; # invoke format STDOUT to STDOUT
         }
    }
    close (WORDSLIST);
}
<A
CLASS="indexterm"
NAME="ch01-idx-868989-0"
></A
>format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.
format STDOUT_TOP =
Page @&lt;&lt;
$%

Filename         Name       Word
================ ========== ============
.</PRE
><P
CLASS="para"
>And finally, the last-time-a-word-was-used display program:</P
><PRE
CLASS="programlisting"
>#!/usr/bin/perl
<A
CLASS="indexterm"
NAME="ch01-idx-868990-0"
></A
>dbmopen (%last_good,&quot;lastdb&quot;,0666);
<A
CLASS="indexterm"
NAME="ch01-idx-868991-0"
></A
>foreach $name (sort keys %last_good) {
    $when = $last_good{$name};
    $hours = (<A
CLASS="indexterm"
NAME="ch01-idx-868992-0"
></A
>time - $when) / 3600; # compute hours ago
    write;
}

format STDOUT =
User @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: last correct guess was @&lt;&lt;&lt; hours ago.
$name, $hours
.</PRE
><P
CLASS="para"
>Together with the secret word lists (files named <CODE
CLASS="replaceable"
><I
>something</I
></CODE
><KBD
CLASS="command"
>.secret</KBD
> in the current directory) and the database <CODE
CLASS="literal"
>lastdb.dir</CODE
> and <CODE
CLASS="literal"
>lastdb.pag</CODE
>, you'll have all you need.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_04.htm"
TITLE="1.4 Basic Concepts"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.4 Basic Concepts"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Learning Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Learning Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_06.htm"
TITLE="1.6 Exercise"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.6 Exercise"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.4 Basic Concepts</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.6 Exercise</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="../prog/index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
