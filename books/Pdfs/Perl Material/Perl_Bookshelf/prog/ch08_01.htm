<HTML
><HEAD
>
<TITLE>[Chapter 8] Other Oddments</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T02:06:38Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Programming Perl"><LINK
REL="prev"
HREF="ch07_02.htm"
TITLE="7.2 Library Modules"><LINK
REL="next"
HREF="ch08_02.htm"
TITLE="8.2 Common Goofs for Novices"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch07_02.htm"
TITLE="7.2 Library Modules"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.2 Library Modules"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 8</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_02.htm"
TITLE="8.2 Common Goofs for Novices"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.2 Common Goofs for Novices"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="CHAPTER"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PERL2-CH-8"
>8. Other Oddments</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="SECT1"
HREF="#PERL2-CH-8-SECT-1"
TITLE="8.1 The Perl Debugger"
>The Perl Debugger</A
><BR><A
CLASS="SECT1"
HREF="ch08_02.htm"
TITLE="8.2 Common Goofs for Novices"
>Common Goofs for Novices</A
><BR><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"
>Efficiency</A
><BR><A
CLASS="SECT1"
HREF="ch08_04.htm"
TITLE="8.4 Programming with Style"
>Programming with Style</A
><BR><A
CLASS="SECT1"
HREF="ch08_05.htm"
TITLE="8.5 Distribution and Installation"
>Distribution and Installation</A
><BR><A
CLASS="SECT1"
HREF="ch08_06.htm"
TITLE="8.6 Perl Poetry"
>Perl Poetry</A
><BR><A
CLASS="SECT1"
HREF="ch08_07.htm"
TITLE="8.7 History Made Practical"
>History Made Practical</A
></P
><P
></P
></DIV
><P
CLASS="para"
>Did you ever have a junk drawer?  You know, one of those drawers
where you put everything important enough to keep (like the spare key
to the back door), but not important enough to have a place of its own
(like the back door itself).</P
><P
CLASS="para"
>Well, this chapter is the junk drawer of the book.  We stuffed many
important (and a few not-so-important) things in this chapter.  Read on.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1"
>8.1 The Perl Debugger</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.DEBUG1"
></A
><A
CLASS="indexterm"
NAME="CH08.DEBUG2"
></A
><A
CLASS="indexterm"
NAME="CH08.DEBUG3"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27790"
></A
>First of all, have you tried using the <B
CLASS="emphasis.bold"
>-w</B
> switch?</P
><P
CLASS="para"
>If you invoke Perl with the <B
CLASS="emphasis.bold"
>-d</B
> switch,
your script runs under the Perl debugger.  This works like an
interactive Perl environment, prompting for debugger commands that let
you examine source code, set breakpoints, dump out your function-call
stack, change the values of variables, and so on.  Any command not
recognized by the debugger[<A
CLASS="footnote"
HREF="#AUTOID-27796"
>1</A
>] is directly executed
(<A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>'d) as Perl code in the current
package.[<A
CLASS="footnote"
HREF="#AUTOID-27800"
>2</A
>] This is so wonderfully
convenient that you often fire up the debugger all by itself just to
test out Perl constructs interactively to see what they do.  Here's a
common way to get that:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-27796"
>[1]</A
>  Leading whitespace before
a command would cause the debugger to think it's
<EM
CLASS="emphasis"
>not</EM
> a command for it, but rather for Perl, so be
careful not to do that.  </P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-27800"
>[2]</A
>  The debugger uses the DB package for its
own state information.  </P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>perl -d -e 42</PRE
><P
CLASS="para"
>In Perl, the debugger is not a separate program as it usually is in a
typical programming environment.  Instead, the <B
CLASS="emphasis.bold"
>-d</B
> flag tells the compiler to insert source
information into the parse trees it's about to hand off to the
interpreter.  That means your 
code must first compile correctly for
the debugger to work on it.  Then when the interpreter starts up, it
pre-loads a Perl library file containing the debugger itself.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.1"
>8.1.1 Debugger Commands</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27808"
></A
>The debugger understands the following commands:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>h</CODE
> [<CODE
CLASS="replaceable"
><I
>command</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Prints out a help message.  </P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27819"
></A
>If you supply another debugger command as an argument to the <CODE
CLASS="literal"
>h</CODE
>
command, it prints out the description for just that command.  The command &quot;<CODE
CLASS="literal"
>h h</CODE
>&quot; produces a more compact help listing designed to
fit on one screen.  If the output of the <CODE
CLASS="literal"
>h</CODE
> command (or any command,
for that matter) scrolls past your screen, just precede the command with a
leading pipe symbol so it's run through your pager:</P
><PRE
CLASS="programlisting"
>DB&lt;1&gt; |h</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>p</CODE
> <CODE
CLASS="replaceable"
><I
>expr</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27831"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27833"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27836"
></A
>Same as &quot;<CODE
CLASS="literal"
>print DB::OUT</CODE
> <CODE
CLASS="replaceable"
><I
>expr</I
></CODE
>&quot; in the current package.  In particular,
since this is just Perl's own <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> function, this means that nested
data structures and objects are not dumped, unlike with the <CODE
CLASS="literal"
>x</CODE
> command.
The <CODE
CLASS="literal"
>DB::OUT</CODE
> handle is opened to <EM
CLASS="emphasis"
>/dev/tty</EM
> (or perhaps an editor
window) no matter where standard output may have been redirected to.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>x</CODE
> <CODE
CLASS="replaceable"
><I
>expr</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27851"
></A
>Evals its expression in a list context and dumps out the result 
in a pretty-printed fashion.  Nested data structures are printed out
recursively, unlike with the print command above.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>V</CODE
> [<CODE
CLASS="replaceable"
><I
>pkg</I
></CODE
> [<CODE
CLASS="replaceable"
><I
>vars</I
></CODE
>]]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27860"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27862"
></A
>Display all (or some) variables in package (defaulting to the main
package) using a data pretty-printer.  (Hashes show their keys and values so
you see what's what, control characters are made printable, nested data
structures print out in a legible fashion, and so on.)  Make sure you type
the identifiers without a type specifier such as <CODE
CLASS="literal"
>$</CODE
> or
<CODE
CLASS="literal"
>@</CODE
>, like this:</P
><PRE
CLASS="programlisting"
>V DB filename line</PRE
><P
CLASS="para"
>In place of a variable name, you can use
<CODE
CLASS="literal"
>~</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
> or
<CODE
CLASS="literal"
>!</CODE
><CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
> to print existing variables
whose names either match or don't match the specified regular
expression.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>X</CODE
> [<CODE
CLASS="replaceable"
><I
>vars</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27879"
></A
>Same as <CODE
CLASS="literal"
>V</CODE
> <CODE
CLASS="replaceable"
><I
>currentpackage</I
></CODE
>
[<CODE
CLASS="replaceable"
><I
>vars</I
></CODE
>].  </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>T</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27889"
></A
>Produce a stack backtrace.  See below for details on its output.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>s</CODE
> [<CODE
CLASS="replaceable"
><I
>expr</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27897"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27899"
></A
>Single step.  Executes until it reaches the beginning of another
statement, descending into subroutine calls.  If an expression is
supplied that includes function calls, it, too, will be single-stepped.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>n</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27906"
></A
>Next.  Executes over subroutine calls, until it reaches the beginning
of the next statement at this same level.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>&lt;CR&gt;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Repeat last <CODE
CLASS="literal"
>n</CODE
> or <CODE
CLASS="literal"
>s</CODE
> command.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>c</CODE
> [<CODE
CLASS="replaceable"
><I
>line</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27921"
></A
>Continue, optionally inserting a one-time-only breakpoint
at the specified line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>l</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27928"
></A
>List next few lines.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>l</CODE
> <CODE
CLASS="replaceable"
><I
>min+incr</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27936"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27938"
></A
><A
CLASS="indexterm"
NAME="AUTOID-27941"
></A
>List <CODE
CLASS="replaceable"
><I
>incr</I
></CODE
><CODE
CLASS="literal"
>+1</CODE
> lines starting at
<CODE
CLASS="replaceable"
><I
>min</I
></CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>l</CODE
> <CODE
CLASS="replaceable"
><I
>min-max</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>List lines <CODE
CLASS="replaceable"
><I
>min</I
></CODE
> through <CODE
CLASS="replaceable"
><I
>max</I
></CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>l</CODE
> <CODE
CLASS="replaceable"
><I
>line</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>List a single line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>l</CODE
> <CODE
CLASS="replaceable"
><I
>subname</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>List first few lines from subroutine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>-</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27971"
></A
>List previous few lines.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>w</CODE
> [<CODE
CLASS="replaceable"
><I
>line</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27980"
></A
>List window (a few lines) around the given <CODE
CLASS="replaceable"
><I
>line</I
></CODE
>, or
the current one if no <CODE
CLASS="replaceable"
><I
>line</I
></CODE
> is supplied.</P
></DD
><DT
CLASS="term"
>.   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-27988"
></A
>Return debugger pointer to the last-executed line and
print it out.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>f</CODE
> <CODE
CLASS="replaceable"
><I
>filename</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Switch to viewing a different file.<A
CLASS="indexterm"
NAME="AUTOID-27997"
></A
></P
></DD
><DT
CLASS="term"
>/<CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>/</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Search forward for <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>; final / is optional.<A
CLASS="indexterm"
NAME="AUTOID-28005"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28007"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28009"
></A
></P
></DD
><DT
CLASS="term"
>?<CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>?</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28017"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28019"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28021"
></A
>Search backward for <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>; final ? is optional.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>L</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>List all breakpoints and actions for the current file.<A
CLASS="indexterm"
NAME="AUTOID-28030"
></A
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>S</CODE
> [[!]<CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28038"
></A
>List subroutine names matching (or not matching with &quot;!&quot;) <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>.
If no <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
> is given, all subroutines are listed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>t</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28047"
></A
>Toggle trace mode.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>t</CODE
> <CODE
CLASS="replaceable"
><I
>expr</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Trace through execution of <CODE
CLASS="replaceable"
><I
>expr</I
></CODE
>.  </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>b</CODE
> [<CODE
CLASS="replaceable"
><I
>line</I
></CODE
>] [<CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28063"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28065"
></A
>Set a breakpoint at <CODE
CLASS="replaceable"
><I
>line</I
></CODE
>.  If <CODE
CLASS="replaceable"
><I
>line</I
></CODE
> is omitted, set a
breakpoint on the line that is about to be executed.  <CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>,
if given, is evaluated each time the statement is reached, and a
breakpoint is taken only if <CODE
CLASS="replaceable"
><I
>condition</I
></CODE
> is true.  Breakpoints
may only be set on lines
that begin an executable statement.  Conditions don't use <B
CLASS="emphasis.bold"
>if</B
>:</P
><PRE
CLASS="programlisting"
>b 237 $x &gt; 30
b 33 /pattern/i</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>b</CODE
> <CODE
CLASS="replaceable"
><I
>subname</I
></CODE
> [<CODE
CLASS="replaceable"
><I
>condition</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Set a (possibly conditional) breakpoint at the first line of the named
subroutine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>d</CODE
> [<CODE
CLASS="replaceable"
><I
>line</I
></CODE
>]</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28087"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28089"
></A
>Delete a breakpoint at the specified <CODE
CLASS="replaceable"
><I
>line</I
></CODE
>.  If
<CODE
CLASS="replaceable"
><I
>line</I
></CODE
> is omitted, deletes the breakpoint on the line
that is about to be executed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>D</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28099"
></A
>Delete all installed breakpoints.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>a</CODE
> [<CODE
CLASS="replaceable"
><I
>line</I
></CODE
>] <CODE
CLASS="replaceable"
><I
>command</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28108"
></A
>Set an action to be done before the <CODE
CLASS="replaceable"
><I
>line</I
></CODE
> is
executed.  The sequence of steps taken by the debugger is:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Check for a breakpoint at this line.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Print the line if necessary (tracing).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do any actions associated with that line.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Prompt the user if at a breakpoint or in single-step.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Evaluate the line.</P
></LI
></UL
><P
CLASS="para"
>For example, this will print out <CODE
CLASS="literal"
>$foo</CODE
> every time line
53 is passed:</P
><PRE
CLASS="programlisting"
>a 53 print &quot;DB FOUND $foo\n&quot;</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>A</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Delete all installed actions.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>O</CODE
><CODE
CLASS="literal"
> [</CODE
><CODE
CLASS="replaceable"
><I
>opt</I
></CODE
><CODE
CLASS="literal"
>[=</CODE
><CODE
CLASS="replaceable"
><I
>val</I
></CODE
><CODE
CLASS="literal"
>]]</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28141"
></A
>Set or query values of options.  <CODE
CLASS="replaceable"
><I
>val</I
></CODE
> defaults to
1.  <CODE
CLASS="replaceable"
><I
>opt</I
></CODE
> can be abbreviated to the shortest unique
string, which is why some options are uppercase and others are
lowercase.  Options are:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Option</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Value</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>recallCommand ShellBang</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>The characters used to recall command or spawn shell.  By
default, these are both set to &quot;!&quot; (see below).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>pager</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Program to use for output of pager-piped commands (those
beginning with a <CODE
CLASS="literal"
>|</CODE
> character). By default,
<CODE
CLASS="literal"
>$ENV{PAGER}</CODE
> will be used.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>PrintRet</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Enables printing of return value after <CODE
CLASS="literal"
>r</CODE
> command.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>frame</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Enables printing messages on entry and exit from subroutines.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The following options affect what happens with <CODE
CLASS="literal"
>V</CODE
>,
<CODE
CLASS="literal"
>X</CODE
>, and <CODE
CLASS="literal"
>x</CODE
> commands:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Option</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Value</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>arrayDepth hashDepth</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Print only to depth <CODE
CLASS="replaceable"
><I
>n</I
></CODE
> (&quot;&quot; for all).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>compactDump veryCompact</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Change style of array and hash dump.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>globPrint</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Whether to print contents of globs.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>DumpDBFiles</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Dump arrays holding debugged files.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>DumpPackages</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Dump symbol tables of packages.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>quote HighBit undefPrint</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Change style of string dump.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>tkRunning</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Run Tk while prompting (with ReadLine).[<A
CLASS="footnote"
HREF="#AUTOID-28224"
>3</A
>]</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>signalLevel warnLevel dieLevel</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Level of verbosity.</P
></TD
></TR
></TBODY
></TABLE
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-28224"
>[3]</A
> A Perl application is
usually frozen when sitting at the debugger prompt. Tk
support keeps the event loop of Tk running while reading the prompt.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>During startup, options are initialized from
<CODE
CLASS="literal"
>$ENV{PERLDB_OPTS}</CODE
>.  You can put additional
initialization options <CODE
CLASS="literal"
>TTY</CODE
>,
<CODE
CLASS="literal"
>noTTY</CODE
>, <CODE
CLASS="literal"
>ReadLine</CODE
>, and
<CODE
CLASS="literal"
>NonStop</CODE
> there.  Here's an example using the
<CODE
CLASS="literal"
>$ENV{PERLDB_OPTS}</CODE
> variable:</P
><PRE
CLASS="programlisting"
>$ PERLDB_OPTS=&quot;N f=2&quot; perl -d myprogram</PRE
><P
CLASS="para"
>This will run the script <CODE
CLASS="literal"
>myprogram</CODE
> without human intervention,
printing out the call tree with entry and exit points.  Note that
&quot;<CODE
CLASS="literal"
>N&nbsp;f=2</CODE
>&quot; is equivalent to
&quot;<CODE
CLASS="literal"
>NonStop=1 frame=2</CODE
>&quot;.</P
></DD
><DT
CLASS="term"
>&lt; <CODE
CLASS="replaceable"
><I
>command</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28248"
></A
>Set an action to happen before every debugger prompt.  A multi-line
<CODE
CLASS="replaceable"
><I
>command</I
></CODE
> may be entered by backslashing the newlines.  <CODE
CLASS="replaceable"
><I
>command</I
></CODE
>
should be Perl code.</P
></DD
><DT
CLASS="term"
>&gt; <CODE
CLASS="replaceable"
><I
>command</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28258"
></A
>Set an action to happen after the prompt when you've just given a
command to return to executing the script.  A multi-line <CODE
CLASS="replaceable"
><I
>command</I
></CODE
> may be
entered by backslashing the newlines.  <CODE
CLASS="replaceable"
><I
>command</I
></CODE
> should be Perl
code.</P
></DD
><DT
CLASS="term"
>! <CODE
CLASS="replaceable"
><I
>number</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28268"
></A
>Redo a previous command (defaults to previous command).</P
></DD
><DT
CLASS="term"
>! -<CODE
CLASS="replaceable"
><I
>number</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>&#13;
Redo <CODE
CLASS="replaceable"
><I
>number</I
></CODE
>'th-to-last command.</P
></DD
><DT
CLASS="term"
>! <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Redo last command that started with <CODE
CLASS="replaceable"
><I
>pattern</I
></CODE
>.
See &quot;<CODE
CLASS="literal"
>O recallCommand</CODE
>&quot;, too.</P
></DD
><DT
CLASS="term"
>!! <CODE
CLASS="replaceable"
><I
>cmd</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28289"
></A
>Run <CODE
CLASS="replaceable"
><I
>cmd</I
></CODE
> in a subprocess (which will read from
<CODE
CLASS="literal"
>DB::IN</CODE
>, write to <CODE
CLASS="literal"
>DB::OUT</CODE
>).
See &quot;<CODE
CLASS="literal"
>O shellBang</CODE
>&quot;, too.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>H -</CODE
><CODE
CLASS="replaceable"
><I
>number</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28302"
></A
>Display last <CODE
CLASS="replaceable"
><I
>number</I
></CODE
> commands.  Only commands longer
than one character are listed.  If <CODE
CLASS="replaceable"
><I
>number</I
></CODE
> is omitted,
lists them all.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>q</CODE
> or <CODE
CLASS="literal"
>^D</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28312"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28314"
></A
>Quit.  (&quot;<CODE
CLASS="literal"
>quit</CODE
>&quot; doesn't quite work for this.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>R</CODE
>   </DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28323"
></A
>Restart the debugger by <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
>ing a new session.  It tries to maintain
your history across this, but internal settings and command line options
may be lost.</P
></DD
><DT
CLASS="term"
>|<CODE
CLASS="replaceable"
><I
>dbcmd</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28331"
></A
>Run debugger command, piping <CODE
CLASS="literal"
>DB::OUT</CODE
> to <CODE
CLASS="literal"
>$ENV{PAGER}</CODE
>.</P
></DD
><DT
CLASS="term"
>||<CODE
CLASS="replaceable"
><I
>dbcmd</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28341"
></A
>Same as |<CODE
CLASS="replaceable"
><I
>dbcmd</I
></CODE
> but <CODE
CLASS="literal"
>DB::OUT</CODE
>
is temporarily <B
CLASS="emphasis.bold"
>select</B
>ed as well.
Often used with commands that would otherwise produce long
output, such as</P
><PRE
CLASS="programlisting"
>|V main</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>= [</CODE
><CODE
CLASS="replaceable"
><I
>alias value</I
></CODE
><CODE
CLASS="literal"
>]</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28356"
></A
>Define a command alias, or list current aliases.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="replaceable"
><I
>command</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Execute <CODE
CLASS="replaceable"
><I
>command</I
></CODE
> as a Perl statement.  A semicolon is
not needed at the end.</P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.2"
>8.1.2 Using the Debugger</A
></H3
><P
CLASS="para"
>If you have any compile-time executable statements (code within a
<CODE
CLASS="literal"
>BEGIN</CODE
> block or a <CODE
CLASS="literal"
>use</CODE
> statement),
they will not be stopped by the debugger,
although <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>s will.</P
><P
CLASS="para"
>The debugger prompt is something like:</P
><PRE
CLASS="programlisting"
>DB&lt;8&gt;</PRE
><P
CLASS="para"
>or even:</P
><PRE
CLASS="programlisting"
>DB&lt;&lt;17&gt;&gt;</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28376"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28379"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28381"
></A
>where that number is the command number.  A <EM
CLASS="emphasis"
>csh</EM
>-like history
mechanism allows you to access previous commands by number.  For example,
<CODE
CLASS="literal"
>!17</CODE
> would repeat
command number 17.  The number of angle brackets indicates the depth of
the debugger.  You get more than one set of brackets, for example, if
you're already at a breakpoint and then print out the result of a
function call that itself also has a breakpoint.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28387"
></A
>If you want to enter a multi-line command, such as a subroutine
definition with several statements, you may escape the newline that would
normally end the debugger command with a backslash.  Here's an example:</P
><PRE
CLASS="programlisting"
>DB&lt;1&gt; <B
CLASS="emphasis.bold"
>for (1..4) {         \</B
>
  cont:     <B
CLASS="emphasis.bold"
>print &quot;ok\n&quot;;    \</B
>
  cont: <B
CLASS="emphasis.bold"
>}</B
>
  ok
  ok
  ok
  ok</PRE
><P
CLASS="para"
>Note that this business of escaping a newline is specific to interactive
commands typed into the debugger.</P
><P
CLASS="para"
>Let's say you want to fire up the debugger on a little program 
of yours (let's call it <EM
CLASS="emphasis"
>camel_flea</EM
>), and stop it as soon 
as it gets down to a function named <CODE
CLASS="literal"
>infested</CODE
>.  Here's how
you'd do that:
&#13;</P
><PRE
CLASS="programlisting"
><CODE
CLASS="replaceable"
><I
>shell_prompt%</I
></CODE
> <B
CLASS="emphasis.bold"
>perl -d camel_flea</B
>
Stack dump during die enabled outside of evals.

Loading DB routines from perl5db.pl patch level 0.94
Emacs support available.

Enter h or `h h' for help.

main::(camel_flea:3):   $a = 1;
  DB&lt;1&gt;</PRE
><P
CLASS="para"
>The debugger halts your program right before the first run-time
executable statement (but see above regarding compile-time statements) and
asks you to enter a command.  Contrary to popular expectations,
whenever the debugger stops to show you a line of code, it 
displays the line it's <EM
CLASS="emphasis"
>about</EM
> to execute, not the one it
just executed.</P
><P
CLASS="para"
>Now, you'd like to stop as soon as your program gets to the
<CODE
CLASS="literal"
>infested</CODE
> function, so you enter a breakpoint there like so:</P
><PRE
CLASS="programlisting"
>DB&lt;1&gt; <B
CLASS="emphasis.bold"
>b infested</B
>
DB&lt;2&gt; <B
CLASS="emphasis.bold"
>c</B
></PRE
><P
CLASS="para"
>The debugger now continues until it hits that function, at which point
it does this:</P
><PRE
CLASS="programlisting"
>main::infested(camel_flea:12):      my bugs;</PRE
><P
CLASS="para"
>It might be nice to look at a window of source code around the
breakpoint, so you use the <CODE
CLASS="literal"
>w</CODE
> command:<A
CLASS="indexterm"
NAME="AUTOID-28412"
></A
></P
><PRE
CLASS="programlisting"
>DB&lt;2&gt; <B
CLASS="emphasis.bold"
>w</B
>
9:      } 
10:
11:     sub infested {
12==&gt;b      my $bugs;
13:         return 3.5;
14:     } 
DB&lt;2&gt;</PRE
><P
CLASS="para"
>As you see, your current line is line 12, and it has a breakpoint
on it.</P
><P
CLASS="para"
>Now, you'd like to see who called whom, so you ask for a stack 
backtrace:</P
><PRE
CLASS="programlisting"
>DB&lt;2&gt; <B
CLASS="emphasis.bold"
>T</B
>
$ = main::infested called from file `Ambulation.pm' line 10
@ = Ambulation::legs(1, 2, 3, 4) called from file `camel_flea' line 7
$ = main::pests('bactrian', 4) called from file `camel_flea' line 4</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28421"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28424"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28427"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28430"
></A
>The left-hand character up there (<CODE
CLASS="literal"
>$</CODE
> or <CODE
CLASS="literal"
>@</CODE
>)
tells whether the function was called in a scalar or list context (we bet you
can tell which is which).  There are three lines because you were three
functions deep when you ran the stack backtrace.  Here's what each line means:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Line number one says you were in the function <CODE
CLASS="literal"
>main::infested</CODE
> when
you ran the stack dump.  It tells you the function was called in a scalar
context from line 10 of the file <EM
CLASS="emphasis"
>Ambulation.pm</EM
>.  It also shows that
it was called without any arguments whatsoever, meaning it was called as
<CODE
CLASS="literal"
>&amp;infested</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Line number two shows that the function <CODE
CLASS="literal"
>Ambulation::legs</CODE
> was
called in a list context from the <EM
CLASS="emphasis"
>camel_flea</EM
> file with four
arguments.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Line number three shows that <CODE
CLASS="literal"
>main::pests</CODE
> was called in a scalar
context, also from <EM
CLASS="emphasis"
>camel_flea</EM
>, but from line 4.</P
></LI
></UL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28450"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28453"
></A
>Limited control over the Perl debugger can also be managed from within your Perl
script itself.  You might do this, for example, to set an automatic breakpoint
at a certain subroutine whenever a particular program is run under the debugger.
Setting <CODE
CLASS="literal"
>$DB::single</CODE
> to 1 will stop at the next statement as
though you'd used the debugger's <CODE
CLASS="literal"
>s</CODE
> command.  If you set
<CODE
CLASS="literal"
>$DB::single</CODE
> to 2, it's equivalent to having just typed the
<CODE
CLASS="literal"
>n</CODE
> command.  The <CODE
CLASS="literal"
>$DB::trace</CODE
> variable can be
set to 1 to simulate having typed the <CODE
CLASS="literal"
>t</CODE
> command.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.3"
>8.1.3 Debugger Customization</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28465"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28467"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28470"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28472"
></A
>To modify the debugger, copy <EM
CLASS="emphasis"
>perl5db.pl</EM
> from the Perl
library to another file and modify it as necessary.  You'll also want
to set your <CODE
CLASS="literal"
>PERL5DB</CODE
> environment variable to say something like this:</P
><PRE
CLASS="programlisting"
>BEGIN { require &quot;myperl5db.pl&quot; }</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28479"
></A
>You can do some customization by setting up a <EM
CLASS="emphasis"
>.perldb</EM
> file with
initialization code.  For instance, you could make aliases
like these (the last one is one people expect to be there):</P
><PRE
CLASS="programlisting"
>$DB::alias{'len'}  = 's/^len(.*)/p length($1)/';
$DB::alias{'stop'} = 's/^stop (at|in)/b/';
$DB::alias{'ps'}   = 's/^ps\b/p scalar /';
$DB::alias{'quit'} = 's/^quit\b.*/exit/';</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.4"
>8.1.4 Readline Support</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28486"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28488"
></A
>As shipped, the only command-line history mechanism supplied is a simplistic one
that checks for leading exclamation points.  This is fine for casual use.
However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN,
you will have full editing capabilities much like GNU
<EM
CLASS="emphasis"
>readline</EM
>(3) provides.  Look for these in the
<EM
CLASS="emphasis"
>modules/by-module/Term</EM
> directory on CPAN.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.5"
>8.1.5 Editor Support for Debugging</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28495"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28497"
></A
>If you have GNU <EM
CLASS="emphasis"
>emacs</EM
> installed on your system, it can
interact with the Perl debugger to provide an integrated software development
environment reminiscent of its interactions with C debuggers.</P
><P
CLASS="para"
>Perl is also delivered with a start file for making <EM
CLASS="emphasis"
>emacs</EM
>
act like a syntax-directed editor that understands (some of) Perl's syntax.
Look in the <EM
CLASS="emphasis"
>emacs/</EM
> directory of the Perl source
distribution.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28504"
></A
>(Historically, a similar setup for interacting with <EM
CLASS="emphasis"
>vi</EM
> and the
X11 window system had also been available, but at the time of this
writing, no debugger support for <EM
CLASS="emphasis"
>vi</EM
> currently exists.)
 
 </P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.6"
>8.1.6 Debugger Internals</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28511"
></A
>When you call the <A
CLASS="xref"
HREF="ch03_010.htm"
TITLE="caller"
><B
CLASS="xref.cmd"
>caller</B
></A
> function from
package DB, Perl sets the <CODE
CLASS="literal"
>@DB::args</CODE
> array to the arguments
that stack frame was called with.  It also maintains other magical internal
variables, such as <CODE
CLASS="literal"
>@DB::dbline</CODE
>, an array of the source code
lines for the currently selected (with the debugger's <CODE
CLASS="literal"
>f</CODE
>
command) file.  Perl effectively inserts a call to the function
<CODE
CLASS="literal"
>DB::DB</CODE
>(<CODE
CLASS="replaceable"
><I
>linenum</I
></CODE
>) in front of every
place that can have a breakpoint. Instead of a subroutine call it calls
<CODE
CLASS="literal"
>DB::sub</CODE
>, setting <CODE
CLASS="literal"
>$DB::sub</CODE
> to the name of
the called subroutine. It also inserts a <CODE
CLASS="literal"
>BEGIN {require
'perl5db.pl'}</CODE
> before the first line, since no subroutine call is
possible until <CODE
CLASS="literal"
>&amp;DB::sub</CODE
> is defined (for subroutines
defined outside this file).  In fact, the same is true if
<CODE
CLASS="literal"
>$DB::deep</CODE
> (how many levels of recursion deep into the
debugger you are) is not defined.</P
><P
CLASS="para"
>At the start, the debugger reads your config file
(<EM
CLASS="emphasis"
>./.perldb</EM
> or <EM
CLASS="emphasis"
>~/.perldb</EM
> under
UNIX), which can set important options.  This file may define a subroutine
<CODE
CLASS="literal"
>&amp;afterinit</CODE
> to be executed after the debugger is
initialized.</P
><P
CLASS="para"
>After the config file is processed, the debugger consults the environment variable
PERLDB_OPTS and parses it as arguments to the <CODE
CLASS="literal"
>O</CODE
>
<CODE
CLASS="replaceable"
><I
>opt=val</I
></CODE
> debugger command.</P
><P
CLASS="para"
>The following options can only be specified at startup.  To set them in your
config file, call <CODE
CLASS="literal"
>&amp;parse_options(&quot;</CODE
><CODE
CLASS="replaceable"
><I
>opt</I
></CODE
><CODE
CLASS="literal"
>=</CODE
><CODE
CLASS="replaceable"
><I
>val</I
></CODE
><CODE
CLASS="literal"
>&quot;)</CODE
>.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
>TTY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The TTY to use for debugging I/O.</P
></DD
><DT
CLASS="term"
>noTTY</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If set, goes in <CODE
CLASS="literal"
>NonStop</CODE
> mode.  On an interrupt, if TTY is
not set, it uses the value of <CODE
CLASS="literal"
>noTTY</CODE
> or <EM
CLASS="emphasis"
>/tmp/perldbtty$$</EM
> to find
TTY using <CODE
CLASS="literal"
>Term::Rendezvous</CODE
>.  The current variant is to have the
name of TTY in this file.</P
></DD
><DT
CLASS="term"
>ReadLine</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If false, a dummy ReadLine is used so that you can debug
ReadLine applications.</P
></DD
><DT
CLASS="term"
>NonStop</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>If true, no interaction is performed until an interrupt.</P
></DD
><DT
CLASS="term"
>LineInfo</DT
><DD
CLASS="listitem"
><P
CLASS="para"
>File or pipe to print line number info to.  If it's a
pipe, then a short, <EM
CLASS="emphasis"
>emacs</EM
>-like message is used.

Example config file:</P
><PRE
CLASS="programlisting"
>&amp;parse_options(&quot;NonStop=1 LineInfo=db.out&quot;);
sub afterinit { $trace = 1; }</PRE
><P
CLASS="para"
>The script will run without human intervention, putting trace information
into the file <EM
CLASS="emphasis"
>db.out</EM
>.  (If you interrupt it, you had better reset
<CODE
CLASS="literal"
>LineInfo</CODE
> to something &quot;interactive&quot;!)</P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.7"
>8.1.7 Debugger Bugs</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28570"
></A
>If your program <A
CLASS="xref"
HREF="ch03_035.htm"
TITLE="exit"
><B
CLASS="xref.cmd"
>exit</B
></A
>s or 
<A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
>s, so too does the debugger.</P
><P
CLASS="para"
>You cannot get the stack frame information or otherwise debug functions
that were not compiled by Perl, such as C or C++ extensions.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28577"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28580"
></A
>If you alter your <B
CLASS="emphasis.bold"
>@_</B
> arguments in a
subroutine (such as with <A
CLASS="xref"
HREF="ch03_143.htm"
TITLE="shift"
><B
CLASS="xref.cmd"
>shift</B
></A
> or
<A
CLASS="xref"
HREF="ch03_108.htm"
TITLE="pop"
><B
CLASS="xref.cmd"
>pop</B
></A
>), the stack backtrace will not show
the original values.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.8"
>8.1.8 Alternative Debuggers: The Perl Profiler</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28589"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28592"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28594"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28596"
></A
>If you wish to supply an alternative debugger for Perl to run, just invoke
your script with the <CODE
CLASS="literal"
>-d:</CODE
><EM
CLASS="emphasis"
>module</EM
> switch.
One of the most popular alternative debuggers for Perl is
DProf, the Perl profiler.   As of this writing, DProf was not
included with the standard Perl distribution, but it is expected to be
included &quot;real soon now.&quot;</P
><P
CLASS="para"
>Meanwhile, you can fetch the Devel::DProf module from CPAN.  Assuming
it's properly installed on your system, you can use it to profile the
Perl program in <EM
CLASS="emphasis"
>mycode.pl</EM
> by typing:</P
><PRE
CLASS="programlisting"
>perl -d:DProf mycode.pl</PRE
><P
CLASS="para"
>When the script terminates, the profiler will dump the profile
information to a file called <EM
CLASS="emphasis"
>tmon.out</EM
>.  A tool
like <EM
CLASS="emphasis"
>dprofpp</EM
> (also supplied with the Devel::DProf
package) interprets the profile.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-1.9"
>8.1.9 Other Debugging Resources</A
></H3
><P
CLASS="para"
>You did try the <B
CLASS="emphasis.bold"
>-w</B
> switch, didn't you?</P
><A
CLASS="indexterm"
NAME="AUTOID-28610"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28611"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28612"
></A
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch07_02.htm"
TITLE="7.2 Library Modules"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 7.2 Library Modules"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_02.htm"
TITLE="8.2 Common Goofs for Novices"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.2 Common Goofs for Novices"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>7.2 Library Modules</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.2 Common Goofs for Novices</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
