<HTML
><HEAD
>
<TITLE>[Chapter 2] 2.9 Special Variables</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:46:26Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"><LINK
REL="prev"
HREF="ch02_08.htm"
TITLE="2.8 Formats"><LINK
REL="next"
HREF="ch03_01.htm"
TITLE="3. Functions"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_08.htm"
TITLE="2.8 Formats"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.8 Formats"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"
>Chapter 2<BR>The Gory Details</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="CHAPTER"
HREF="ch03_01.htm"
TITLE="3. Functions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 3. Functions"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-9"
>2.9 Special Variables</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.SPECIAL1"
></A
><A
CLASS="indexterm"
NAME="CH02.SPECIAL2"
></A
>The following names have special meaning to Perl.  Most of the
punctuational names have reasonable mnemonics, or analogs in one of
the shells.  Nevertheless, if you wish to use the long variable names,
just say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>use English;</PRE
></P
><P
CLASS="para"
>at the top of your program.  This will alias all the short names to the long names in the current package.  Some of them even have medium names,
generally borrowed from <EM
CLASS="emphasis"
>awk</EM
>(1).</P
><P
CLASS="para"
>A few of these variables are considered read-only.  This means that if
you try to assign to this variable, either directly, or indirectly through
a reference, you'll raise a run-time exception.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-9.1"
>2.9.1 Regular Expression Special Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7452"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7455"
></A
>There are several variables that are associated with regular expressions
and pattern matching.  Except for <B
CLASS="emphasis.bold"
>$*</B
> they are always local to the
current block, so you never need to mention them in a <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
>.  (And
<B
CLASS="emphasis.bold"
>$*</B
> is deprecated, so you never need to mention it at all.)</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>$</CODE
><CODE
CLASS="replaceable"
><I
>digit</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7468"
></A
>Contains the text matched by the corresponding set of parentheses in
the last pattern matched, not counting patterns matched in nested
blocks that have been exited already.  (Mnemonic: like <CODE
CLASS="literal"
>\</CODE
><CODE
CLASS="replaceable"
><I
>digit</I
></CODE
>.)
These variables are all read-only.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$&amp;</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$MATCH</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7479"
></A
>The string matched by the last successful pattern match, not counting any
matches hidden within a block or <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> enclosed by the
current block.  (Mnemonic: like <CODE
CLASS="literal"
>&amp;</CODE
> in some editors.)  This
variable is read-only. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$`</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$PREMATCH</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7491"
></A
>The string preceding whatever was matched by the last successful pattern
match not counting any matches hidden within a block or <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>
enclosed by the current block.  (Mnemonic: <CODE
CLASS="literal"
>`</CODE
> often precedes a
quoted string.)  This variable is read-only. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$'</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$POSTMATCH</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7503"
></A
>The string following whatever was matched by the last successful pattern
match not counting any matches hidden within a block or <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>
enclosed by the current block.
(Mnemonic: <CODE
CLASS="literal"
>'</CODE
> often follows a quoted
string.)  Example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$_ = 'abcdefghi';
/def/;
print &quot;$`:$&amp;:$'\n&quot;;         # prints abc:def:ghi</PRE
></P
><P
CLASS="para"
>This variable is read-only.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$+</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$LAST_PAREN_MATCH</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7518"
></A
>The last bracket matched by the last search pattern.  This is useful if you
don't know which of a set of alternative patterns matched.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/Version: (.*)|Revision: (.*)/ &amp;&amp; ($rev = $+);</PRE
></P
><P
CLASS="para"
>(Mnemonic: be positive and forward looking.)  This variable is read-only.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$*</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$MULTILINE_MATCHING</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7531"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7534"
></A
>Use of <B
CLASS="emphasis.bold"
>$*</B
> is now deprecated, and is allowed only for maintaining backwards
compatibility with older versions of Perl.  Use <B
CLASS="emphasis.bold"
>/m</B
> (and maybe <B
CLASS="emphasis.bold"
>/s</B
>)
in the regular expression match instead.</P
><P
CLASS="para"
>Set to 1 to do multi-line matching within a string, 0 to tell Perl that it
can assume that strings contain a single line for the purpose of
optimizing pattern matches.  Pattern matches on strings containing multiple
newlines can produce confusing results when <B
CLASS="emphasis.bold"
>$*</B
> is 0.  Default is 0.
(Mnemonic: <CODE
CLASS="literal"
>*</CODE
> matches multiple things.) Note that this variable only
influences the interpretation of <CODE
CLASS="literal"
>^</CODE
> and <CODE
CLASS="literal"
>$</CODE
>.  A literal
newline can be searched for even when <CODE
CLASS="literal"
>$* == 0</CODE
>.</P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-9.2"
>2.9.2 Per-Filehandle Special Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7549"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7552"
></A
>These variables never need to be mentioned in a <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> 
because they always refer to some value
pertaining to the currently selected output filehandle&nbsp;- each
filehandle keeps its own set of values.  When you <B
CLASS="emphasis.bold"
>select</B
> another filehandle, the old filehandle
keeps whatever values it had in effect, and the variables now reflect
the values of the new filehandle.</P
><P
CLASS="para"
>To go a step further and avoid <B
CLASS="emphasis.bold"
>select</B
>
entirely, these variables that depend on the currently selected
filehandle may instead be set by calling an object method on the
FileHandle object.  (Summary lines below for this contain the word
<CODE
CLASS="replaceable"
><I
>HANDLE</I
></CODE
>.)  First you must say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>use FileHandle;</PRE
></P
><P
CLASS="para"
>after which you may use either:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
><CODE
CLASS="replaceable"
><I
>method</I
></CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE</I
></CODE
> <CODE
CLASS="replaceable"
><I
>EXPR</I
></CODE
></PRE
></P
><P
CLASS="para"
>or:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
><CODE
CLASS="replaceable"
><I
>HANDLE</I
></CODE
>-&gt;<CODE
CLASS="replaceable"
><I
>method</I
></CODE
>(<CODE
CLASS="replaceable"
><I
>EXPR</I
></CODE
>)</PRE
></P
><P
CLASS="para"
>Each of the methods returns the old value of the FileHandle attribute.
The methods each take an optional <CODE
CLASS="replaceable"
><I
>EXPR</I
></CODE
>, which if supplied specifies the
new value for the FileHandle attribute in question.  If not supplied,
most of the methods do nothing to the current value, except for
<CODE
CLASS="literal"
>autoflush</CODE
>, which will assume a <CODE
CLASS="literal"
>1</CODE
> for you, just to be different.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>$|</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OUTPUT_AUTOFLUSH</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>autoflush</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7589"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7592"
></A
>If set to nonzero, forces an <EM
CLASS="emphasis"
>fflush</EM
>(3) after every <B
CLASS="emphasis.bold"
>write</B
> or
<B
CLASS="emphasis.bold"
>print</B
> on the currently selected output channel.  (This is called
&quot;command buffering&quot;.  Contrary to popular belief, setting this variable
does not turn off buffering.)  Default is 0, which on many systems
means that <CODE
CLASS="literal"
>STDOUT</CODE
> will default to being line buffered if output is to
the terminal, and block buffered otherwise.  Setting this variable is
useful primarily when you are outputting to a pipe, such as when you are
running a Perl script under <EM
CLASS="emphasis"
>rsh</EM
> and want to see the output as it's
happening.  This has no effect on input buffering.  If you have a need to
flush a buffer immediately after setting <B
CLASS="emphasis.bold"
>$|</B
>,
you may simply <CODE
CLASS="literal"
>print &quot;&quot;;</CODE
> rather than waiting for the
next <B
CLASS="emphasis.bold"
>print</B
> to flush it.  (Mnemonic: when you
want your pipes to be piping hot.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$%</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_PAGE_NUMBER</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_page_number</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7613"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7615"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7617"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7619"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7622"
></A
>The current page number of the currently selected output channel.
(Mnemonic: <CODE
CLASS="literal"
>%</CODE
> is page number in <EM
CLASS="emphasis"
>nroff</EM
>.) </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$=</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_LINES_PER_PAGE</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_lines_per_page</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7637"
></A
>The current page length (printable lines) of the currently selected output
channel.  Default is 60.  (Mnemonic: <CODE
CLASS="literal"
>=</CODE
> has horizontal lines.) </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$-</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_LINES_LEFT</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_lines_left</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7651"
></A
>The number of lines left on the page of the currently selected output
channel.  (Mnemonic: <CODE
CLASS="literal"
>lines_on_page - lines_printed</CODE
>.) </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$~</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_NAME</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_name</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7665"
></A
>The name of the current report format for the currently selected output
channel.  Default is name of the filehandle.  (Mnemonic: takes a turn after
<B
CLASS="emphasis.bold"
>$^</B
>.) </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_TOP_NAME</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_top_name</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7679"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7682"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7684"
></A
>The name of the current top-of-page format for the currently selected
output channel.  Default is name of the filehandle with <CODE
CLASS="literal"
>_TOP</CODE
> appended.
(Mnemonic: points to top of page.)</P
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-9.3"
>2.9.3 Global Special Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.GLOBAL1"
></A
><A
CLASS="indexterm"
NAME="CH02.GLOBAL2"
></A
>There are quite a few variables that are global in the fullest
sense&nbsp;- they mean the same thing in every package.  If you want a
private copy of one of these, you must localize it in the current
block.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>$_</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$ARG</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7705"
></A
>The default input and pattern-searching space. These pairs are
equivalent:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while (&lt;&gt;) {...}    # only equivalent in while!
while (defined($_ = &lt;&gt;)) {...}

/^Subject:/
$_ =~ /^Subject:/

tr/a-z/A-Z/
$_ =~ tr/a-z/A-Z/

chop
chop($_)</PRE
></P
><P
CLASS="para"
>Here are the places where Perl will assume <B
CLASS="emphasis.bold"
>$_</B
> even if you don't use
it: </P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Various unary functions, including functions like <A
CLASS="xref"
HREF="ch03_104.htm"
TITLE="ord"
><B
CLASS="xref.cmd"
>ord</B
></A
> and
<A
CLASS="xref"
HREF="ch03_076.htm"
TITLE="int"
><B
CLASS="xref.cmd"
>int</B
></A
>, as well as all the file tests (<CODE
CLASS="literal"
>-f</CODE
>, <CODE
CLASS="literal"
>-d</CODE
>) except for
<CODE
CLASS="literal"
>-t</CODE
>, which defaults to <CODE
CLASS="literal"
>STDIN</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Various list functions like <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> and <A
CLASS="xref"
HREF="ch03_181.htm"
TITLE="unlink"
><B
CLASS="xref.cmd"
>unlink</B
></A
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The pattern-matching operations <CODE
CLASS="literal"
>m//</CODE
>, <CODE
CLASS="literal"
>s///</CODE
>, and <CODE
CLASS="literal"
>tr///</CODE
>
when used without an <CODE
CLASS="literal"
>=~</CODE
> operator.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The default iterator variable in a <B
CLASS="emphasis.bold"
>foreach</B
> loop if no other
variable is supplied. </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The implicit iterator variable in the <A
CLASS="xref"
HREF="ch03_072.htm"
TITLE="grep"
><B
CLASS="xref.cmd"
>grep</B
></A
> and <A
CLASS="xref"
HREF="ch03_091.htm"
TITLE="map"
><B
CLASS="xref.cmd"
>map</B
></A
>
functions.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The default place to put an input record when a <CODE
CLASS="literal"
>&lt;FH&gt;</CODE
> operation's
result is tested by itself as the sole criterion of a <B
CLASS="emphasis.bold"
>while</B
> test.
Note that outside of a <B
CLASS="emphasis.bold"
>while</B
> test, this
will not happen. </P
></LI
></UL
><P
CLASS="para"
>Mnemonic: underline is the underlying operand in certain operations.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$.</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$INPUT_LINE_NUMBER</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$NR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7753"
></A
>The current input line number of the last filehandle that was read.  An
explicit close on the filehandle resets the line number.  Since <CODE
CLASS="literal"
>&lt;&gt;</CODE
>
never does an explicit close, line numbers increase across
<B
CLASS="emphasis.bold"
>ARGV</B
> files (but see examples under <A
CLASS="xref"
HREF="ch03_031.htm"
TITLE="eof"
><B
CLASS="xref.cmd"
>eof</B
></A
> in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>).  Localizing
<B
CLASS="emphasis.bold"
>$.</B
> has the effect of also localizing Perl's notion of the last read
filehandle.  (Mnemonic: many programs use &quot;.&quot; to mean the current line
number.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$/</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$INPUT_RECORD_SEPARATOR</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$RS</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7770"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7773"
></A
>The input record separator, newline by default.  It works like <EM
CLASS="emphasis"
>awk</EM
>'s
<CODE
CLASS="literal"
>RS</CODE
> variable, and, if set to the null string, treats blank lines as
delimiters.  You may set it to a multi-character string to match a
multi-character delimiter.  Note that setting it to <CODE
CLASS="literal"
>&quot;\n\n&quot;</CODE
> means
something slightly different than setting it to <CODE
CLASS="literal"
>&quot;&quot;</CODE
>, if the file
contains consecutive blank lines.  Setting it to <CODE
CLASS="literal"
>&quot;&quot;</CODE
> will treat two or
more consecutive blank lines as a single blank line.  Setting it to
<CODE
CLASS="literal"
>&quot;\n\n&quot;</CODE
> means Perl will blindly assume that the next input character belongs to
the next paragraph, even if it's a third newline.  (Mnemonic: <CODE
CLASS="literal"
>/</CODE
> is used to
delimit line boundaries when quoting poetry.)</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>undef $/;
$_ = &lt;FH&gt;;          # whole file now here
s/\n[ \t]+/ /g;</PRE
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$,</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OUTPUT_FIELD_SEPARATOR</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OFS</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7793"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7797"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7801"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7805"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7809"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7813"
></A
>The output field separator for the <B
CLASS="emphasis.bold"
>print</B
> operator.  Ordinarily the <B
CLASS="emphasis.bold"
>print</B
>
operator simply prints out the comma separated fields you specify.  In
order to get behavior more like <EM
CLASS="emphasis"
>awk</EM
>, set this variable as you would
set <EM
CLASS="emphasis"
>awk</EM
>'s <CODE
CLASS="literal"
>OFS</CODE
> variable to specify what is printed between
fields.  (Mnemonic: what is printed when there is a &quot;<CODE
CLASS="literal"
>,</CODE
>&quot; in your <B
CLASS="emphasis.bold"
>print</B
>
statement.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$\</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OUTPUT_RECORD_SEPARATOR</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$ORS</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7832"
></A
>The output record separator for the <B
CLASS="emphasis.bold"
>print</B
> operator.  Ordinarily the
<B
CLASS="emphasis.bold"
>print</B
> operator simply prints out the comma-separated fields you
specify, with no trailing newline or record separator assumed.  In
order to get behavior more like <EM
CLASS="emphasis"
>awk</EM
>, set this variable as you would
set <EM
CLASS="emphasis"
>awk</EM
>'s <CODE
CLASS="literal"
>ORS</CODE
> variable to specify what is printed at the end
of the <B
CLASS="emphasis.bold"
>print</B
>.  (Mnemonic: you set <B
CLASS="emphasis.bold"
>$\</B
> instead of adding <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
> at the
end of the print.  Also, it's just like <CODE
CLASS="literal"
>/</CODE
>, but it's what you get &quot;back&quot;
from Perl.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$&quot;</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$LIST_SEPARATOR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7851"
></A
>This is like <CODE
CLASS="literal"
>$,</CODE
> above except that it applies to list values interpolated
into a double-quoted string (or similar interpreted string).  Default
is a space.  (Mnemonic: obvious, I think.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$;</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$SUBSCRIPT_SEPARATOR</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$SUBSEP</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7864"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7867"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7870"
></A
>The subscript separator for multi-dimensional array emulation.  If you
refer to a hash element as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$foo{$a,$b,$c}</PRE
></P
><P
CLASS="para"
>it really means:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$foo{join($;, $a, $b, $c)}</PRE
></P
><P
CLASS="para"
>But don't put:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@foo{$a,$b,$c}      # a slice--note the @</PRE
></P
><P
CLASS="para"
>which means:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($foo{$a},$foo{$b},$foo{$c})</PRE
></P
><P
CLASS="para"
>Default is <CODE
CLASS="literal"
>&quot;\034&quot;</CODE
>, the same as SUBSEP in <EM
CLASS="emphasis"
>awk</EM
>.  Note that if your
keys contain binary data there might not be any safe value for <CODE
CLASS="literal"
>$;</CODE
>.
(Mnemonic: comma&nbsp;- the syntactic subscript separator&nbsp;- is a
semi-semicolon.  Yeah, I know, it's pretty lame, but <CODE
CLASS="literal"
>$,</CODE
> is already
taken for something more important.)</P
><P
CLASS="para"
>This variable is for maintaining backward compatibility, so consider using
&quot;real&quot; multi-dimensional arrays now.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^L</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_FORMFEED</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_formfeed</CODE
> <CODE
CLASS="replaceable"
><I
>HANDLE EXPR</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7901"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7903"
></A
>What a format outputs to perform a formfeed.  Default is <CODE
CLASS="literal"
>&quot;\f&quot;</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$:</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$FORMAT_LINE_BREAK_CHARACTERS</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>format_line_break_characters HANDLE EXPR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7916"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7919"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7921"
></A
>The current set of characters after which a string may be broken to fill
continuation fields (starting with <CODE
CLASS="literal"
>^</CODE
>) in a format.  Default is <CODE
CLASS="literal"
>&quot; \n-&quot;</CODE
>, to break on whitespace or hyphens.  (Mnemonic:
a colon in poetry is a part of a line.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^A</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$ACCUMULATOR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7934"
></A
>The current value of the <A
CLASS="xref"
HREF="ch03_193.htm"
TITLE="write"
><B
CLASS="xref.cmd"
>write</B
></A
>
accumulator for <A
CLASS="xref"
HREF="ch03_041.htm"
TITLE="format"
><B
CLASS="xref.cmd"
>format</B
></A
> lines.  A format
contains <A
CLASS="xref"
HREF="ch03_042.htm"
TITLE="formline"
><B
CLASS="xref.cmd"
>formline</B
></A
> commands that put
their result into <B
CLASS="emphasis.bold"
>$^A</B
>.  After calling
its format, <A
CLASS="xref"
HREF="ch03_193.htm"
TITLE="write"
><B
CLASS="xref.cmd"
>write</B
></A
> prints out the
contents of <B
CLASS="emphasis.bold"
>$^A</B
> and empties.  So you
never actually see the contents of <B
CLASS="emphasis.bold"
>$^A</B
>
unless you call <A
CLASS="xref"
HREF="ch03_042.htm"
TITLE="formline"
><B
CLASS="xref.cmd"
>formline</B
></A
> yourself and
then look at it.  </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$#</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OFMT</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7952"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7955"
></A
>Use of <B
CLASS="emphasis.bold"
>$#</B
> is now deprecated and is allowed only for maintaining backwards
compatibility with older versions of Perl.  You should use <A
CLASS="xref"
HREF="ch03_111.htm"
TITLE="printf"
><B
CLASS="xref.cmd"
>printf</B
></A
> instead. <B
CLASS="emphasis.bold"
>$#</B
> contains the output format for printed numbers.  This variable is a half-hearted
attempt to emulate <EM
CLASS="emphasis"
>awk</EM
>'s <CODE
CLASS="literal"
>OFMT</CODE
> variable.  There are times, however,
when <EM
CLASS="emphasis"
>awk</EM
> and Perl have differing notions of what is in fact numeric.
Also, the initial value is approximately <CODE
CLASS="literal"
>%.14g</CODE
> rather than <CODE
CLASS="literal"
>%.6g</CODE
>, so you
need to set <B
CLASS="emphasis.bold"
>$#</B
> explicitly to get <EM
CLASS="emphasis"
>awk</EM
>'s value.  (Mnemonic: <CODE
CLASS="literal"
>#</CODE
> is the
number sign.  Better yet, just forget it.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$?</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$CHILD_ERROR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7976"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7979"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7982"
></A
>The status returned by the last pipe close, backtick (<CODE
CLASS="literal"
>``</CODE
>) command,
or <A
CLASS="xref"
HREF="ch03_167.htm"
TITLE="system"
><B
CLASS="xref.cmd"
>system</B
></A
> operator.  Note that this is the status word returned by
the <EM
CLASS="emphasis"
>wait</EM
>(2) system call, so the exit value of the subprocess is actually
<CODE
CLASS="literal"
>($? &gt;&gt; 8)</CODE
>.  Thus on many systems, <CODE
CLASS="literal"
>($? &amp; 255)</CODE
> gives which signal,
if any, the process died from, and whether there was a core dump.
(Mnemonic: similar to <EM
CLASS="emphasis"
>sh</EM
> and <EM
CLASS="emphasis"
>ksh</EM
>.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$!</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OS_ERROR</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$ERRNO</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8000"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8003"
></A
>If used in a numeric context, yields the current value of the
<CODE
CLASS="literal"
>errno</CODE
> variable (identifying the last system call error) in the
currently executing <EM
CLASS="emphasis"
>perl</EM
>, with
all the usual caveats.  (This means that you shouldn't depend on the value
of <B
CLASS="emphasis.bold"
>$!</B
> to be anything in particular unless you've gotten a specific
error return indicating a system error.)  If used in a string context,
yields the corresponding system error string.  You can assign to <B
CLASS="emphasis.bold"
>$!</B
>
in order to set <CODE
CLASS="literal"
>errno</CODE
>, if, for instance, you want <B
CLASS="emphasis.bold"
>$!</B
> to return
the string for error <EM
CLASS="emphasis"
>n</EM
>, or you want to set the exit value for the
<A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
> operator.  (Mnemonic: What just went bang?)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$@</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$EVAL_ERROR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8021"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8024"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8027"
></A
>The Perl syntax error message from the last <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> command.  If null,
the last <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> was parsed and executed correctly (although the operations
you invoked may have failed in the normal fashion).  (Mnemonic: Where was
the syntax error &quot;at&quot;?)</P
><P
CLASS="para"
>Note that warning messages are not collected in this variable.  You can, 
however, set up a routine to process warnings by setting
<CODE
CLASS="literal"
>$SIG{__WARN__}</CODE
> below. </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$$</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$PROCESS_ID</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$PID</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8043"
></A
>The process number of the Perl running this script.  (Mnemonic: same
as shells.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$&lt;</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$REAL_USER_ID</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$UID</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8055"
></A
>The real user ID (uid) of this process.  (Mnemonic: it's the uid you came
<EM
CLASS="emphasis"
>from</EM
>, if you're running setuid.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$&gt;</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$EFFECTIVE_USER_ID</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$EUID</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8068"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8071"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8074"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8077"
></A
>The effective uid of this process.  Example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$&lt; = $&gt;;            # set real to effective uid
($&lt;,$&gt;) = ($&gt;,$&lt;);  # swap real and effective uid</PRE
></P
><P
CLASS="para"
>(Mnemonic: it's the uid you went <EM
CLASS="emphasis"
>to</EM
>, if you're running
setuid.)  Note: <B
CLASS="emphasis.bold"
>$&lt;</B
> and <B
CLASS="emphasis.bold"
>$&gt;</B
> can only be swapped on machines
supporting <EM
CLASS="emphasis"
>setreuid</EM
>(2).  And sometimes not even then.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$(</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$REAL_GROUP_ID</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$GID</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8096"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8099"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8102"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8105"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8108"
></A
>The real group ID (gid) of this process.  If you are on a machine that supports
membership in multiple groups simultaneously, gives a space-separated
list of groups you are in.  The first number is the one returned by
<EM
CLASS="emphasis"
>getgid</EM
>(1), and the subsequent ones by <EM
CLASS="emphasis"
>getgroups</EM
>(2), one of which
may be the same as the first number.  (Mnemonic: parentheses are used to
<EM
CLASS="emphasis"
>group</EM
> things.  The real gid is the group you
<EM
CLASS="emphasis"
>left</EM
>, if you're running setgid.) </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$)</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$EFFECTIVE_GROUP_ID</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$EGID</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The effective gid of this process.  If you are on a machine that
supports membership in multiple groups simultaneously, <B
CLASS="emphasis.bold"
>$)</B
> gives a
space-separated list of groups you are in.  The first number is the
one returned by <EM
CLASS="emphasis"
>getegid</EM
>(2), and the subsequent
ones by <EM
CLASS="emphasis"
>getgroups</EM
>(2), one of which may be the
same as the first number.  (Mnemonic: parentheses are used to
<EM
CLASS="emphasis"
>group</EM
> things.  The effective gid is the group
that's <EM
CLASS="emphasis"
>right</EM
> for you, if you're running setgid.)</P
><P
CLASS="para"
>Note: <B
CLASS="emphasis.bold"
>$&lt;</B
>, <B
CLASS="emphasis.bold"
>$&gt;</B
>, <B
CLASS="emphasis.bold"
>$(</B
>, and
<B
CLASS="emphasis.bold"
>$)</B
> can only be set on machines that
support the corresponding system set-id routine.  <B
CLASS="emphasis.bold"
>$(</B
> and <B
CLASS="emphasis.bold"
>$)</B
> can only
be swapped on machines supporting <EM
CLASS="emphasis"
>setregid</EM
>(2).
Because Perl doesn't currently use <EM
CLASS="emphasis"
>initgroups</EM
>(2),
you can't set your group vector to multiple groups.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$0</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$PROGRAM_NAME</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8145"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8148"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8152"
></A
>Contains the name of the file containing the Perl script being executed.
Assigning to <B
CLASS="emphasis.bold"
>$0</B
> attempts to modify the argument area that the
<EM
CLASS="emphasis"
>ps</EM
>(1) program sees.  This is more useful as a way of indicating the
current program state than it is for hiding the program you're running.
But it doesn't work on all systems.  (Mnemonic: same as <EM
CLASS="emphasis"
>sh</EM
> and
<EM
CLASS="emphasis"
>ksh</EM
>.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$[</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8165"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8168"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8171"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8174"
></A
>The index of the first element in an array, and of the first character in
a substring.  Default is 0, but you could set it to 1 to make Perl
behave more like <EM
CLASS="emphasis"
>awk</EM
> (or FORTRAN) when
subscripting and when evaluating the <A
CLASS="xref"
HREF="ch03_075.htm"
TITLE="index"
><B
CLASS="xref.cmd"
>index</B
></A
> and <A
CLASS="xref"
HREF="ch03_162.htm"
TITLE="substr"
><B
CLASS="xref.cmd"
>substr</B
></A
>
functions.  (Mnemonic: [ begins subscripts.)</P
><P
CLASS="para"
>Assignment to <B
CLASS="emphasis.bold"
>$[</B
> is now treated as a compiler directive, and cannot
influence the behavior of any other file.  Its use is discouraged.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$]</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$PERL_VERSION</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8189"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8192"
></A
>Returns the version + patchlevel / 1000.  It can be used to determine at
the beginning of a script whether the Perl interpreter executing the script
is in the right range of versions.  Example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>warn &quot;No checksumming!\n&quot; if $] &lt; 3.019;
die &quot;Must have prototyping available\n&quot; if $] &lt; 5.003;</PRE
></P
><P
CLASS="para"
>(Mnemonic: Is this version of Perl in the right bracket?)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^D</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$DEBUGGING</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8204"
></A
>The current value of the debugging flags.  (Mnemonic: value of <B
CLASS="emphasis.bold"
>-D</B
>
switch.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^F</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$SYSTEM_FD_MAX</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8215"
></A
>The maximum system file descriptor, ordinarily 2.  System file
descriptors are passed to <EM
CLASS="emphasis"
>exec</EM
>ed
processes, while higher file descriptors are not.  Also, during an
<A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
>, system file descriptors are
preserved even if the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> fails.
(Ordinary file descriptors are closed before the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> is attempted, and stay closed if the
<A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> fails.)  Note that the
close-on-exec status of a file descriptor will be decided according to
the value of <B
CLASS="emphasis.bold"
>$^F</B
> at the time of the
<B
CLASS="emphasis.bold"
>open</B
>, not the time of the <EM
CLASS="emphasis"
>exec</EM
>.  </P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^H</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8231"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8234"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8236"
></A
>This variable contains internal compiler hints enabled by certain 
pragmatic modules.  Hint: ignore this and use the pragmata.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^I</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$INPLACE_EDIT</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8245"
></A
>The current value of the inplace-edit extension.  Use <A
CLASS="xref"
HREF="ch03_180.htm"
TITLE="undef"
><B
CLASS="xref.cmd"
>undef</B
></A
> to disable
inplace editing.  (Mnemonic: value of <B
CLASS="emphasis.bold"
>-i</B
> switch.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^O</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$OSNAME</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8257"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8260"
></A
>This variable contains the name of the operating system the current
Perl binary was compiled for.  It's intended as a cheap alternative
to pulling it out of the Config module.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^P</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$PERLDB</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8270"
></A
>The internal flag that the debugger clears so that it doesn't debug
itself.  You could conceivably disable debugging yourself by clearing
it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^T</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$BASETIME</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8280"
></A
>The time at which the script began running, in seconds since the epoch
(the beginning of 1970, for UNIX systems).  The values returned by the
<CODE
CLASS="literal"
>-M</CODE
>, <CODE
CLASS="literal"
>-A</CODE
>, and <CODE
CLASS="literal"
>-C</CODE
> filetests are based on this value.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^W</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$WARNING</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8293"
></A
>The current value of the warning switch, either true or
false.  (Mnemonic: the value is related to the <B
CLASS="emphasis.bold"
>-w</B
> switch.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$^X</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>$EXECUTABLE_NAME</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8304"
></A
>The name that the Perl binary itself was executed as, from C's <CODE
CLASS="literal"
>argv[0]</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>$ARGV</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8313"
></A
>Contains the name of the current file when reading from <CODE
CLASS="literal"
>&lt;ARGV&gt;</CODE
>.</P
></DD
></DL
><A
CLASS="indexterm"
NAME="AUTOID-8316"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8317"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-9.4"
>2.9.4 Global Special Arrays</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.GAH1"
></A
><A
CLASS="indexterm"
NAME="CH02.GAH2"
></A
><A
CLASS="indexterm"
NAME="CH02.GAH3"
></A
>The following arrays and hashes are global.  Just like the special global
scalar variables, they refer to package main no matter when they are
referenced.  The following two statements are exactly the same:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print &quot;@INC\n&quot;;
print &quot;@main::INC\n&quot;;</PRE
></P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>@ARGV</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8338"
></A
>The array containing the command-line arguments intended for the
script.  Note that <CODE
CLASS="literal"
>$#ARGV</CODE
> is generally the number of arguments minus
one, since <CODE
CLASS="literal"
>$ARGV[0]</CODE
> is the first argument, not the
command name.  See <B
CLASS="emphasis.bold"
>$0</B
> for the command name.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>@INC</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8348"
></A
>The array containing the list of places to look for Perl scripts
to be evaluated by the <CODE
CLASS="literal"
>do EXPR</CODE
>, <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>, or <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
>
constructs.  It initially consists of the arguments to any <B
CLASS="emphasis.bold"
>-I</B
>
command-line switches, followed by the default Perl libraries, such as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/usr/local/lib/perl5/$ARCH/$VERSION
/usr/local/lib/perl5
/usr/local/lib/perl5/site_perl
/usr/local/lib/perl5/site_perl/$ARCH</PRE
></P
><P
CLASS="para"
>followed by &quot;.&quot;, to represent the
current directory.  If you need to modify this list at run-time, you should use
the lib module in order to also get the machine-dependent library
properly loaded:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>use lib '/mypath/libdir/';
use SomeMod;</PRE
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>@F</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8364"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8366"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8368"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8371"
></A
>The array into which the input lines are split when the <B
CLASS="emphasis.bold"
>-a</B
>
command-line switch is given.  If the <B
CLASS="emphasis.bold"
>-a</B
> option is not used, this
array has no special meaning.  (This array is actually only <CODE
CLASS="literal"
>@main::F</CODE
>, and not
in all packages at once.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>%INC</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8381"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8383"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8385"
></A
>The hash containing entries for the filename of each file that has been
included via <A
CLASS="xref"
HREF="ch03_028.htm"
TITLE="do"
><B
CLASS="xref.cmd"
>do</B
></A
> or <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>.  The key is the filename you
specified, and the value is the location of the file actually found.  The
<A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
> command uses this array to determine whether a given file has
already been included.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>%ENV</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8396"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8398"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8400"
></A
>The hash containing your current environment.  Setting a value in <B
CLASS="emphasis.bold"
>%ENV</B
>
changes the environment for child processes:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$ENV{PATH} = &quot;/bin:/usr/bin&quot;;</PRE
></P
><P
CLASS="para"
>To remove something from your environment, make sure
to use <A
CLASS="xref"
HREF="ch03_026.htm"
TITLE="delete"
><B
CLASS="xref.cmd"
>delete</B
></A
> instead of <A
CLASS="xref"
HREF="ch03_180.htm"
TITLE="undef"
><B
CLASS="xref.cmd"
>undef</B
></A
>.</P
><P
CLASS="para"
>Note that processes running as a <EM
CLASS="emphasis"
>crontab</EM
> entry
inherit a particularly impoverished set of environment variables.
Also note that you should set <CODE
CLASS="literal"
>$ENV{PATH}</CODE
>,
<CODE
CLASS="literal"
>$ENV{SHELL}</CODE
>, and <CODE
CLASS="literal"
>$ENV{IFS}</CODE
> if
you are running as a setuid script.  See <A
CLASS="xref"
HREF="ch08_01.htm"
TITLE="Other Oddments"
>Chapter 8, <CITE
CLASS="chapter"
>Other Oddments</CITE
></A
>,
for more on security and setuid issues.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>%SIG</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8420"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8422"
></A
>The hash used to set signal handlers for various signals.  Example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub handler {       # 1st argument is signal name
    local($sig) = @_;
    print &quot;Caught a SIG$sig--shutting down\n&quot;;
    close(LOG);
    exit(0);
}

$SIG{INT} = 'handler';
$SIG{QUIT} = 'handler';
...
$SIG{INT} = 'DEFAULT';    # restore default action
$SIG{QUIT} = 'IGNORE';    # ignore SIGQUIT</PRE
></P
><P
CLASS="para"
>The <B
CLASS="emphasis.bold"
>%SIG</B
> array only contains values for the signals actually set
within the Perl script.  Here are some other examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$SIG{PIPE} = Plumber;     # SCARY!!
$SIG{PIPE} = &quot;Plumber&quot;;   # just fine, assumes main::Plumber
$SIG{PIPE} = \&amp;Plumber;   # just fine; assume current Plumber
$SIG{PIPE} = Plumber();   # oops, what did Plumber() return??</PRE
></P
><P
CLASS="para"
>The example marked <CODE
CLASS="literal"
>SCARY!!</CODE
> is problematic because it's a bareword, which means
sometimes it's a string representing the function, and sometimes it's 
going to call the subroutine right then and there!  Best to be sure
and quote it or take a reference to it.<A
CLASS="indexterm"
NAME="AUTOID-8432"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8434"
></A
>
Certain internal hooks can also be set using the <B
CLASS="emphasis.bold"
>%SIG</B
> hash.  The
routine indicated by <CODE
CLASS="literal"
>$SIG{__WARN__}</CODE
> is called when a warning message
is about to be printed.  The warning message is passed as the first
argument.  The presence of a <CODE
CLASS="literal"
>__WARN__</CODE
> hook causes the ordinary
printing of warnings to <CODE
CLASS="literal"
>STDERR</CODE
> to be suppressed.  You can use this
to save warnings in a variable, or turn warnings into fatal errors, like
this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>local $SIG{__WARN__} = sub { die $_[0] };
eval $proggie;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8443"
></A
>The routine indicated by <CODE
CLASS="literal"
>$SIG{__DIE__}</CODE
> is called
when a fatal exception is about to be thrown.  The error message is
passed as the first argument.  When a <CODE
CLASS="literal"
>__DIE__</CODE
> hook
routine returns, the exception processing continues as it would have
in the absence of the hook, unless the hook routine itself exits via a
<A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>, a loop exit, or a <A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
>.  The <CODE
CLASS="literal"
>__DIE__</CODE
> handler is
explicitly disabled during the call, so that you yourself can then
call the real <A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
> from a
<CODE
CLASS="literal"
>__DIE__</CODE
> handler.  (If it weren't disabled, the
handler would call itself recursively forever.)  The case is similar for
<CODE
CLASS="literal"
>__WARN__</CODE
>.</P
></DD
></DL
><A
CLASS="indexterm"
NAME="AUTOID-8453"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8454"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8455"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-9.5"
>2.9.5 Global Special Filehandles</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8459"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8462"
></A
>The following filehandles (except for <CODE
CLASS="literal"
>DATA</CODE
>) always refer to
<CODE
CLASS="literal"
>main::FILEHANDLE</CODE
>.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>ARGV</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The special filehandle that iterates over command line filenames in
<B
CLASS="emphasis.bold"
>@ARGV</B
>.  Usually written as the null filehandle in <CODE
CLASS="literal"
>&lt;&gt;</CODE
>.<A
CLASS="indexterm"
NAME="AUTOID-8475"
></A
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>STDERR</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The special filehandle for standard error in any package. <A
CLASS="indexterm"
NAME="AUTOID-8482"
></A
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>STDIN</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The special filehandle for standard input in any package.<A
CLASS="indexterm"
NAME="AUTOID-8489"
></A
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>STDOUT</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The special filehandle for standard output in any package.<A
CLASS="indexterm"
NAME="AUTOID-8496"
></A
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>DATA</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8503"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8505"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8507"
></A
>The special filehandle that refers to anything following the
<CODE
CLASS="literal"
>__END__</CODE
> token in the file
containing the script.  Or, the special filehandle for anything
following the <CODE
CLASS="literal"
>__DATA__</CODE
> token in a required file, as long as
you're reading data in the same package that the <CODE
CLASS="literal"
>__DATA__</CODE
> was
found in.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>_</CODE
> (underline)</DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-8517"
></A
>The special filehandle used to cache the information from the last <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
>,
<A
CLASS="xref"
HREF="ch03_090.htm"
TITLE="lstat"
><B
CLASS="xref.cmd"
>lstat</B
></A
>, or <B
CLASS="emphasis.bold"
>file</B
> test operator.</P
></DD
></DL
><A
CLASS="indexterm"
NAME="AUTOID-8523"
></A
><A
CLASS="indexterm"
NAME="AUTOID-8524"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_08.htm"
TITLE="2.8 Formats"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.8 Formats"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="CHAPTER"
HREF="ch03_01.htm"
TITLE="3. Functions"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 3. Functions"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>2.8 Formats</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>3. Functions</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
