<HTML
><HEAD
>
<TITLE>[Chapter 11] 11.6 Changing Defaults for Formats</TITLE>
<META
NAME="DC.title"
CONTENT="Learning Perl on Win32 Systems"><META
NAME="DC.creator"
CONTENT="Randal L. Schwartz, Erik Olson &amp; Tom Christiansen"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:34:52Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-324-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch11_01.htm"
TITLE="11. Formats"><LINK
REL="prev"
HREF="ch11_05.htm"
TITLE="11.5 The Top-of-Page Format"><LINK
REL="next"
HREF="ch11_07.htm"
TITLE="11.7 The FileHandle Module"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Learning Perl on Win32 Systems"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Learning Perl on Win32 Systems"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/wsrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_05.htm"
TITLE="11.5 The Top-of-Page Format"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.5 The Top-of-Page Format"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch11_01.htm"
TITLE="11. Formats"
>Chapter 11<BR>Formats</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_07.htm"
TITLE="11.7 The FileHandle Module"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.7 The FileHandle Module"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch11-33587"
>11.6 Changing Defaults for Formats</A
></H2
><P
CLASS="para"
>We have often referred to the default for this or that. Well, Perl provides a way to override the defaults for just about every step. Let's talk about these.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-pgfId-948465"
>11.6.1 Using select to Change the Filehandle</A
></H3
><P
CLASS="para"
>Back when we talked about <CODE
CLASS="literal"
>print</CODE
>, in <A
CLASS="xref"
HREF="ch06_01.htm"
TITLE="Basic I/O"
>Chapter 6, <CITE
CLASS="chapter"
>Basic I/O</CITE
></A
>, we mentioned that <CODE
CLASS="literal"
>print</CODE
> and <CODE
CLASS="literal"
>print</CODE
> <CODE
CLASS="literal"
>STDOUT</CODE
> were identical, because <CODE
CLASS="literal"
>STDOUT</CODE
> was the default for <CODE
CLASS="literal"
>print</CODE
>. Not quite. The real default for <CODE
CLASS="literal"
>print</CODE
> (and <CODE
CLASS="literal"
>write</CODE
>, and a few other operations we'll get to in a moment) is an odd notion called the <A
CLASS="indexterm"
NAME="ch11-idx-948304-0"
></A
><EM
CLASS="emphasis"
>currently selected filehandle</EM
>.</P
><P
CLASS="para"
>The currently selected filehandle starts out as <CODE
CLASS="literal"
>STDOUT</CODE
>&nbsp;- which makes it easy to print things on the standard output. However, you can change the currently selected filehandle with the <A
CLASS="indexterm"
NAME="ch11-idx-948303-0"
></A
><CODE
CLASS="literal"
>select</CODE
> function. This function takes a single filehandle (or a scalar variable containing the name of a filehandle) as an argument. After the currently selected filehandle is changed, it affects all future operations that depend on the currently selected filehandle. For example:</P
><PRE
CLASS="programlisting"
>print &quot;hello world\n&quot;;      # like print STDOUT &quot;hello world\n&quot;;
select (LOGFILE);           # select a new filehandle
print &quot;howdy, world\n&quot;;     # like print LOGFILE &quot;howdy, world\n&quot;;
print &quot;more for the log\n&quot;; # more for LOGFILE
select (STDOUT);            # re-select STDOUT
print &quot;back to stdout\n&quot;;   # this goes to standard output</PRE
><P
CLASS="para"
>Note that the <CODE
CLASS="literal"
>select</CODE
> operation is sticky&nbsp;- after you've selected a new handle, it stays in effect until the next <CODE
CLASS="literal"
>select</CODE
>.</P
><P
CLASS="para"
>So, a better definition for <CODE
CLASS="literal"
>STDOUT</CODE
> with respect to <CODE
CLASS="literal"
>print</CODE
> and <CODE
CLASS="literal"
>write</CODE
> is that <CODE
CLASS="literal"
>STDOUT</CODE
> is the default currently selected handle, or the default default handle.</P
><P
CLASS="para"
>Subroutines may find a need to change the currently selected filehandle. However, you would be shocked if you called a subroutine and then found out that all of your carefully crafted text lines were going into some bit bucket because the subroutine changed the currently selected filehandle without restoring it. So what's a well-behaved subroutine to do? If the subroutine knows that the current handle is <CODE
CLASS="literal"
>STDOUT</CODE
>, the subroutine can restore the selected handle with code similar to that given earlier. However, what if the caller of the subroutine had already changed the selected filehandle?</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-948305-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-948305-1"
></A
>return value from <CODE
CLASS="literal"
>select</CODE
> is a string containing the name of the previously selected handle. You can capture this value to restore the previously selected filehandle later, using code like this:</P
><PRE
CLASS="programlisting"
>$oldhandle = select LOGFILE;
print &quot;this goes to LOGFILE\n&quot;;
select ($oldhandle); # restore the previous handle</PRE
><P
CLASS="para"
>Yes, for these examples, putting <CODE
CLASS="literal"
>LOGFILE</CODE
> explicitly as the filehandle for the <CODE
CLASS="literal"
>print</CODE
> is an easier method, but some operations require the currently selected filehandle to change, as we will soon see.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-pgfId-948466"
>11.6.2 Changing the Format Name</A
></H3
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch11-idx-948306-0"
></A
>default format name for a particular filehandle is the same as the filehandle. However, you can change this name for the currently selected filehandle by setting the new format name into a special variable called <A
CLASS="indexterm"
NAME="ch11-idx-948307-0"
></A
><CODE
CLASS="literal"
>$~</CODE
>. You can also examine the value of the variable to see what the current format is for the currently selected filehandle.</P
><P
CLASS="para"
>For example, to use the <CODE
CLASS="literal"
>ADDRESSLABEL</CODE
> format on <CODE
CLASS="literal"
>STDOUT</CODE
>, simply use the following:</P
><PRE
CLASS="programlisting"
>$~ = &quot;ADDRESSLABEL&quot;;</PRE
><P
CLASS="para"
>But what if you want to set the format for the <CODE
CLASS="literal"
>REPORT</CODE
> filehandle to <CODE
CLASS="literal"
>SUMMARY</CODE
>? Just a few steps to do it here:</P
><PRE
CLASS="programlisting"
>$oldhandle = select REPORT;
$~ = &quot;SUMMARY&quot;;
select ($oldhandle);</PRE
><P
CLASS="para"
>The next time we say:</P
><PRE
CLASS="programlisting"
>write (REPORT);</PRE
><P
CLASS="para"
>we get text out on the <CODE
CLASS="literal"
>REPORT</CODE
> filehandle in the <CODE
CLASS="literal"
>SUMMARY</CODE
> format.</P
><P
CLASS="para"
>Note that we saved the previous handle into a scalar variable and then restored it later. This maneuver is good programming practice. In fact, in production code, we probably would have handled the previous one-line example similarly and not assumed that <CODE
CLASS="literal"
>STDOUT</CODE
> was the default handle.</P
><P
CLASS="para"
>By setting the current format for a particular filehandle, you can interleave many different formats in a single report.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-pgfId-948467"
>11.6.3 Changing the Top-of-Page Format Name</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-948309-0"
></A
><A
CLASS="indexterm"
NAME="ch11-idx-948309-1"
></A
>Just as we can change the name of the format for a particular filehandle by setting the <CODE
CLASS="literal"
>$~</CODE
> variable, we can change the top-of-page format by setting the <A
CLASS="indexterm"
NAME="ch11-idx-948308-0"
></A
><CODE
CLASS="literal"
>$^</CODE
> variable. This variable holds the name of the top-of-page format for the currently selected filehandle and is read/write, meaning that you can examine its value to see the current format name, and you can change it by assigning to it.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-pgfId-948468"
>11.6.4 Changing the Page Length</A
></H3
><P
CLASS="para"
>If a top-of-page format is defined, the <A
CLASS="indexterm"
NAME="ch11-idx-948310-0"
></A
>page length becomes important. By default, the page length is 60 lines; that is, when a <CODE
CLASS="literal"
>write</CODE
> won't fit by the end of line 60, the top-of-page format is invoked automatically before printing the text.</P
><P
CLASS="para"
>Sometimes 60 lines isn't right. You can change this by setting the <CODE
CLASS="literal"
>$=</CODE
> variable. This variable holds the current page length for the currently selected filehandle. Once again, to change it for a filehandle other than <CODE
CLASS="literal"
>STDOUT</CODE
> (the default currently selected filehandle), you'll need to use the <CODE
CLASS="literal"
>select()</CODE
> operator. Here's how to change the <CODE
CLASS="literal"
>LOGFILE</CODE
> filehandle to have 30-line pages:</P
><PRE
CLASS="programlisting"
>$old = select LOGFILE; # select LOGFILE and save old handle
$= = 30;
select $old;</PRE
><P
CLASS="para"
>Changing the page length won't have any effect until the next time the top-of-page format is invoked. If you set it before any text is output to a filehandle through a format, it'll work just fine because the top-of-page format is invoked immediately at the first <CODE
CLASS="literal"
>write</CODE
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch11-pgfId-948469"
>11.6.5 Changing the Position on the Page</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch11-idx-948313-0"
></A
>If you <CODE
CLASS="literal"
>print</CODE
> your own text to a filehandle, it messes up the page-position line count because Perl isn't counting lines for anything but a <CODE
CLASS="literal"
>write</CODE
>. If you want to let Perl know that you've output a few extra lines, you can adjust Perl's internal line count by altering the <CODE
CLASS="literal"
>$-</CODE
> variable. This variable contains the number of lines left on the current page on the currently selected filehandle. Each <CODE
CLASS="literal"
>write</CODE
> decrements the lines remaining by the lines actually output. When this count reaches zero, the top-of-page format is invoked, and the value of <A
CLASS="indexterm"
NAME="ch11-idx-948315-0"
></A
><CODE
CLASS="literal"
>$-</CODE
> is then copied from <A
CLASS="indexterm"
NAME="ch11-idx-948314-0"
></A
><CODE
CLASS="literal"
>$=</CODE
> (the page length).</P
><P
CLASS="para"
>For example, to tell Perl that you've sent an extra line to <CODE
CLASS="literal"
>STDOUT</CODE
>, do something like this:</P
><PRE
CLASS="programlisting"
>write; # invoke STDOUT format on STDOUT
...;
print &quot;An extra line... oops!\n&quot;; # this goes to STDOUT
$- --; # decrement $- to indicate non-write line went to STDOUT
...;
write; # this will still work, taking extra line into account</PRE
><P
CLASS="para"
>At the beginning of the program, <CODE
CLASS="literal"
>$-</CODE
> is set to zero for each filehandle. This ensures that the top-of-page format will be the first thing invoked for each filehandle upon the first <CODE
CLASS="literal"
>write</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_05.htm"
TITLE="11.5 The Top-of-Page Format"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 11.5 The Top-of-Page Format"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Learning Perl on Win32 Systems"
><IMG
SRC="../gifs/txthome.gif"
ALT="Learning Perl on Win32 Systems"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch11_07.htm"
TITLE="11.7 The FileHandle Module"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 11.7 The FileHandle Module"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>11.5 The Top-of-Page Format</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>11.7 The FileHandle Module</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="../prog/index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
