<HTML
><HEAD
>
<TITLE>[Chapter 1] 1.2 Natural and Artificial Languages</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:28:46Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. An Overview of Perl"><LINK
REL="prev"
HREF="ch01_01.htm"
TITLE="1.1 Getting Started"><LINK
REL="next"
HREF="ch01_03.htm"
TITLE="1.3 A Grade Example"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_01.htm"
TITLE="1.1 Getting Started"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.1 Getting Started"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. An Overview of Perl"
>Chapter 1<BR>An Overview of Perl</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_03.htm"
TITLE="1.3 A Grade Example"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.3 A Grade Example"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-2"
>1.2 Natural and Artificial Languages</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH01.LANG"
></A
><A
CLASS="indexterm"
NAME="CH01.NAT"
></A
><A
CLASS="indexterm"
NAME="CH01.ART"
></A
>Languages were first invented by humans, for the benefit of humans.  In
the annals of computer science, this fact has occasionally been forgotten.[<A
CLASS="footnote"
HREF="#AUTOID-407"
>3</A
>]
Since Perl was designed (loosely speaking) by an occasional linguist, it
was designed to work smoothly in the same ways that natural language
works smoothly.  Naturally, there are many aspects to this, since natural
language works well at many levels simultaneously.  We could enumerate
many of these linguistic principles here, but the most important
principle of language design is simply that easy things should be easy,
and hard things should be possible.  That may seem obvious, but many
computer languages fail at one or the other.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-407"
>[3]</A
> More precisely, this fact has occasionally been remembered.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Natural languages are good at both because people are continually trying
to express both easy things and hard things, so the language evolves to
handle both.  Perl was designed first of all to evolve, and indeed it
has evolved.  Many people have contributed to the evolution of Perl over
the years.  We often joke that a camel is a horse designed by a
committee, but if you think about it, the camel is pretty well adapted
for life in the desert.  The camel has evolved to be relatively
self-sufficient.[<A
CLASS="footnote"
HREF="#AUTOID-410"
>4</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-410"
>[4]</A
> On the other hand, the camel has not evolved to smell good.  Neither has Perl.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Now when someone utters the word &quot;linguistics&quot;, many people think of one
of two things.  Either they think of words, or they think of sentences.
But words and sentences are just two handy ways to &quot;chunk&quot; speech.
Either may be broken down into smaller units of meaning, or combined
into larger units of meaning.  And the meaning of any unit depends
heavily on the syntactic, semantic, and pragmatic context in which the
unit is located.  Natural language has words of various sorts, nouns and
verbs and such.  If I say &quot;dog&quot; in isolation, you think of it as a noun,
but I can also use the word in other ways.  That is, a noun can
function as a verb, an adjective or an adverb when the context
demands it.  If you dog a dog during the dog days of summer, you'll be a dog
tired dogcatcher.[<A
CLASS="footnote"
HREF="#AUTOID-413"
>5</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-413"
>[5]</A
> And you're probably dog tired of all this linguistics claptrap.
But we'd like you to understand why Perl is different from the typical
computer language, doggone it!</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Perl also evaluates words differently in various contexts.  We will see how
it does that later.  Just remember that Perl is trying to understand what
you're saying, like any good listener does.  Perl works pretty hard to try to
keep up its end of the bargain.  Just say what you mean, and Perl will
usually &quot;get it&quot;.  (Unless you're talking nonsense, of course&nbsp;- the Perl
parser understands Perl a lot better than either English or Swahili.)</P
><P
CLASS="para"
>But back to nouns.  A noun can name a particular object, or it can name a
class of objects generically without specifying which one or ones are
currently being referred to.  Most computer languages make this
distinction, only we call the particular thing a value and the generic one
a variable.  A value
just exists somewhere, who knows where, but a variable gets associated
with one or more values over its lifetime.  So whoever is interpreting
the variable has to keep track of that association.  That interpreter may
be in your brain, or in your computer.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-2.1"
>1.2.1 Nouns</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH01.NOUNS"
></A
><A
CLASS="indexterm"
NAME="CH01.VAR"
></A
><A
CLASS="indexterm"
NAME="CH01.NV"
></A
>A variable is just a handy place to keep something, a place with a
name, so you know where to find your special something when you come
back looking for it later.  As in real life, there are various kinds of
places to store things, some of them rather private, and some of them
out in public.  Some places are temporary, and other places are more
permanent.  Computer scientists love to talk about the &quot;scope&quot; of
variables, but that's all they mean by it.  Perl has various handy
ways of dealing with scoping issues, which you'll be happy to learn
later when the time is right.  Which is not yet.  (Look up the adjectives
&quot;local&quot; and &quot;my&quot; in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3, <CITE
CLASS="chapter"
>Functions</CITE
></A
>, when you get curious.)</P
><P
CLASS="para"
>But a more immediately useful way of classifying variables is by what
sort of data they can hold.  As in English, Perl's primary type
distinction is between singular and plural data.  Strings and numbers are
singular pieces of data, while lists of strings or numbers are plural.
(And when we get to object-oriented programming, you'll find that an
object looks singular from the outside, but may look plural from the
inside, like a class of students.)  We call a singular variable a
<EM
CLASS="emphasis"
>scalar</EM
>, and a plural variable an <EM
CLASS="emphasis"
>array</EM
>.  Since a string can be
stored in a scalar variable, we might write a slightly longer (and
commented) version of our first example like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$phrase = &quot;Howdy, world!\n&quot;;          # Set a variable.
print $phrase;                        # Print the variable.</PRE
></P
><P
CLASS="para"
>Note that we did not have to predefine what kind of variable
<CODE
CLASS="literal"
>$phrase</CODE
> is.  The <CODE
CLASS="literal"
>$</CODE
> character
tells Perl that <CODE
CLASS="literal"
>phrase</CODE
> is a scalar variable, that
is, one containing a singular value.  An array variable, by contrast,
would start with an <CODE
CLASS="literal"
>@</CODE
> character.  (It may help you
to remember that a <CODE
CLASS="literal"
>$</CODE
> is a stylized &quot;S&quot;, for &quot;scalar&quot;,
while <CODE
CLASS="literal"
>@</CODE
> is a stylized &quot;a&quot;, for &quot;array&quot;.)</P
><P
CLASS="para"
>Perl has some other variable types, with unlikely names like &quot;hash&quot;,
&quot;handle&quot;, and &quot;typeglob&quot;.  Like scalars and arrays, these types of
variables are also preceded by funny characters.[<A
CLASS="footnote"
HREF="#AUTOID-442"
>6</A
>]
For completeness, <A
CLASS="xref"
HREF="ch01_02.htm#PERL2-CH-1-TAB-1"
TITLE="Variable Syntax"
>Table 1.1</A
> lists all the funny characters you'll encounter.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-442"
>[6]</A
> Some language purists point to these funny characters as a reason to
abhor Perl.  This is superficial.  These characters have many benefits:
Variables can be interpolated into strings with no additional syntax.
Perl scripts are easy to read (for people who have bothered to learn
Perl!) because the nouns stand out from verbs, and new verbs can be added
to the language without breaking old scripts.  (We told you Perl was
designed to evolve.)  And the noun analogy is not frivolous&nbsp;- there is
ample precedent in various natural languages for requiring grammatical
noun markers.  It's how we think!  (We think.)</P
></DIV
></BLOCKQUOTE
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="PERL2-CH-1-TAB-1"
>Table 1.1: Variable Syntax</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Type</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Character</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Is a name for:</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Scalar</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$cents</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An individual value (number or string)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Array</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@large</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A list of values, keyed by number</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Hash</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>%</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>%interest</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A group of values, keyed by string</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Subroutine</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;how</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A callable chunk of Perl code</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Typeglob</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*struck</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Everything named <CODE
CLASS="literal"
>struck</CODE
></TD
></TR
></TBODY
></TABLE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-2.1.1"
>1.2.1.1 Singularities</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-494"
></A
><A
CLASS="indexterm"
NAME="AUTOID-496"
></A
>From our example, you can see that scalars may be assigned a new value with
the <CODE
CLASS="literal"
>=</CODE
> operator, just as in many other computer languages.
Scalar variables can be assigned
any form of scalar value: integers, floating-point numbers, strings, and
even esoteric things like references to other variables, or to objects.
There are many ways of generating these values for assignment.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-501"
></A
><A
CLASS="indexterm"
NAME="AUTOID-504"
></A
>As in the UNIX
shell, you can use different quoting mechanisms to make different kinds
of values.  Double quotation marks (double quotes) do variable interpolation[<A
CLASS="footnote"
HREF="#AUTOID-507"
>7</A
>]
and backslash interpretation,[<A
CLASS="footnote"
HREF="#AUTOID-509"
>8</A
>]
while single quotes suppress both interpolation and interpretation.  And
backquotes (the ones leaning to the left) will execute an external
program and return the output of the program, so you can capture it as
a single string containing all the lines of output.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-507"
>[7]</A
> Sometimes called &quot;substitution&quot; by shell programmers, but we prefer to
reserve that word for something else in Perl.  So please call it
interpolation.  We're using the term in the textual sense (&quot;this passage
is a Gnostic interpolation&quot;) rather than in the mathematical sense
(&quot;this point on the graph is an interpolation between two other
points&quot;).</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-509"
>[8]</A
> Such as turning <CODE
CLASS="literal"
>\t</CODE
> into a tab, <CODE
CLASS="literal"
>\n</CODE
> into a newline,
<CODE
CLASS="literal"
>\001</CODE
> into a CTRL-A,
and so on, in the tradition of many UNIX programs.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$answer = 42;               # an integer
$pi = 3.14159265;           # a &quot;real&quot; number
$avocados = 6.02e23;        # scientific notation
$pet = &quot;Camel&quot;;             # string
$sign = &quot;I love my $pet&quot;;   # string with interpolation
$cost = 'It costs $100';    # string without interpolation
$thence = $whence;          # another variable
$x = $moles * $avocados;    # an expression
$cwd = `pwd`;               # string output from a command
$exit = system(&quot;vi $x&quot;);    # numeric status of a command
$fido = new Camel &quot;Fido&quot;;   # an object</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-517"
></A
>Uninitialized variables automatically spring into existence as needed.
Following the principle of least surprise, they are created with a null
value, either <CODE
CLASS="literal"
>&quot;&quot;</CODE
> or <CODE
CLASS="literal"
>0</CODE
>.  Depending on where you use them, variables
will be interpreted automatically as strings, as numbers, or as &quot;true&quot;
and &quot;false&quot; values (commonly called Boolean values).  Various operators
expect certain kinds of values as parameters, so we will speak of those
operators as &quot;providing&quot; or &quot;supplying&quot; a scalar context to those parameters.
Sometimes we'll be more specific, and say it supplies a numeric context,
a string context, or a Boolean context to those parameters.  (Later
we'll also talk about list context, which is the opposite of scalar
context.)  Perl will automatically convert the data into the form
required by the current context, within reason.  For example, suppose
you said this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$camels = '123';
print $camels + 1, &quot;\n&quot;;</PRE
></P
><P
CLASS="para"
>The original value of <CODE
CLASS="literal"
>$camels</CODE
> is a string, but it is converted to a
number to add <CODE
CLASS="literal"
>1</CODE
> to it, and then converted back to a string to be
printed out as <CODE
CLASS="literal"
>124</CODE
>.  The newline, represented by <CODE
CLASS="literal"
>&quot;\n&quot;</CODE
>, is also
in string context, but since it's already a string, no conversion is
necessary.  But notice that we had to use double quotes there&nbsp;- using
single quotes to say <CODE
CLASS="literal"
>'\n'</CODE
> would result in a two-character string
consisting of a backslash followed by an &quot;<CODE
CLASS="literal"
>n</CODE
>&quot;, which is not a newline by
anybody's definition.</P
><P
CLASS="para"
>So, in a sense, double quotes and single quotes are yet another way of
specifying context.  The interpretation of the innards of a quoted
string depends on which quotes you use.  Later we'll see some other
operators that work like quotes syntactically, but use the string in
some special way, such as for pattern matching or substitution.  These
all work like double-quoted strings too.  The <EM
CLASS="emphasis"
>double-quote</EM
> context is
the &quot;interpolative&quot; context of Perl, and is supplied by many operators
that don't happen to resemble double quotes.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-2.1.2"
>1.2.1.2 Pluralities</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-535"
></A
><A
CLASS="indexterm"
NAME="AUTOID-538"
></A
><A
CLASS="indexterm"
NAME="AUTOID-540"
></A
><A
CLASS="indexterm"
NAME="AUTOID-542"
></A
>Some kinds of variables hold multiple values that are logically tied
together.  Perl has two types of multivalued variables: arrays and
hashes.  In many ways these behave like scalars.  They spring into
existence with nothing in them when needed.  When you assign to them,
they supply a <EM
CLASS="emphasis"
>list</EM
> context to the right side of the assignment.</P
><P
CLASS="para"
>You'd use an array when you want to look something up by number.  You'd
use a hash when you want to look something up by name.  The two concepts
are complementary.  You'll often see people using an array to translate
month numbers into month names, and a corresponding hash to translate
month names back into month numbers.  (Though hashes aren't limited to
holding only numbers.  You could have a hash that translates
month names to birthstone names, for instance.)</P
>Arrays.<P
CLASS="para"
>An <EM
CLASS="emphasis"
>array</EM
> is an ordered list of scalars, accessed[<A
CLASS="footnote"
HREF="#AUTOID-552"
>9</A
>]
by the scalar's position in the list.  The list may contain numbers, or
strings, or a mixture of both.  (In fact, it could also contain
references to other lists, but we'll get to that in <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4, <CITE
CLASS="chapter"
>References and Nested Data Structures</CITE
></A
>, when we're
discussing multidimensional arrays.)  To assign a list value to an
array, you simply group the variables together (with a set of
parentheses):</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-552"
>[9]</A
> Or keyed, or indexed, or subscripted, or looked up.  Take your pick.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@home = (&quot;couch&quot;, &quot;chair&quot;, &quot;table&quot;, &quot;stove&quot;);</PRE
></P
><P
CLASS="para"
>Conversely, if you use <CODE
CLASS="literal"
>@home</CODE
> in a list context, such as on the right
side of a list assignment, you get back out the same list you put in.
So you could set four scalar variables from the array like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($potato, $lift, $tennis, $pipe) = @home;</PRE
></P
><P
CLASS="para"
>These are called list assignments.  They logically happen in parallel,
so you can swap two variables by saying:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($alpha,$omega) = ($omega,$alpha);</PRE
></P
><P
CLASS="para"
>As in C, arrays are zero-based, so while you would talk about the
first through fourth elements of the array, you would get to them with
subscripts 0 through 3.[<A
CLASS="footnote"
HREF="#AUTOID-565"
>10</A
>]
Array subscripts are enclosed in square brackets [like this], so if
you want to select an individual array element, you would refer to it
as
<CODE
CLASS="literal"
>$home[</CODE
><EM
CLASS="emphasis"
>n</EM
><CODE
CLASS="literal"
>]</CODE
>,
where <EM
CLASS="emphasis"
>n</EM
> is the subscript (one less than the
element number) you want.  See the example below.  Since the element
you are dealing with is a scalar, you always precede it with a
<CODE
CLASS="literal"
>$</CODE
>.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-565"
>[10]</A
> If this seems odd to you, just think of the subscript as an offset, that
is, the count of how many array elements come before it.  Obviously, the
first element doesn't have any elements before it, and so has an offset
of 0.  This is how computers think.  (We think.)</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>If you want to assign to one array element at a time, you could write the
earlier assignment as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$home[0] = &quot;couch&quot;;
$home[1] = &quot;chair&quot;;
$home[2] = &quot;table&quot;;
$home[3] = &quot;stove&quot;;</PRE
></P
><P
CLASS="para"
>Since arrays are ordered, there are various useful operations that you
can do on them, such as the stack operations, <A
CLASS="xref"
HREF="ch03_112.htm"
TITLE="push"
><B
CLASS="xref.cmd"
>push</B
></A
> and <A
CLASS="xref"
HREF="ch03_108.htm"
TITLE="pop"
><B
CLASS="xref.cmd"
>pop</B
></A
>.  A
stack is, after all, just an ordered list, with a beginning and an
end.  Especially an end.  Perl regards the end of your list as the top
of a stack.  (Although most Perl programmers think of a list as
horizontal, with the top of the stack on the right.)</P
>Hashes.<P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-581"
></A
><A
CLASS="indexterm"
NAME="AUTOID-584"
></A
><A
CLASS="indexterm"
NAME="AUTOID-586"
></A
>A <EM
CLASS="emphasis"
>hash</EM
> is an unordered set of scalars, accessed[<A
CLASS="footnote"
HREF="#AUTOID-591"
>11</A
>]
by some string value that is associated with each scalar.  For this
reason hashes are often called &quot;associative arrays&quot;.  But that's too long
for lazy typists to type, and we talk about them so often that we decided
to name them something short and snappy.[<A
CLASS="footnote"
HREF="#AUTOID-593"
>12</A
>]
The other reason we picked the name &quot;hash&quot; is to emphasize the fact that
they're disordered.  (They are, coincidentally, implemented internally
using a hash-table lookup, which is why hashes are so fast, and stay so
fast no matter how many values you put into them.)  You can't <A
CLASS="xref"
HREF="ch03_112.htm"
TITLE="push"
><B
CLASS="xref.cmd"
>push</B
></A
> or
<A
CLASS="xref"
HREF="ch03_108.htm"
TITLE="pop"
><B
CLASS="xref.cmd"
>pop</B
></A
> a hash though, because it doesn't make sense.  A hash has no
beginning or end.  Nevertheless, hashes are extremely powerful and
useful.  Until you start thinking in terms of hashes, you aren't really
thinking in Perl.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-591"
>[11]</A
> Or keyed, or indexed, or subscripted, or looked up.  Take your pick.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-593"
>[12]</A
> Presuming for the moment that we can classify <EM
CLASS="emphasis"
>any</EM
> sort of hash as
&quot;snappy&quot;.  Please pass the Tabasco.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Since the keys to a hash are not automatically implied by their position,
you must supply the key as well as the value when populating a hash.
You can still assign a list to it like an ordinary array, but each
pair of items in the list will be interpreted as a key/value pair.
Suppose you wanted to translate abbreviated day names to the corresponding
full names.  You could write the following list assignment.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>%longday = (&quot;Sun&quot;, &quot;Sunday&quot;, &quot;Mon&quot;, &quot;Monday&quot;, &quot;Tue&quot;, &quot;Tuesday&quot;,
            &quot;Wed&quot;, &quot;Wednesday&quot;, &quot;Thu&quot;, &quot;Thursday&quot;, &quot;Fri&quot;,
            &quot;Friday&quot;, &quot;Sat&quot;, &quot;Saturday&quot;);</PRE
></P
><P
CLASS="para"
>Because it is sometimes difficult to read a hash that is defined like
this, Perl provides the <CODE
CLASS="literal"
>=&gt;</CODE
> (equal sign, greater than) sequence as
an alternative separator to the comma.  Using this syntax (and
some creative formatting), it is easier to see which strings are the
keys, and which strings are the associated values.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>%longday = (
    &quot;Sun&quot; =&gt; &quot;Sunday&quot;,
    &quot;Mon&quot; =&gt; &quot;Monday&quot;,
    &quot;Tue&quot; =&gt; &quot;Tuesday&quot;,
    &quot;Wed&quot; =&gt; &quot;Wednesday&quot;,
    &quot;Thu&quot; =&gt; &quot;Thursday&quot;,
    &quot;Fri&quot; =&gt; &quot;Friday&quot;,
    &quot;Sat&quot; =&gt; &quot;Saturday&quot;,
);</PRE
></P
><P
CLASS="para"
>Not only can you assign a list to a hash, as we did above, but if you use
a hash in list context, it'll convert the hash back to a list of key/value
pairs, in a weird order.  This is occasionally useful.  More often people
extract a list of just the keys, using the (aptly named) <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
> function.
The key list is also unordered, but can easily be sorted if desired, using
the (aptly named) <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> function.  More on that later.</P
><P
CLASS="para"
>Because hashes are a fancy kind of array, you select an individual hash
element by enclosing the key in braces.
So, for example, if you want to find out the value associated
with <CODE
CLASS="literal"
>Wed</CODE
> in the hash above, you would use <CODE
CLASS="literal"
>$longday{&quot;Wed&quot;}</CODE
>.  Note
again that you are dealing with a scalar value, so you use <CODE
CLASS="literal"
>$</CODE
>, not <CODE
CLASS="literal"
>%</CODE
>.</P
><P
CLASS="para"
>Linguistically, the relationship encoded in a hash is genitive
or possessive, like the word &quot;of&quot; in English, or like &quot;'s&quot;.  The wife
<EM
CLASS="emphasis"
>of</EM
> Adam is Eve, so we write:<A
CLASS="indexterm"
NAME="AUTOID-615"
></A
><A
CLASS="indexterm"
NAME="AUTOID-616"
></A
><A
CLASS="indexterm"
NAME="AUTOID-617"
></A
></P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$wife{&quot;Adam&quot;} = &quot;Eve&quot;;</PRE
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-1-SECT-2.2"
>1.2.2 Verbs</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-623"
></A
><A
CLASS="indexterm"
NAME="AUTOID-625"
></A
><A
CLASS="indexterm"
NAME="AUTOID-627"
></A
><A
CLASS="indexterm"
NAME="AUTOID-630"
></A
>As is typical of your typical imperative computer language, many of the
verbs in Perl are commands: they tell the Perl interpreter to do
something.  On the other hand, as is typical of a natural language, the
meanings of Perl verbs tend to mush off in various directions, depending
on the context.  A statement starting with a verb is generally purely
imperative, and evaluated entirely for its side effects.  We often call
these verbs <EM
CLASS="emphasis"
>procedures</EM
>, especially when they're user-defined.  A frequently
seen command (in fact, you've seen it already) is the <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> command:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print &quot;Adam's wife is &quot;, $wife{'Adam'}, &quot;.\n&quot;;</PRE
></P
><P
CLASS="para"
>This has the side effect of producing the desired output.</P
><P
CLASS="para"
>But there are other &quot;moods&quot; besides the imperative mood.  Some verbs are
for asking questions, and are useful in conditional statements.  Other
verbs translate their input parameters into return values, just as a
recipe tells you how to turn raw ingredients into something (hopefully)
edible.  We tend to call these verbs <EM
CLASS="emphasis"
>functions</EM
>, in deference to generations
of mathematicians who don't know what the word &quot;functional&quot; means in
natural language.<A
CLASS="indexterm"
NAME="AUTOID-640"
></A
><A
CLASS="indexterm"
NAME="AUTOID-642"
></A
></P
><P
CLASS="para"
>An example of a built-in function would be the exponential function:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$e = exp(1);   # 2.718281828459, or thereabouts</PRE
></P
><P
CLASS="para"
>But Perl doesn't make a hard distinction between procedures and
functions.  You'll find the terms used interchangeably.  Verbs are also
sometimes called subroutines (when user-defined) or operators (when
built-in).  But call them whatever you like&nbsp;- they all return a value,
which may or may not be a meaningful value, which you may or may not
choose to ignore.</P
><P
CLASS="para"
>As we go on, you'll see additional examples of how Perl behaves like a
natural language.  But there are other ways to look at Perl too.  We've
already sneakily introduced some notions from mathematical language,
such as addition and subscripting, not to mention the exponential
function.  But Perl is also a control language, a glue language, a
prototyping language, a text-processing language, a list-processing
language, and an object-oriented language.  Among other things.</P
><P
CLASS="para"
>But Perl is also just a plain old computer language.  And that's how
we'll look at it next.<A
CLASS="indexterm"
NAME="AUTOID-651"
></A
><A
CLASS="indexterm"
NAME="AUTOID-652"
></A
><A
CLASS="indexterm"
NAME="AUTOID-653"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_01.htm"
TITLE="1.1 Getting Started"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.1 Getting Started"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch01_03.htm"
TITLE="1.3 A Grade Example"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.3 A Grade Example"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.1 Getting Started</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.3 A Grade Example</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
