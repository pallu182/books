<HTML
><HEAD
>
<TITLE>[Chapter 8] 8.4 Programming with Style</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T02:07:26Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Other Oddments"><LINK
REL="prev"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"><LINK
REL="next"
HREF="ch08_05.htm"
TITLE="8.5 Distribution and Installation"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.3 Efficiency"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch08_01.htm"
TITLE="8. Other Oddments"
>Chapter 8<BR>Other Oddments</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_05.htm"
TITLE="8.5 Distribution and Installation"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.5 Distribution and Installation"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-4"
>8.4 Programming with Style</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.STYLE1"
></A
><A
CLASS="indexterm"
NAME="CH08.STYLE2"
></A
><A
CLASS="indexterm"
NAME="CH08.STYLE3"
></A
>Each programmer will, of course, have his or her own preferences in regards to
formatting, but there are some general guidelines that will make your
programs easier to read, understand, and maintain.</P
><P
CLASS="para"
>The most important thing is to run your programs under the <B
CLASS="emphasis.bold"
>-w</B
> flag at all times.  You may turn it off explicitly
for particular portions of code via the <B
CLASS="emphasis.bold"
>$^W</B
>
variable if you must.  You should also always run under <CODE
CLASS="literal"
>use
strict</CODE
> or know the reason why not.  The <CODE
CLASS="literal"
>use sigtrap</CODE
>
and even the <CODE
CLASS="literal"
>use diagnostics</CODE
> pragmas may also prove of
benefit.</P
><P
CLASS="para"
>Regarding aesthetics of code layout, about the only thing Larry cares strongly
about is that the closing brace of a multi-line <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>
should line up in the same column as the start of the keyword that started the
construct.  Beyond that, he has other preferences that aren't so strong.
Examples in this book (should) all follow these coding conventions.</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Four-column indent.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29943"
></A
>An opening brace should be put on the same line as its preceding
keyword, if possible; otherwise, line them up vertically.</P
><PRE
CLASS="programlisting"
>while ($condition) {	# for short ones, align with keywords
    # do something
} 

# if the condition wraps, line up the braces with each other
while ($this_condition and $that_condition
       and $this_other_long_condition) 
{
    # do something
}</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put space before the opening brace of a multi-line <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>.<A
CLASS="indexterm"
NAME="AUTOID-29950"
></A
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A one-line <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
> may be put on one line, including braces.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not put space before a semicolon.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Omit the semicolon in a short, one-line <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Surround most operators with space.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Surround a &quot;complex&quot; subscript (inside brackets) with space.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put blank lines between chunks of code that do different things.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put a newline between a closing brace and <B
CLASS="emphasis.bold"
>else</B
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Do not put space between a function name instance and its opening parenthesis.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Put space after each comma.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Break long lines after an operator (but before <B
CLASS="emphasis.bold"
>and</B
> and <B
CLASS="emphasis.bold"
>or</B
>).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Line up corresponding items vertically.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Omit redundant punctuation as long as clarity doesn't suffer.</P
></LI
></UL
><P
CLASS="para"
>Larry has his reasons for each of these things, but he doesn't claim that
everyone else's mind works the same as his does.</P
><P
CLASS="para"
>Here are some other, more substantive style issues to think about:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Just because you <EM
CLASS="emphasis"
>can</EM
> do something a particular way doesn't mean
you <EM
CLASS="emphasis"
>should</EM
> do it that way.  Perl is designed to give you several
ways to do anything, so consider picking the most readable one.  For
instance:</P
><PRE
CLASS="programlisting"
>open(FOO,$foo) || die &quot;Can't open $foo: $!&quot;;</PRE
><P
CLASS="para"
>is better than:</P
><PRE
CLASS="programlisting"
>die &quot;Can't open $foo: $!&quot; unless open(FOO,$foo);</PRE
><P
CLASS="para"
>because the second way hides the main point of the statement in a
modifier.  On the other hand</P
><PRE
CLASS="programlisting"
>print &quot;Starting analysis\n&quot; if $verbose;</PRE
><P
CLASS="para"
>is better than:</P
><PRE
CLASS="programlisting"
>$verbose &amp;&amp; print &quot;Starting analysis\n&quot;;</PRE
><P
CLASS="para"
>since the main point isn't whether the user typed <B
CLASS="emphasis.bold"
>-v</B
> or not.</P
><P
CLASS="para"
>Similarly, just because an operator lets you assume default arguments doesn't
mean that you have to make use of the defaults.  The defaults are there for lazy
systems programmers writing one-shot programs.  If you want your program to be
readable, consider supplying the argument.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29999"
></A
>Along the same lines, just because you <EM
CLASS="emphasis"
>can</EM
> omit parentheses in many
places doesn't mean that you ought to:</P
><PRE
CLASS="programlisting"
>return print reverse sort num values %array;
return print(reverse(sort num (values(%array))));</PRE
><P
CLASS="para"
>When in doubt, parenthesize.  At the very least it will let some poor
schmuck bounce on the % key in <EM
CLASS="emphasis"
>vi</EM
>.</P
><P
CLASS="para"
>Even if <EM
CLASS="emphasis"
>you</EM
> aren't in doubt, consider the mental welfare of the person
who has to maintain the code after you, and who will probably put
parentheses in the wrong place.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30009"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30011"
></A
>Don't go through silly contortions to exit a loop at the top or
the bottom.  Perl provides the <A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
> operator
so you can exit in the middle.  Just &quot;outdent&quot; it to make it more visible:</P
><PRE
CLASS="programlisting"
>LINE:
    for (;;) {
        statements;
      last LINE if $foo;
        next LINE if /^#/;
        statements;
    }</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30018"
></A
>Don't be afraid to use loop labels&nbsp;- they're there to enhance
readability as well as to allow multi-level loop breaks.  See the example just given.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-30023"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30025"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30027"
></A
>
Avoid using <A
CLASS="xref"
HREF="ch03_072.htm"
TITLE="grep"
><B
CLASS="xref.cmd"
>grep</B
></A
>,
<A
CLASS="xref"
HREF="ch03_091.htm"
TITLE="map"
><B
CLASS="xref.cmd"
>map</B
></A
>, or backticks in a void context;
that is, when you just throw away their return values.  Those
functions all have return values, so use them.  Otherwise, use a
<B
CLASS="emphasis.bold"
>foreach</B
> loop or the <A
CLASS="xref"
HREF="ch03_167.htm"
TITLE="system"
><B
CLASS="xref.cmd"
>system</B
></A
> function.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> 
For portability, when using features that may not be
implemented on every machine, test the construct in an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> to see whether it fails.  If you know the
version or patchlevel of a particular feature, you can test <B
CLASS="emphasis.bold"
>$]</B
> (<CODE
CLASS="literal"
>$PERL_VERSION</CODE
> in the
English module) to see whether the feature is there.  The Config
module will also let you interrogate values determined by the
<EM
CLASS="emphasis"
>Configure</EM
> program when Perl was installed.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Choose mnemonic identifiers.  If you can't remember what mnemonic means,
you've got a problem.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30044"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30047"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30050"
></A
>While short identifiers like <CODE
CLASS="literal"
>$gotit</CODE
> are
probably OK, use underscores to separate words.  It is generally much easier to read
<CODE
CLASS="literal"
>$var_names_like_this</CODE
> than
<CODE
CLASS="literal"
>$VarNamesLikeThis</CODE
>, especially for non-native speakers of
English.  Besides, the same rule works for <CODE
CLASS="literal"
>$VAR_NAMES_LIKE_THIS</CODE
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30058"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30061"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30064"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30067"
></A
>Package names are sometimes an exception to this rule.  Perl informally
reserves lowercase module names for pragmatic modules like <CODE
CLASS="literal"
>integer</CODE
> and
<CODE
CLASS="literal"
>strict</CODE
>.  Other modules should begin with a capital letter and use mixed
case, but probably without underscores due to name-length limitations of
some primitive filesystems.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You may find it helpful to use letter case to indicate the scope 
or nature of a variable. For example:</P
><PRE
CLASS="programlisting"
>$ALL_CAPS_HERE   # constants only (beware clashes with Perl vars!)  
$Some_Caps_Here  # package-wide global/static 
$no_caps_here    # function scope my() or local() variables</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30076"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30079"
></A
>Function and method names seem to work best as all lowercase. 
For example, <CODE
CLASS="literal"
>$obj-&gt;as_string()</CODE
>. </P
><P
CLASS="para"
>You can use a leading underscore to indicate that a variable or
function should not be used outside the package that defined it.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>If you have a really hairy regular expression, use the <B
CLASS="emphasis.bold"
>/x</B
> modifier and put in some whitespace to make it look a
little less like line noise.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Don't use slash as a delimiter when your regexp has slashes or backslashes.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Don't use quotes as a delimiter when your string contains that same
quote.  Use the <CODE
CLASS="literal"
>q//</CODE
>, <CODE
CLASS="literal"
>qq//</CODE
>, or
<CODE
CLASS="literal"
>qx//</CODE
> pseudofunctions instead.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30096"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30098"
></A
>Use the <B
CLASS="emphasis.bold"
>and</B
> and <B
CLASS="emphasis.bold"
>or</B
> operators to avoid having to parenthesize list
operators so much, and to reduce the incidence of punctuational
operators like <CODE
CLASS="literal"
>&amp;&amp;</CODE
> and
<CODE
CLASS="literal"
>||</CODE
>.  Call your subroutines as if they were
functions or list operators to avoid excessive ampersands and
parentheses.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Use &quot;here&quot; documents instead of repeated <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> statements.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Line up corresponding things vertically, especially if they're too long
to fit on one line anyway.</P
><PRE
CLASS="programlisting"
>$IDX = $ST_MTIME;       
$IDX = $ST_ATIME       if $opt_u; 
$IDX = $ST_CTIME       if $opt_c;     
$IDX = $ST_SIZE        if $opt_s;

mkdir $tmpdir, 0700 or die &quot;can't mkdir $tmpdir: $!&quot;;
chdir($tmpdir)      or die &quot;can't chdir $tmpdir: $!&quot;;
mkdir 'tmp',   0777 or die &quot;can't mkdir $tmpdir/tmp: $!&quot;;</PRE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>That which I tell you three times is true:</P
><TABLE
CLASS="simplelist"
BORDER="0"
><TR
><TD
CLASS="member"
>Always check the return codes of system calls.  </TD
></TR
><TR
><TD
CLASS="member"
><EM
CLASS="emphasis"
>Always check the return codes of system calls.</EM
></TD
></TR
><TR
><TD
CLASS="member"
><EM
CLASS="emphasis"
>ALWAYS CHECK THE RETURN CODES OF SYSTEM CALLS!</EM
></TD
></TR
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30119"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30121"
></A
>Error messages should go to <CODE
CLASS="literal"
>STDERR</CODE
>, and should say which program
caused the problem and what the failed system call and arguments were.
Most importantly, they should contain the standard system error message for
what went wrong.  Here's a simple but sufficient example:</P
><PRE
CLASS="programlisting"
>opendir(D, $dir)     or die &quot;can't opendir $dir: $!&quot;;</PRE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Line up your translations when it makes sense:</P
><PRE
CLASS="programlisting"
>tr [abc]
   [xyz];</PRE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-30130"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30133"
></A
>
Think about reusability.  Why waste brainpower on a
one-shot script when you might want to do something like it again?
Consider generalizing your code.  Consider writing a module or object
class.  Consider making your code run cleanly with <CODE
CLASS="literal"
>use
strict</CODE
> and <B
CLASS="emphasis.bold"
>-w</B
> in effect.
Consider giving away your code.  Consider changing your whole world
view.  Consider ... oh, never mind.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Be consistent.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Be nice.</P
></LI
></UL
><A
CLASS="indexterm"
NAME="AUTOID-30141"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30142"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30143"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.3 Efficiency"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_05.htm"
TITLE="8.5 Distribution and Installation"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.5 Distribution and Installation"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.3 Efficiency</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.5 Distribution and Installation</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
