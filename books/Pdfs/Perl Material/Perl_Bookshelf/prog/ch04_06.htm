<HTML
><HEAD
>
<TITLE>[Chapter 4] 4.6 A Brief Tutorial:  Manipulating Lists of Lists</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:57:45Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch04_01.htm"
TITLE="4. References and Nested Data Structures"><LINK
REL="prev"
HREF="ch04_05.htm"
TITLE="4.5 Braces, Brackets, and Quoting"><LINK
REL="next"
HREF="ch04_07.htm"
TITLE="4.7 Data Structure Code Examples"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Braces, Brackets, and Quoting"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.5 Braces, Brackets, and Quoting"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch04_01.htm"
TITLE="4. References and Nested Data Structures"
>Chapter 4<BR>References and Nested Data Structures</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_07.htm"
TITLE="4.7 Data Structure Code Examples"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.7 Data Structure Code Examples"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-6"
>4.6 A Brief Tutorial:  Manipulating Lists of Lists</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH04.TUT1"
></A
><A
CLASS="indexterm"
NAME="CH04.TUT2"
></A
><A
CLASS="indexterm"
NAME="CH04.TUT3"
></A
><A
CLASS="indexterm"
NAME="CH04.TUT4"
></A
><A
CLASS="indexterm"
NAME="CH04.TUT5"
></A
>There are many kinds of nested data structures.
The simplest kind to build is a list of lists (also called an array
of arrays, or a multi-dimensional array).  It's reasonably easy to
understand, and almost everything that applies here will also be applicable
to the fancier data structures.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-6.1"
>4.6.1 Composition and Access</A
></H3
><P
CLASS="para"
>Here's how to put together a two-dimensional array value:</P
><PRE
CLASS="programlisting"
># assign to an array a list of list references
@LoL = ( 
       [ &quot;fred&quot;, &quot;barney&quot; ],
       [ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot; ],
       [ &quot;homer&quot;, &quot;marge&quot;, &quot;bart&quot; ],
);

print $LoL[2][2];   # prints &quot;bart&quot;</PRE
><P
CLASS="para"
>The overall list is enclosed by parentheses, not brackets.
That's because you're assigning a list to an array.  If you didn't want
the result to be a list, but rather a reference to an array, then you
would use brackets on the outside:</P
><PRE
CLASS="programlisting"
># assign to a scalar variable a reference to a list of list references
$ref_to_LoL = [
    [ &quot;fred&quot;, &quot;barney&quot;, &quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;, ],
    [ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;, &quot;maggie&quot;, ],
    [ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],
];

print $ref_to_LoL-&gt;[2][2];   # prints &quot;elroy&quot;</PRE
><P
CLASS="para"
><CODE
CLASS="literal"
>$ref_to_LoL</CODE
> is a reference to an array, whereas
<CODE
CLASS="literal"
>@LoL</CODE
> is an array proper.  The parentheses
(indicating a list) have changed to brackets (indicating the creation
of a reference to an array).  Unlike C, Perl doesn't allow you to
freely interchange arrays with references to arrays.  This is a
feature.</P
><P
CLASS="para"
>Remember that there is an implied <CODE
CLASS="literal"
>-&gt;</CODE
> between every pair of
adjacent braces or brackets.  Therefore these two lines:</P
><PRE
CLASS="programlisting"
>$LoL[2][2]
$ref_to_LoL-&gt;[2][2]</PRE
><P
CLASS="para"
>are equivalent to these two lines:</P
><PRE
CLASS="programlisting"
>$LoL[2]-&gt;[2]
$ref_to_LoL-&gt;[2]-&gt;[2]</PRE
><P
CLASS="para"
>There is, however, no implied
<CODE
CLASS="literal"
>-&gt;</CODE
> before the first pair of brackets, which is
why the dereference of <CODE
CLASS="literal"
>$ref_to_LoL</CODE
> requires the
<CODE
CLASS="literal"
>-&gt;</CODE
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-6.2"
>4.6.2 Growing Your Own</A
></H3
><P
CLASS="para"
>Now those big list assignments are well and good for creating a fixed
data structure, but what if you want to calculate each element on the
fly, or otherwise build the structure piecemeal?</P
><P
CLASS="para"
>First, let's look at reading a data structure in from a file.  We'll
assume that there's a flat file in which each line is a row of the
structure, and each word an element.  Here's how to proceed:</P
><PRE
CLASS="programlisting"
>while (&lt;&gt;) {
    @tmp = split;
    push @LoL, [ @tmp ];
}</PRE
><P
CLASS="para"
>You can also load the array from a function:</P
><PRE
CLASS="programlisting"
>for $i ( 1 .. 10 ) {
    @tmp = somefunc($i);
    $LoL[$i] = [ @tmp ];
}</PRE
><P
CLASS="para"
>Of course, you don't need to name the temporary array:</P
><PRE
CLASS="programlisting"
>while (&lt;&gt;) {
    push @LoL, [ split ];
}</PRE
><P
CLASS="para"
>and:</P
><PRE
CLASS="programlisting"
>for $i ( 1 .. 10 ) {
    $LoL[$i] = [ somefunc($i) ];
}</PRE
><P
CLASS="para"
>You also don't have to use <A
CLASS="xref"
HREF="ch03_112.htm"
TITLE="push"
><B
CLASS="xref.cmd"
>push</B
></A
>.  You
could keep track of where you are in the array, and assign each line
of the file to the appropriate row of the array:</P
><PRE
CLASS="programlisting"
>my (@LoL, $i, $line);
for $i ( 0 .. 10 ) { # just first 11 lines 
    $line = &lt;&gt;;
    $LoL[$i] = [ split ' ', $line ];
}</PRE
><P
CLASS="para"
>Simplifying, you can avoid the assignment of the line to a
mediating variable:</P
><PRE
CLASS="programlisting"
>my (@LoL, $i);
for $i ( 0 .. 10 ) { # just first 11 lines
    $LoL[$i] = [ split ' ', &lt;&gt; ];
}</PRE
><P
CLASS="para"
>In general, you should be leery of using potential list functions like
<CODE
CLASS="literal"
>&lt;&gt;</CODE
> in a scalar context without explicitly stating such.  
The following example would be clearer to the casual reader:</P
><PRE
CLASS="programlisting"
>my (@LoL, $i);
for $i ( 0 .. 10 ) { # just first 11 lines
    $LoL[$i] = [ split ' ', scalar(&lt;&gt;) ];
}</PRE
><P
CLASS="para"
>If you want a <CODE
CLASS="literal"
>$ref_to_LoL</CODE
> variable as a reference
to an array, do something like:</P
><PRE
CLASS="programlisting"
>my $ref_to_LoL;
while (&lt;&gt;) {
    push @$ref_to_LoL, [ split ];
}</PRE
><P
CLASS="para"
>So much for adding new rows to the list of lists.  What about adding new
columns? If you're just dealing with matrices, it's often easiest to use
simple assignment:</P
><PRE
CLASS="programlisting"
>for $x (1 .. 10) {
    for $y (1 .. 10) {
        $LoL[$x][$y] = func($x, $y);
    }
}

for $x ( 3, 7, 9 ) {
    $LoL[$x][20] += func2($x);
}</PRE
><P
CLASS="para"
>It doesn't matter whether the subscripted elements of <CODE
CLASS="literal"
>@LoL</CODE
> are already 
there or not; Perl will gladly create them for you, setting
intervening elements to the undefined value as need be. If you just want to append to a row, you have
to do something a bit funnier looking:</P
><PRE
CLASS="programlisting"
># add new columns to an existing row
push @{ $LoL[0] }, &quot;wilma&quot;, &quot;betty&quot;;</PRE
><P
CLASS="para"
>Notice that this wouldn't work:</P
><PRE
CLASS="programlisting"
>push $LoL[0], &quot;wilma&quot;, &quot;betty&quot;;  # WRONG!</PRE
><P
CLASS="para"
>In fact, that wouldn't even compile, because the argument to <A
CLASS="xref"
HREF="ch03_112.htm"
TITLE="push"
><B
CLASS="xref.cmd"
>push</B
></A
> must be a real array, not just a reference
to an array.  Therefore, the first argument absolutely must begin
with an <CODE
CLASS="literal"
>@</CODE
> character.  What comes after the
<CODE
CLASS="literal"
>@</CODE
> is somewhat negotiable.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-6.3"
>4.6.3 Access and Printing</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-14862"
></A
>Now it's time to print your data structure.  If you only want one element, do this:</P
><PRE
CLASS="programlisting"
>print $LoL[0][0];</PRE
><P
CLASS="para"
>If you want to print the whole thing, though, you can't just say:</P
><PRE
CLASS="programlisting"
>print @LoL;         # WRONG</PRE
><P
CLASS="para"
>because you'll get references listed, and Perl will never
automatically dereference thingies for you.  Instead, you have to roll
yourself a loop or two.  The following code prints the whole
structure, using the shell-style <B
CLASS="emphasis.bold"
>for</B
>
construct to loop through the outer set of subscripts:</P
><PRE
CLASS="programlisting"
>for $array_ref ( @LoL ) {
    print &quot;\t [ @$array_ref ],\n&quot;;
}</PRE
><P
CLASS="para"
>Beware of the brackets.  In this and the following example, the
(non-subscripting) brackets do not indicate the creation of a
reference.  The brackets occur inside a quoted string, not in a place
where a term is expected, and therefore lose their special meaning.
They are just part of the string that <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> outputs.</P
><P
CLASS="para"
>If you want to keep track of subscripts, you might do this:</P
><PRE
CLASS="programlisting"
>for $i ( 0 .. $#LoL ) {
    print &quot;\t element $i is [ @{$LoL[$i]} ],\n&quot;;
}</PRE
><P
CLASS="para"
>or maybe even this (notice the inner loop):</P
><PRE
CLASS="programlisting"
>for $i ( 0 .. $#LoL ) {
    for $j ( 0 .. $#{$LoL[$i]} ) {
        print &quot;element $i $j is $LoL[$i][$j]\n&quot;;
    }
}</PRE
><P
CLASS="para"
>As you can see, things are getting a bit complicated.  That's why 
sometimes it's easier to use a temporary variable on your way through:</P
><PRE
CLASS="programlisting"
>for $i ( 0 .. $#LoL ) {
    $aref = $LoL[$i];
    for $j ( 0 .. $#{$aref} ) {
        print &quot;element $i $j is $aref-&gt;[$j]\n&quot;;
    }
}</PRE
><P
CLASS="para"
>But that's still a bit ugly.  How about this:</P
><PRE
CLASS="programlisting"
>for $i ( 0 .. $#LoL ) {
    $aref = $LoL[$i];
    $n = @$aref - 1;
    for $j ( 0 .. $n ) {
        print &quot;element $i $j is $aref-&gt;[$j]\n&quot;;
    }
}</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-6.4"
>4.6.4 Slices</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-14884"
></A
>If you want to get at a slice (part of a row) in a multi-dimensional
array, you're going to have to do some fancy subscripting.  That's
because, while we have a nice synonym for a single element via the
pointer arrow, no such convenience exists for slices.
However, you can always write a loop to do a slice operation.</P
><P
CLASS="para"
>Here's how to create a one-dimensional slice of one subarray of a
two-dimensional array, using a loop.  We'll assume a list-of-lists
variable (rather than a reference to a list of lists):</P
><PRE
CLASS="programlisting"
>@part = ();
$x = 4;     
for ($y = 7; $y &lt; 13; $y++) {
    push @part, $LoL[$x][$y];
}</PRE
><P
CLASS="para"
>That same loop could be replaced with a slice operation:</P
><PRE
CLASS="programlisting"
>@part = @{ $LoL[4] } [ 7..12 ];</PRE
><P
CLASS="para"
>If you want a <EM
CLASS="emphasis"
>two-dimensional slice</EM
>, say, with
<CODE
CLASS="literal"
>$x</CODE
> running from <CODE
CLASS="literal"
>4..8</CODE
> and
<CODE
CLASS="literal"
>$y</CODE
> from <CODE
CLASS="literal"
>7..12</CODE
>, here's one way to
do it:</P
><PRE
CLASS="programlisting"
>@newLoL = ();
for ($startx = $x = 4; $x &lt;= 8; $x++) {
    for ($starty = $y = 7; $y &lt;= 12; $y++) {
        $newLoL[$x - $startx][$y - $starty] = $LoL[$x][$y];
    }
}</PRE
><P
CLASS="para"
>In this example, the individual values within each subarray of
<CODE
CLASS="literal"
>@newLoL</CODE
> are assigned one by one, taken from the
appropriate locations in <CODE
CLASS="literal"
>@LoL</CODE
>.  An alternative is
to create anonymous arrays, each consisting of a desired slice of a
subarray of <CODE
CLASS="literal"
>@LoL</CODE
>, and then put references to these
anonymous arrays into <CODE
CLASS="literal"
>@newLoL</CODE
>.  So we are writing
references into <CODE
CLASS="literal"
>@newLoL</CODE
> (subscripted once, so to
speak) instead of subarray values into a twice-subscripted
<CODE
CLASS="literal"
>@newLol</CODE
>.  This method eliminates the innermost loop:</P
><PRE
CLASS="programlisting"
>for ($x = 4; $x &lt;= 8; $x++) {
    push @newLoL, [ @{ $LoL[$x] } [ 7..12 ] ];
}</PRE
><P
CLASS="para"
>Of course, if you do this very often, you should probably write a
subroutine called something like <CODE
CLASS="literal"
>extract_rectangle()</CODE
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-6.5"
>4.6.5 Common Mistakes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH04.TROUBLE"
></A
>As mentioned previously, every array or hash in Perl is implemented in
one dimension.  &quot;Multi-dimensional&quot; arrays, too, are one-dimensional, but
the values in this one-dimensional array are references to other data
structures.  If you print these values out without
dereferencing them, you will get the references rather than the data
referenced.  For example, these two lines:</P
><PRE
CLASS="programlisting"
>@LoL = ( [2, 3], [4, 5, 7], [0] );
print &quot;@LoL&quot;;</PRE
><P
CLASS="para"
>result in:</P
><PRE
CLASS="programlisting"
>ARRAY(0x83c38) ARRAY(0x8b194) ARRAY(0x8b1d0)</PRE
><P
CLASS="para"
>On the other hand, this line:</P
><PRE
CLASS="programlisting"
>print $LoL[1][2];</PRE
><P
CLASS="para"
>yields <CODE
CLASS="literal"
>7</CODE
> as output.</P
><P
CLASS="para"
>Perl dereferences your variables only when you employ one of the<A
CLASS="indexterm"
NAME="AUTOID-14921"
></A
>
dereferencing mechanisms.  But remember that
<CODE
CLASS="literal"
>$LoL[1][2]</CODE
> is just a convenient way to write
<CODE
CLASS="literal"
>$LoL[1]-&gt;[2]</CODE
>, which in turn is a convenient way to write
<CODE
CLASS="literal"
>${$LoL[1]}[2]</CODE
>.  Indeed, you could write all your dereferencing
operations with braces, but that would be uglier than ugly.
Use the syntactic sugar Perl provides to sweeten your program.</P
><P
CLASS="para"
><CODE
CLASS="literal"
>@LoL</CODE
> was defined as an array whose values happened to be
references.  Here's a similar-looking, but very different case:</P
><PRE
CLASS="programlisting"
>my $listref = [
    [ &quot;fred&quot;, &quot;barney&quot;, &quot;pebbles&quot;, &quot;bambam&quot;, &quot;dino&quot;, ],
    [ &quot;homer&quot;, &quot;bart&quot;, &quot;marge&quot;, &quot;maggie&quot;, ],
    [ &quot;george&quot;, &quot;jane&quot;, &quot;elroy&quot;, &quot;judy&quot;, ],
];

print $listref[2][2];   # WRONG!</PRE
><P
CLASS="para"
>Here, <CODE
CLASS="literal"
>$listref</CODE
> is not an array, but a scalar
variable <EM
CLASS="emphasis"
>referring</EM
> to an array&nbsp;- in this
case, referring to an anonymous, multi-dimensional array, the one
created by the outer brackets.  Therefore, to print
<CODE
CLASS="literal"
>elroy</CODE
> in this example, we should have said:</P
><PRE
CLASS="programlisting"
>print $listref-&gt;[2][2];</PRE
><P
CLASS="para"
>By contrast, <CODE
CLASS="literal"
>$listref[2]</CODE
> in the erroneous <B
CLASS="emphasis.bold"
>print</B
>
statement is the second element in a not-yet-declared array.  If you
ask to</P
><PRE
CLASS="programlisting"
>use strict 'vars'; # or just use strict</PRE
><P
CLASS="para"
>then the use of the undeclared array will be flagged as an error at compile time.</P
><P
CLASS="para"
>In constructing an array of arrays, remember to take a reference for the
daughter arrays.  Otherwise, you will just create an array containing the
element counts of the daughter arrays, like this:</P
><PRE
CLASS="programlisting"
>for $i (1..10) {
    @list = somefunc($i);
    $LoL[$i] = @list;       # WRONG!
}</PRE
><P
CLASS="para"
>Here <CODE
CLASS="literal"
>@list</CODE
> is being accessed in a scalar context, and therefore
yields a count of its elements, which is assigned to
<CODE
CLASS="literal"
>$LoL[$i]</CODE
>.  The proper way to take the reference will be shown
in a moment.</P
><P
CLASS="para"
>Another common error involves taking a reference to the same memory location
over and over again:</P
><PRE
CLASS="programlisting"
>for $i (1..10) {
    @list = somefunc($i);
    $LoL[$i] = \@list;      # WRONG!
}</PRE
><P
CLASS="para"
>Every reference generated by the second line of the <B
CLASS="emphasis.bold"
>for</B
> loop is
the same, namely, a reference to the single array <CODE
CLASS="literal"
>@list</CODE
>.  Yes, this
array is being given a different set of values on each pass through the
loop, but when everything is said and done, <CODE
CLASS="literal"
>$LoL</CODE
> contains a set of
identical references to the same array, which now holds the last set of
values that were assigned to it.</P
><P
CLASS="para"
>Here's a more successful approach:</P
><PRE
CLASS="programlisting"
>for $i (1..10) {
    @list = somefunc($i);
    $LoL[$i] = [ @list ];
}</PRE
><P
CLASS="para"
>The brackets make a reference to a new array with a <EM
CLASS="emphasis"
>copy</EM
>
of what's in <CODE
CLASS="literal"
>@list</CODE
> at the time of the assignment.</P
><P
CLASS="para"
>A similar result&nbsp;- though much more difficult to read&nbsp;- would be produced by:</P
><PRE
CLASS="programlisting"
>for $i (1..10) {
    @list = somefunc($i);
    @{$LoL[$i]} = @list;
}</PRE
><P
CLASS="para"
>Since <CODE
CLASS="literal"
>$LoL[$i]</CODE
> needs to be a reference, the reference springs
into existence.  Then, the preceding <CODE
CLASS="literal"
>@</CODE
> dereferences this new
reference, with the result that the values of <CODE
CLASS="literal"
>@list</CODE
> are assigned 
(in list context) to the array referenced by <CODE
CLASS="literal"
>$LoL[$i]</CODE
>.  For
clarity's sake, you might wish to avoid this construct.</P
><P
CLASS="para"
>But there <EM
CLASS="emphasis"
>is</EM
> a situation in which you might use it.
Suppose <CODE
CLASS="literal"
>@LoL</CODE
> is already an array of references to arrays.
That is, suppose you had made assignments like:</P
><PRE
CLASS="programlisting"
>$LoL[3] = \@original_list;</PRE
><P
CLASS="para"
>And now suppose that you want to change <CODE
CLASS="literal"
>@original_list</CODE
> (that is,
you want to change the fourth row of <CODE
CLASS="literal"
>$LoL</CODE
>) so that it
refers to the elements of <CODE
CLASS="literal"
>@list</CODE
>.  This code will work:</P
><PRE
CLASS="programlisting"
>@{$LoL[3]} = @list;</PRE
><P
CLASS="para"
>In this case, the reference itself does not change, but the elements of
the array being referred to do.  You need to be aware, however,
that this approach overwrites the values of <CODE
CLASS="literal"
>@original_list</CODE
>.</P
><P
CLASS="para"
>Finally, the following dangerous-looking code actually works fine:</P
><PRE
CLASS="programlisting"
>for $i (1..10) {
    my @list = somefunc($i);
    $LoL[$i] = \@list;
}</PRE
><P
CLASS="para"
>That's because the <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> variable is
created afresh each time through the loop.  So even though it looks as
though you stored the same variable reference each time, you actually did
not.  This is a subtle distinction, but the technique can produce more
efficient code, at the risk of misleading less enlightened programmers.  
It's more efficient because there's no copy in the final assignment.
On the other hand, if you have to copy the values anyway (which the
first assignment above is doing), then you might as well use the copy
implied by the brackets and avoid the temporary variable:</P
><PRE
CLASS="programlisting"
>for $i (1..10) {
    $LoL[$i] = [ somefunc($i) ];
}</PRE
><P
CLASS="para"
>In summary:</P
><PRE
CLASS="programlisting"
>$LoL[$i] = [ @list ];   # safest, sometimes fastest
$LoL[$i] = \@list;      # fast but risky, depends on my-ness of list
@{ $LoL[$i] } = @list;  # too tricky for most uses</PRE
><A
CLASS="indexterm"
NAME="AUTOID-14980"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14981"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14982"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14983"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14984"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14985"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Braces, Brackets, and Quoting"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 4.5 Braces, Brackets, and Quoting"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_07.htm"
TITLE="4.7 Data Structure Code Examples"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.7 Data Structure Code Examples"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>4.5 Braces, Brackets, and Quoting</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.7 Data Structure Code Examples</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
