<HTML
><HEAD
>
<TITLE>[Chapter 9] Diagnostic Messages</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T02:07:40Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Programming Perl"><LINK
REL="prev"
HREF="ch08_07.htm"
TITLE="8.7 History Made Practical"><LINK
REL="next"
HREF="glossary.htm"
TITLE="Glossary"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_07.htm"
TITLE="8.7 History Made Practical"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.7 History Made Practical"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 9</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="GLOSSARY"
HREF="glossary.htm"
TITLE="Glossary"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: Glossary"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="CHAPTER"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PERL2-CH-9"
>9. Diagnostic Messages</A
></H1
><P
CLASS="para"
>These messages are classified as follows (listed in increasing order of
desperation):<A
CLASS="indexterm"
NAME="AUTOID-30319"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30322"
></A
><A
CLASS="indexterm"
NAME="CH09.MESS1"
></A
><A
CLASS="indexterm"
NAME="CH09.MESS2"
></A
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Class</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(W)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A warning (optional)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(D)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A deprecation (optional)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(S)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A severe warning (mandatory)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(F)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A fatal error (trappable)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(P)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An internal error (panic) that you should never see (trappable)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(X)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A very fatal error (non-trappable)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(A)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>An alien error message (not generated by Perl)</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30358"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30360"
></A
><A
CLASS="indexterm"
NAME="AUTOID-30363"
></A
>Optional warnings are enabled by using the <B
CLASS="emphasis.bold"
>-w</B
> switch.  Warnings may be captured by setting
<CODE
CLASS="literal"
>$SIG{__WARN__}</CODE
> to a reference to a routine
that will be called on each warning before printing it.  Trappable errors may be
trapped using <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>.  You can also capture
control before a trappable error &quot;dies&quot; by setting
<CODE
CLASS="literal"
>$SIG{__DIE__}</CODE
> to a subroutine reference, but
if you don't call <A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
> within that handler,
the fatal exception is still thrown when you return from it.  In other words,
you're not allowed to &quot;de-fatalize&quot; an exception that way.  You must use an
<A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> wrapper for that.</P
><P
CLASS="para"
>In the following messages <EM
CLASS="emphasis"
>%s</EM
> stands for an
interpolated string that is determined only when the message is
generated.  (Similarly, <EM
CLASS="emphasis"
>%d</EM
> stands for an
interpolated number&nbsp;- think <A
CLASS="xref"
HREF="ch03_111.htm"
TITLE="printf"
><B
CLASS="xref.cmd"
>printf</B
></A
>
formats, but we use <EM
CLASS="emphasis"
>%d</EM
> to mean a number in any
base here.)  Note that some messages begin with
<EM
CLASS="emphasis"
>%s</EM
>&nbsp;- which means that listing them
alphabetically is problematical.  You should search among these
messages if the one you are looking for does not appear in the
expected place.  The symbols
<CODE
CLASS="literal"
>&quot; % - ? @</CODE
> sort before
alphabetic characters, while <CODE
CLASS="literal"
>[</CODE
> and
<CODE
CLASS="literal"
>\</CODE
> sort after.</P
><P
CLASS="para"
>References of the form, &quot;See <A
CLASS="xref"
HREF="ch03_182.htm"
TITLE="unpack"
><B
CLASS="xref.cmd"
>unpack</B
></A
>,&quot;
refer to entries in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3, <CITE
CLASS="chapter"
>Functions</CITE
></A
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-30384"
></A
>If you decide a bug is a Perl bug and not your bug, you should try to
reduce it to a minimal test case and then report it with the
<EM
CLASS="emphasis"
>perlbug</EM
> program that comes with Perl.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>&quot;my&quot; variable </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> can't be in a package</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Lexically scoped variables aren't in a package, so it doesn't make sense
to try to declare one with a package qualifier on the front.  Use <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
>
if you want to localize a package variable.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>&quot;no&quot; not allowed in expression</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_100.htm"
TITLE="no"
><B
CLASS="xref.cmd"
>no</B
></A
> keyword is recognized and executed at compile time, and returns
no useful value.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>&quot;use&quot; not allowed in expression</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> keyword is recognized and executed at compile time, and returns
no useful value.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>% may only be used in unpack</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't pack a string by supplying a checksum, since the
checksumming process loses information, and you can't go the other
way.  See <A
CLASS="xref"
HREF="ch03_182.htm"
TITLE="unpack"
><B
CLASS="xref.cmd"
>unpack</B
></A
>.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> (...) interpreted as function</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You've run afoul of the rule that says that any list operator followed
by parentheses turns into a function, with all the list operator's arguments 
found inside the parens.  
See the section &quot;Terms and List Operators (Leftward)&quot; in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2, <CITE
CLASS="chapter"
>The Gory Details</CITE
></A
>.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> argument is not a HASH element</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The argument to <A
CLASS="xref"
HREF="ch03_026.htm"
TITLE="delete"
><B
CLASS="xref.cmd"
>delete</B
></A
> or <A
CLASS="xref"
HREF="ch03_034.htm"
TITLE="exists"
><B
CLASS="xref.cmd"
>exists</B
></A
> must be a hash element, such as</P
><PRE
CLASS="programlisting"
>$foo{$bar}
$ref-&gt;[12]-&gt;{&quot;susie&quot;}</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> did not return a true value</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>d (or <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
>d) file must return a true value to
indicate that it compiled correctly and ran its initialization code
correctly.  It's traditional to end such a file with a &quot;<CODE
CLASS="literal"
>1;</CODE
>&quot;,
though any true value would do.  See <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> found where operator expected</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The Perl lexer knows whether to expect a term or an operator.  If it
sees what it knows to be a term when it was expecting to see an operator,
it gives you this warning.  Usually it indicates that an operator or
delimiter was omitted, such as a semicolon.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> had compilation errors.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The final summary message when a <EM
CLASS="emphasis"
>perl -c</EM
> command fails.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> has too many errors.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> matches null string many times</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> never introduced</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The symbol in question was declared but somehow went out of scope
before it could possibly have been used.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> syntax OK</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The final summary message when a <EM
CLASS="emphasis"
>perl -c</EM
> command succeeds.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: Command not found.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through <EM
CLASS="emphasis"
>csh</EM
> instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: Expression syntax.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through <EM
CLASS="emphasis"
>csh</EM
> instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: Undefined variable.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through <EM
CLASS="emphasis"
>csh</EM
> instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: not found</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through the Bourne shell instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>-P not allowed for setuid/setgid script</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>-T and -B not implemented on filehandles</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl can't peek at the <CODE
CLASS="literal"
>stdio</CODE
> buffer of filehandles when it doesn't
know about your kind of <CODE
CLASS="literal"
>stdio</CODE
>.  You'll have to use a filename instead.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>500 Server error</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>See <CODE
CLASS="literal"
>Server error</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>?+* follows nothing in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You started a regular expression with a quantifier.  Backslash it
if you meant it literally.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>@ outside of string</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You had a <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
> template that specified an absolute position outside
the string being unpacked.  See <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>accept() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to do an <A
CLASS="xref"
HREF="ch03_004.htm"
TITLE="accept"
><B
CLASS="xref.cmd"
>accept</B
></A
> on a closed socket.  Did you forget to check
the return value of your <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call?  See <A
CLASS="xref"
HREF="ch03_004.htm"
TITLE="accept"
><B
CLASS="xref.cmd"
>accept</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Allocation too large: </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't allocate more than 64K on an MS-DOS machine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Arg too short for msgsnd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) <A
CLASS="xref"
HREF="ch03_096.htm"
TITLE="msgsnd"
><B
CLASS="xref.cmd"
>msgsnd</B
></A
> requires a string at least as
long as <CODE
CLASS="literal"
>sizeof(long)</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Ambiguous use of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> resolved as </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W)(S) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, pair of parentheses, or declaration.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Args must match #! line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The setuid emulator requires that the switches <EM
CLASS="emphasis"
>perl</EM
> was invoked
with match the switches specified on the <CODE
CLASS="literal"
>#!</CODE
> line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Argument &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; isn't numeric</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The indicated string was fed as an argument to an operator that
expected a numeric value instead.  If you're fortunate the message
will identify which operator was so unfortunate.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Array @</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> missing the @ in argument </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>()</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) Really old Perl let you omit the <CODE
CLASS="literal"
>@</CODE
> on array names in some
spots.  This is now heavily deprecated.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>assertion botched: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <EM
CLASS="emphasis"
>malloc</EM
>(3) package that comes with Perl had an internal failure.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Assertion failed: file &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) A general assertion failed.  The file in question must be examined.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Assignment to both a list and a scalar</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) If you assign to a conditional operator, the second and third arguments
must either both be scalars or both be lists.  Otherwise Perl won't
know which context to supply to the right side.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Attempt to free non-arena SV: </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) All SV objects are supposed to be allocated from arenas that will
be garbage collected upon exit.  An SV was discovered to be outside any
of those arenas.  This probably means that someone screwed up in a C
extension module.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Attempt to free temp prematurely</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) Mortalized values are supposed to be freed by the internal
<CODE
CLASS="literal"
>free_tmps()</CODE
> routine.  This indicates that something else is
freeing the SV before the <CODE
CLASS="literal"
>free_tmps()</CODE
> routine gets a chance, which
means that the <CODE
CLASS="literal"
>free_tmps()</CODE
> routine will be freeing an unreferenced
scalar when it does try to free it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Attempt to free unreferenced glob pointers</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The reference counts got screwed up on symbol aliases.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Attempt to free unreferenced scalar</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) Perl went to decrement the reference count of a scalar to see if it
would go to <CODE
CLASS="literal"
>0</CODE
>, and discovered that it had already gone to
<CODE
CLASS="literal"
>0</CODE
> earlier, and should have been freed, and in fact, probably was
freed.  This could indicate that <CODE
CLASS="literal"
>SvREFCNT_dec()</CODE
>
was called too
many times, or that <CODE
CLASS="literal"
>SvREFCNT_inc()</CODE
> was called too few times, or
that the SV was mortalized when it shouldn't have been, or that memory
has been corrupted.  In any event, it's likely a problem with the C
extension module you're developing.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad arg length for </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>, is </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
>, should be </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You passed a buffer of the wrong size to one of <A
CLASS="xref"
HREF="ch03_093.htm"
TITLE="msgctl"
><B
CLASS="xref.cmd"
>msgctl</B
></A
>,
<A
CLASS="xref"
HREF="ch03_136.htm"
TITLE="semctl"
><B
CLASS="xref.cmd"
>semctl</B
></A
> or <A
CLASS="xref"
HREF="ch03_144.htm"
TITLE="shmctl"
><B
CLASS="xref.cmd"
>shmctl</B
></A
>.  In C parlance, the correct sizes are
<CODE
CLASS="literal"
>sizeof(struct msqid_ds *)</CODE
>, <CODE
CLASS="literal"
>sizeof(struct semid_ds *)</CODE
> and
<CODE
CLASS="literal"
>sizeof(struct shmid_ds *)</CODE
>, respectively.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad associative array</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) One of the internal hash routines was passed a null HV pointer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad filehandle: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A symbol was passed to something wanting a filehandle, but the symbol
has no filehandle associated with it.  Perhaps you didn't do an <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
>, or
did it in another package.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad free() ignored</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) An internal routine called <EM
CLASS="emphasis"
>free</EM
>(3) on something that had never been
<EM
CLASS="emphasis"
>malloc</EM
>(3)ed in the first place.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad name after </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>::</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You started to name a symbol by using a package prefix, and then didn't
finish the symbol.  In particular, you can't interpolate outside of quotes,
so</P
><PRE
CLASS="programlisting"
>$var = 'myvar';
$sym = mypack::$var;</PRE
><P
CLASS="para"
>is not the same as</P
><PRE
CLASS="programlisting"
>$var = 'myvar';
$sym = &quot;mypack::$var&quot;;</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad symbol for array</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An internal request asked to add an array entry to something that
wasn't a symbol table entry.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad symbol for filehandle</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An internal request asked to add a filehandle entry to something that
wasn't a symbol table entry.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bad symbol for hash</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An internal request asked to add a hash entry to something that
wasn't a symbol table entry.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Badly placed ()'s</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through <EM
CLASS="emphasis"
>csh</EM
> instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually
feed your script into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>BEGIN failed--compilation aborted</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An untrapped exception was raised while executing a BEGIN subroutine.
Compilation stops immediately and the interpreter is exited.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>bind() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to do a <A
CLASS="xref"
HREF="ch03_007.htm"
TITLE="bind"
><B
CLASS="xref.cmd"
>bind</B
></A
> on a closed socket.  Did you forget to check
the return value of your <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call?  See <A
CLASS="xref"
HREF="ch03_007.htm"
TITLE="bind"
><B
CLASS="xref.cmd"
>bind</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Bizarre copy of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Perl detected an attempt to copy an internal value that is not copiable.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Callback called exit</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A subroutine invoked from an external package via <CODE
CLASS="literal"
>perl_call_sv()</CODE
>
exited by calling <A
CLASS="xref"
HREF="ch03_035.htm"
TITLE="exit"
><B
CLASS="xref.cmd"
>exit</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't &quot;last&quot; outside a block</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A <A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
> statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a
current block.  See note on the next entry.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't &quot;next&quot; outside a block</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A <A
CLASS="xref"
HREF="ch03_099.htm"
TITLE="next"
><B
CLASS="xref.cmd"
>next</B
></A
> statement was executed to
reiterate the current block, but 
there isn't a current block.  Note that an <B
CLASS="emphasis.bold"
>if</B
> or
<B
CLASS="emphasis.bold"
>else</B
> block doesn't 
count as a &quot;loopish&quot; block.  You can usually double the curly brackets to get
the same effect though, since the inner brackets will be considered a block
that loops once.  See <A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't &quot;redo&quot; outside a block</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A <A
CLASS="xref"
HREF="ch03_120.htm"
TITLE="redo"
><B
CLASS="xref.cmd"
>redo</B
></A
> statement was executed to restart the current block, but
there isn't a current block.  See note on the previous entry.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't bless non-reference value</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Only hard references may be blessed.  This is how Perl &quot;enforces&quot;
encapsulation of objects.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't break at that line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A debugger warning indicating
the line number specified wasn't the location of a statement that could
be stopped at.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't call method &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; in empty package &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't have anything at all
defined in it, let alone methods.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't call method &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; on unblessed reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A method call must know what package it's supposed to run in.  It
ordinarily finds this out from the object reference you supply, but
you didn't supply an object reference in this case.  A reference isn't
an object reference until it has been blessed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't call method &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; without a package or object reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an expression that returns
neither an object reference nor a package name.  (Perhaps it's null?)
Something like this will reproduce the error:</P
><PRE
CLASS="programlisting"
>$BADREF = undef;
process $BADREF 1,2,3;
$BADREF-&gt;process(1,2,3);</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't chdir to </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You called <CODE
CLASS="literal"
>perl -x/foo/bar</CODE
>, but
<EM
CLASS="emphasis"
>/foo/bar</EM
> is not a directory that you can
<EM
CLASS="emphasis"
>chdir</EM
>(2) to, possibly because it doesn't exist.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't coerce </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> to integer in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Certain types of SVs, in particular real symbol table entries
(type GLOB), can't be forced to stop being what they are.  So you can't
say things like:</P
><PRE
CLASS="programlisting"
>*foo += 1;     # ERROR</PRE
><P
CLASS="para"
>You <EM
CLASS="emphasis"
>can</EM
> say</P
><PRE
CLASS="programlisting"
>$foo = *foo;   # make a &quot;fake&quot; glob value
$foo += 1;</PRE
><P
CLASS="para"
>but then <CODE
CLASS="literal"
>$foo</CODE
> no longer contains a glob.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't coerce </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> to number in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Certain types of SVs, in particular real symbol table entries
(type GLOB), can't be forced to stop being what they are.  See preceding entry.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't coerce </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> to string in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Certain types of SVs, in particular real symbol table entries
(type GLOB), can't be forced to stop being what they are.  See
previous two entries.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't create pipe mailbox</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  The process is suffering from exhausted quotas
or other plumbing problems.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't declare </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in my</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Only scalar, array and hash variables may be declared as lexical variables.
They must have ordinary identifiers as names, since lexical variables don't
live in a symbol table, and can't be package qualified.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do inplace edit on </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The creation of the new file failed for the indicated reason.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do inplace edit without backup</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You're on a system such as MS-DOS that gets confused if you try
reading from a deleted (but still opened) file.  You have to use the switch,
<CODE
CLASS="literal"
>-i.bak</CODE
>, or some such.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do inplace edit: </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> &gt; 14 characters</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) There isn't enough room in the filename to make a backup name for the file.
Perhaps you should get a system with longer filenames.  <CODE
CLASS="literal"
>:-)</CODE
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do inplace edit: </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> is not a regular file</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) You tried to use the <B
CLASS="emphasis.bold"
>-i</B
> switch on a special file, such as a file in
<EM
CLASS="emphasis"
>/dev</EM
>, or a FIFO.  The file was ignored.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do setegid!</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <CODE
CLASS="literal"
>setegid()</CODE
> call failed for some reason in the setuid emulator
of <EM
CLASS="emphasis"
>suidperl</EM
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do seteuid!</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The setuid emulator of <EM
CLASS="emphasis"
>suidperl</EM
> failed for some reason.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do setuid</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) This typically means that ordinary <EM
CLASS="emphasis"
>perl</EM
> tried to exec
<EM
CLASS="emphasis"
>suidperl</EM
> to do setuid emulation, but couldn't exec it.
If you're running <EM
CLASS="emphasis"
>/usr/local/bin/perl5.003</EM
>, it looks for a
corresponding <EM
CLASS="emphasis"
>/usr/local/bin/sperl5.003</EM
>.  (Note the &quot;s&quot;.)
If the file is there, check the execute permissions.  If it isn't, ask
your sysadmin why he and/or she removed it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do waitpid with flags</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) This machine doesn't have either <EM
CLASS="emphasis"
>waitpid</EM
>(2) or <EM
CLASS="emphasis"
>wait4</EM
>(2),
so only <A
CLASS="xref"
HREF="ch03_190.htm"
TITLE="waitpid"
><B
CLASS="xref.cmd"
>waitpid</B
></A
> without flags is emulated.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't do {n,m} with n &gt; m</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Minima must be less than or equal to maxima.  If you really want
your regular expression to match something <CODE
CLASS="literal"
>0</CODE
> times, just put
<CODE
CLASS="literal"
>{0}</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't emulate -</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> on #! line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <CODE
CLASS="literal"
>#!</CODE
> line specifies a switch that doesn't make sense at this point.
For example, it'd be kind of silly to put a <B
CLASS="emphasis.bold"
>-x</B
> on the <CODE
CLASS="literal"
>#!</CODE
> line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't exec &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A <A
CLASS="xref"
HREF="ch03_167.htm"
TITLE="system"
><B
CLASS="xref.cmd"
>system</B
></A
>, <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
> or piped <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> call could not execute the named
program for the indicated reason.  Typical reasons include: the permissions
were wrong on the file, the file wasn't found in <CODE
CLASS="literal"
>$ENV{PATH}</CODE
>, the
executable in question was compiled for another architecture, or the
<CODE
CLASS="literal"
>#!</CODE
> line in a script points to an interpreter that can't be run for
similar reasons.  (Or maybe your system doesn't support <CODE
CLASS="literal"
>#!</CODE
> at all.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't exec </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to execute the indicated program for you because that's
what the <CODE
CLASS="literal"
>#!</CODE
> line said.  If that's not what you wanted, you may need to
mention &quot;<CODE
CLASS="literal"
>perl</CODE
>&quot; on the <CODE
CLASS="literal"
>#!</CODE
> line somewhere.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't execute </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You used the <B
CLASS="emphasis.bold"
>-S</B
> switch, but the script to execute could not be found
in the PATH, or at least not with the correct permissions.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't find label </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You said to <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
> a label that isn't mentioned anywhere that it's
possible for us to go to.  See <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't find string terminator </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> anywhere before EOF</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl strings can stretch over multiple lines.  This message means that
the closing delimiter was omitted.  Since bracketed quotes count nesting
levels, the following is missing its final parenthesis:</P
><PRE
CLASS="programlisting"
>print q(The character '(' starts a s(n)ide comment.)</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't fork</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A fatal error occurred while trying to fork while opening a pipeline.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't get filespec - stale stat buffer?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A warning peculiar to VMS.  This arises because of the difference between
access checks under VMS and under the UNIX model Perl assumes.  Under VMS,
access checks are done by filename, rather than by bits in the stat buffer, so
that ACLs and other protections can be taken into account.  Unfortunately, Perl
assumes that the stat buffer contains all the necessary information, and passes
it, instead of the filespec, to the access-checking routine.  It will try to
retrieve the filespec using the device name and FID present in the stat buffer,
but this works only if you haven't made a subsequent call to the CRTL
<CODE
CLASS="literal"
>stat</CODE
>
routine, since the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access-checking routine gave up and
returned FALSE, just to be conservative.  (Note: The access-checking routine
knows about the Perl <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
> operator and file tests, so you shouldn't ever
see this warning in response to a Perl command; it arises only if some internal
code takes stat buffers lightly.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't get pipe mailbox device name</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  After creating a mailbox to act as a pipe, Perl
can't retrieve its name for later use.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't get SYSGEN parameter value for MAXBUF</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  Perl asked <CODE
CLASS="literal"
>$GETSYI</CODE
> how big you want your
mailbox buffers to be, and didn't get an answer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't goto subroutine outside a subroutine</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The deeply magical <CODE
CLASS="literal"
>goto</CODE
>
<CODE
CLASS="replaceable"
><I
>SUBROUTINE</I
></CODE
> call can only replace one subroutine
call for another.  It can't manufacture one out of whole cloth.  In general
you should only be calling it out of an <CODE
CLASS="literal"
>AUTOLOAD</CODE
> routine anyway.  See
<A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't localize a reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You said something like <CODE
CLASS="literal"
>local $$ref</CODE
>, which is not allowed
because the compiler can't determine whether <CODE
CLASS="literal"
>$ref</CODE
> will end up
pointing to anything with a symbol table entry, and a symbol table entry
is necessary to do a <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't localize lexical variable </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You used <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> on a variable name that was previous declared as a
lexical variable using <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
>.  This is not allowed.  If you want to
localize a package variable of the same name, qualify it with the
package name.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't locate </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in @INC</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You said to <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> (or <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>, or <A
CLASS="xref"
HREF="ch03_028.htm"
TITLE="do"
><B
CLASS="xref.cmd"
>do</B
></A
>) a file that
couldn't be found in any of the libraries mentioned in <CODE
CLASS="literal"
>@INC</CODE
>.
Perhaps you need to set the <CODE
CLASS="literal"
>PERL5LIB</CODE
> environment variable to say where
the extra library is, or maybe the script needs to add the library name
to <CODE
CLASS="literal"
>@INC</CODE
> with the <CODE
CLASS="literal"
>use lib</CODE
> directive.  Or maybe you just
misspelled the name of the file.  See <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't locate object method &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; via package &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but the package doesn't define that
method name, nor do any of its base classes (which is why the message
says &quot;via&quot; rather than &quot;in&quot;).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't locate package </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> for @</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>::ISA</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The <CODE
CLASS="literal"
>@ISA</CODE
> array contained the name of another package that
doesn't seem to exist.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't mktemp()</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <CODE
CLASS="literal"
>mktemp</CODE
> routine failed for some reason while trying to process
a <B
CLASS="emphasis.bold"
>-e</B
> switch.  Maybe your <EM
CLASS="emphasis"
>/tmp</EM
> partition is full, or clobbered.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't modify </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You aren't allowed to assign to the item indicated, or otherwise try to
change it, such as with an autoincrement.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't modify non-existent substring</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal routine that does assignment to a <A
CLASS="xref"
HREF="ch03_162.htm"
TITLE="substr"
><B
CLASS="xref.cmd"
>substr</B
></A
> was handed
a NULL pointer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't msgrcv to readonly var</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The target of a <A
CLASS="xref"
HREF="ch03_095.htm"
TITLE="msgrcv"
><B
CLASS="xref.cmd"
>msgrcv</B
></A
> must be modifiable in order to be used as
a receive buffer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) An inplace edit couldn't open the original file for the indicated reason.
Usually this is because you don't have read permission for the file.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open bidirectional pipe</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to say <CODE
CLASS="literal"
>open(CMD, &quot;|cmd|&quot;)</CODE
>, which is
not supported.
You can try any of several modules in the Perl library to do this, such
as Open2.  Alternately, direct the pipe's output to a file using
&quot;<CODE
CLASS="literal"
>&gt;</CODE
>&quot;, and then read it in under a different filehandle.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open error file </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> as stderr</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl does its own command-line redirection, and
couldn't open for writing the file specified after <CODE
CLASS="literal"
>2&gt;</CODE
> or
<CODE
CLASS="literal"
>2&gt;&gt;</CODE
> on the command line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open input file </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> as stdin</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl does its own command-line redirection, and
couldn't open for reading the file specified after <CODE
CLASS="literal"
>&lt;</CODE
> on
the command line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open output file </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> as stdout</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl does its own command-line
redirection, and couldn't open for writing the file specified after
<CODE
CLASS="literal"
>&gt;</CODE
> or 
<CODE
CLASS="literal"
>&gt;&gt;</CODE
> on the command line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open output pipe (name: </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  Perl does its own command-line redirection, and
couldn't open the pipe into which to send data destined for <CODE
CLASS="literal"
>STDOUT</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't open perl script &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The script you specified can't be opened for the indicated reason.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't rename </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> to </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>, skipping file</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The rename done by the <B
CLASS="emphasis.bold"
>-i</B
> switch failed
for some reason, probably because you don't have write permission to the
directory.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't reopen input pipe (name: </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>) in binary mode</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  Perl thought <CODE
CLASS="literal"
>STDIN</CODE
>
was a pipe, and tried to
reopen it to accept binary data.  Alas, it failed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't reswap uid and euid</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <B
CLASS="emphasis.bold"
>setreuid</B
> call failed for some reason in the setuid emulator
of <EM
CLASS="emphasis"
>suidperl</EM
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't return outside a subroutine</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_125.htm"
TITLE="return"
><B
CLASS="xref.cmd"
>return</B
></A
> statement was executed in mainline code, that is, where
there was no subroutine call to return out of.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't stat script &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) For some reason you can't <EM
CLASS="emphasis"
>fstat</EM
>(2) the script even though you have
it open already.  Bizarre.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't swap uid and euid</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <B
CLASS="emphasis.bold"
>setreuid</B
> call failed for some reason in the setuid emulator
of <EM
CLASS="emphasis"
>suidperl</EM
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't take log of </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Logarithms are only defined on positive real numbers.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't take sqrt of </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) For ordinary real numbers, you can't take the square root of a
negative number.  There's a Complex module available for Perl, though,
if you really want to do that.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't undef active subroutine</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't undefine a routine that's currently running.  You can,
however, redefine it while it's running, and you can even <A
CLASS="xref"
HREF="ch03_180.htm"
TITLE="undef"
><B
CLASS="xref.cmd"
>undef</B
></A
> the
redefined subroutine while the old routine is running.  Go figure.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't unshift</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to <A
CLASS="xref"
HREF="ch03_183.htm"
TITLE="unshift"
><B
CLASS="xref.cmd"
>unshift</B
></A
> an &quot;unreal&quot; array that can't be
unshifted, such as the main Perl stack.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't upgrade that kind of scalar</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal <CODE
CLASS="literal"
>sv_upgrade</CODE
>() routine adds &quot;members&quot; to an SV, making
it into a more specialized kind of SV.  The top several SV types are
so specialized, however, that they cannot be interconverted.  This
message indicates that such a conversion was attempted.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't upgrade to undef</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The undefined SV is the bottom of the totem pole, in the scheme
of upgradability.  Upgrading to undef indicates an error in the
code calling <CODE
CLASS="literal"
>sv_upgrade()</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use &quot;my </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; in sort comparison</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The global variables <B
CLASS="emphasis.bold"
>$a</B
> and <B
CLASS="emphasis.bold"
>$b</B
> are reserved for sort
comparisons.  You mentioned <B
CLASS="emphasis.bold"
>$a</B
> or <B
CLASS="emphasis.bold"
>$b</B
> in the same line as the
<CODE
CLASS="literal"
>&lt;=&gt;</CODE
> or <B
CLASS="emphasis.bold"
>cmp</B
> operator,
and the variable had earlier been declared as a lexical variable.
Either qualify the sort variable with the package name, or rename the
lexical variable.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> for loop variable</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Only a simple scalar variable may be used as a loop variable on a
<B
CLASS="emphasis.bold"
>foreach</B
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> ref as </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> ref</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You've mixed up your reference types.  You have to dereference a
reference of the type needed.  You can use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
> function to
test the type of the reference, if need be.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use \1 to mean $1 in expression</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) In an ordinary expression, backslash is a unary operator that creates
a reference to its argument.  The use of backslash to indicate a backreference
to a matched substring is only valid as part of a regular expression pattern.
Trying to do this in ordinary Perl code produces a value that prints
out looking like <CODE
CLASS="literal"
>SCALAR(0xdecaf)</CODE
>.  Use the <B
CLASS="emphasis.bold"
>$1</B
> form instead.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use string (&quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;) as </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> ref while &quot;strict refs&quot; in use</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Only hard references are allowed by <CODE
CLASS="literal"
>use strict refs</CODE
>.
Symbolic references are disallowed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use an undefined value as </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to de-lurk some insidious errors.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use global </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in &quot;my&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to declare a magical variable as a lexical variable.  This is
not allowed, because the magic can only be tied to one location (namely
the global variable) and it would be incredibly confusing to have
variables in your program that looked like magical variables but
weren't.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't use subscript on </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The compiler tried to interpret a bracketed expression as a
subscript, but to the left of the brackets was an expression that
didn't look like an array reference, or anything else subscriptable.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't write to temp file for -e: </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <EM
CLASS="emphasis"
>write</EM
>(2) routine failed for some reason while trying to process
a <B
CLASS="emphasis.bold"
>-e</B
> switch.  Maybe your <EM
CLASS="emphasis"
>/tmp</EM
> partition is full, or clobbered.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Can't x= to readonly value</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to repeat a constant value (perhaps the undefined value) with
an assignment operator, which implies modifying the value itself.
Perhaps you need to copy the value to a temporary, and repeat that.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Cannot open temporary file</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <EM
CLASS="emphasis"
>creat</EM
>(2) routine failed for some reason
while trying to process a <B
CLASS="emphasis.bold"
>-e</B
> switch.  Maybe
your <EM
CLASS="emphasis"
>/tmp</EM
> partition is full, or clobbered.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>chmod: mode argument is missing initial 0</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A novice will sometimes say</P
><PRE
CLASS="programlisting"
>chmod 777, $filename</PRE
><P
CLASS="para"
>not realizing that <CODE
CLASS="literal"
>777</CODE
> will be interpreted as a decimal number,
equivalent to <CODE
CLASS="literal"
>01411</CODE
>.  Octal constants are introduced with a
leading <CODE
CLASS="literal"
>0</CODE
> in Perl, as in C.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Close on unopened file</CODE
> <EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to <A
CLASS="xref"
HREF="ch03_018.htm"
TITLE="close"
><B
CLASS="xref.cmd"
>close</B
></A
> a filehandle that was never opened.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>connect() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to do a <A
CLASS="xref"
HREF="ch03_020.htm"
TITLE="connect"
><B
CLASS="xref.cmd"
>connect</B
></A
> on a closed socket.  Did you forget
to check the return value of your <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call?  See <A
CLASS="xref"
HREF="ch03_020.htm"
TITLE="connect"
><B
CLASS="xref.cmd"
>connect</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Corrupt malloc ptr </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> at </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <EM
CLASS="emphasis"
>malloc</EM
>(3) package that comes with Perl had an internal failure.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>corrupted regexp pointers</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The regular expression engine got confused by what the regular
expression compiler gave it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>corrupted regexp program</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The regular expression engine got passed a regular expression program
without a valid magic number.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Deep recursion on subroutine &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) This subroutine has called itself (directly or indirectly) 100
more times than it has returned.  This probably indicates an infinite
recursion, unless you're writing strange benchmark programs, in which
case it indicates something else.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Did you mean &amp;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> instead?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You probably referred to an imported subroutine <CODE
CLASS="literal"
>&amp;FOO</CODE
> as
<CODE
CLASS="literal"
>$FOO</CODE
> or some such.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Did you mean $ or @ instead of %?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You probably said <CODE
CLASS="literal"
>%hash{$key}</CODE
> when you meant <CODE
CLASS="literal"
>$hash{$key}</CODE
>
or <CODE
CLASS="literal"
>@hash{@keys}</CODE
>.
On the other hand, maybe you just meant <CODE
CLASS="literal"
>%hash</CODE
> and got carried away.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Do you need to predeclare </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) This is an educated guess made in conjunction with the message &quot;<EM
CLASS="emphasis"
>%s</EM
>
<CODE
CLASS="literal"
>found where operator expected</CODE
>&quot;.  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
<A
CLASS="xref"
HREF="ch03_161.htm"
TITLE="sub"
><B
CLASS="xref.cmd"
>sub</B
></A
>, <A
CLASS="xref"
HREF="ch03_106.htm"
TITLE="package"
><B
CLASS="xref.cmd"
>package</B
></A
>, <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>, or <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> statement.  If you're
referencing something that isn't defined yet, you don't actually have
to define the subroutine or package before the current location.  You
can use an empty <CODE
CLASS="literal"
>sub foo;</CODE
> or <CODE
CLASS="literal"
>package FOO;</CODE
> to enter
a &quot;forward&quot; declaration.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Don't know how to handle magic of type '</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>'</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal handling of magical variables has been cursed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>do_study: out of memory</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) This should have been caught by <CODE
CLASS="literal"
>safemalloc()</CODE
> instead.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Duplicate free() ignored</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) An internal routine has called <CODE
CLASS="literal"
>free()</CODE
> on something that had already
been freed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>elseif should be elsif</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) There is no keyword <B
CLASS="emphasis.bold"
>elseif</B
> in Perl because Larry thinks it's
ugly.  Your code will be interpreted as an attempt to call a method
named <CODE
CLASS="literal"
>elseif()</CODE
> for the class returned by the following block.
This is unlikely to do what you want.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>END failed--cleanup aborted</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An untrapped exception was raised while executing an <CODE
CLASS="literal"
>END</CODE
> subroutine.
The interpreter is immediately exited.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Error converting file specification </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Since Perl may have to deal with file
specifications in either VMS or UNIX syntax, it converts them to a
single form when it must operate on them directly.  Either you've
passed an invalid file specification to Perl, or you've found a
case the conversion routines don't handle.  Drat.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Execution of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> aborted due to compilation errors.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The final summary message when a Perl compilation fails.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Exiting eval via </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You are exiting an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> by unconventional means, such as
a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>, or a loop control statement.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Exiting subroutine via </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You are exiting a subroutine by unconventional means, such as
a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>, or a loop control statement.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Exiting substitution via </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You are exiting a substitution by unconventional means, such as
a <A
CLASS="xref"
HREF="ch03_125.htm"
TITLE="return"
><B
CLASS="xref.cmd"
>return</B
></A
>, a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>, or a loop control statement.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Fatal VMS error at </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>, line </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  Something untoward happened in a VMS
system service or RTL routine; Perl's exit status should provide more
details.  The filename in <EM
CLASS="emphasis"
>%s</EM
> and the line number in
<EM
CLASS="emphasis"
>%d</EM
> tell you which section of the Perl source code is
distressed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>fcntl is not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your machine apparently doesn't implement <EM
CLASS="emphasis"
>fcntl</EM
>(2).  What is this, a
PDP-11 or something?</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Filehandle </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> never opened</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) An I/O operation was attempted on a filehandle that was never initialized.
You need to do an <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> or a <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call, or call a constructor from
the FileHandle package.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Filehandle </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> opened only for input</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to write on a read-only filehandle.  If you intended it to
be a read-write filehandle, you needed to open it with <CODE
CLASS="literal"
>+&lt;</CODE
> or
<CODE
CLASS="literal"
>+&gt;</CODE
> or <CODE
CLASS="literal"
>+&gt;&gt;</CODE
> instead of with <CODE
CLASS="literal"
>&lt;</CODE
> or nothing.  If you
only intended to write the file, use <CODE
CLASS="literal"
>&gt;</CODE
> or <CODE
CLASS="literal"
>&gt;&gt;</CODE
>.  See
<A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Filehandle only opened for input</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to write on a read-only filehandle.  If you intended it to
be a read-write filehandle, you needed to open it with <CODE
CLASS="literal"
>+&lt;</CODE
> or
<CODE
CLASS="literal"
>+&gt;</CODE
> or <CODE
CLASS="literal"
>+&gt;&gt;</CODE
> instead of with <CODE
CLASS="literal"
>&lt;</CODE
> or nothing.  If you
only intended to write the file, use <CODE
CLASS="literal"
>&gt;</CODE
> or <CODE
CLASS="literal"
>&gt;&gt;</CODE
>.  See
<A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Final $ should be \$ or $name</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You must now decide whether the final <CODE
CLASS="literal"
>$</CODE
> in a string was meant to be
a literal dollar sign, or was meant to introduce a variable name
that happens to be missing.  So you have to add either the backslash or
the name.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Final @ should be \@ or @name</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You must now decide whether the final <CODE
CLASS="literal"
>@</CODE
> in a string was
meant to be a literal &quot;at&quot; sign, or was meant to introduce a variable
name that happens to be missing.  So you have to add either the
backslash or the name.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Format </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> redefined</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You redefined a format.  To suppress this warning, say</P
><PRE
CLASS="programlisting"
>{
    local $^W = 0;
    eval &quot;format <CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
> =...&quot;;
}</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Format not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.  If you think you
have such a line, make sure there are no spaces or tabs on either side
of the dot.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Found = in conditional, should be ==</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You said</P
><PRE
CLASS="programlisting"
>if ($foo = 123)</PRE
><P
CLASS="para"
>when you meant</P
><PRE
CLASS="programlisting"
>if ($foo == 123)</PRE
><P
CLASS="para"
>(or something like that).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>gdbm store returned </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
>, errno </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
>, key &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A warning from the GDBM_File extension module that a <CODE
CLASS="literal"
>store()</CODE
> failed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>gethostent not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your C library apparently doesn't implement <EM
CLASS="emphasis"
>gethostent</EM
>(3), probably
because if it did, it'd feel morally obligated to return every hostname
on the Internet.  DNS tends to give machines a sense of grandeur.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>get{sock,peer}name() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to get a socket or peer socket name on a closed socket.
Did you forget to check the return value of your <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call?</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>getpwnam returned invalid UIC </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> for user &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A warning peculiar to VMS.  The call to <CODE
CLASS="literal"
>sys$getuai</CODE
>
underlying the <A
CLASS="xref"
HREF="ch03_062.htm"
TITLE="getpwnam"
><B
CLASS="xref.cmd"
>getpwnam</B
></A
> function
returned an invalid UIC.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Glob not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and not
finding it.  Chances are you left out some needed parentheses earlier in
the line, and you really meant a &quot;less than&quot;.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Global symbol &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; requires explicit package name</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You've said <CODE
CLASS="literal"
>use strict vars</CODE
>, which indicates that all
variables must either be lexically scoped (using <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
>), or explicitly
qualified to say which package the global variable is in (using <CODE
CLASS="literal"
>::</CODE
>).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>goto must have label</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Unlike <A
CLASS="xref"
HREF="ch03_099.htm"
TITLE="next"
><B
CLASS="xref.cmd"
>next</B
></A
> or <A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
>, you're not allowed to <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
> an unspecified destination, the opinions
of Elizabethans nothwithstanding.  Go to <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Had to create </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> unexpectedly</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A routine asked for a symbol from a symbol table that ought to have
existed already, but for some reason it didn't, and had to be created on
an emergency basis to prevent a core dump.  This probably indicates
a typo in an extension module.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Hash %</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> missing the % in argument </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>()</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) Really old Perl let you omit the <CODE
CLASS="literal"
>%</CODE
> on hash names in some
spots.  This is now heavily deprecated.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Illegal division by zero</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to divide a number by <CODE
CLASS="literal"
>0</CODE
>.  Either something was
wrong in your logic, or you need to put a conditional in to guard
against meaningless input.  Maybe both.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Illegal modulus zero</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to divide a number by <CODE
CLASS="literal"
>0</CODE
> to get the remainder.
Most numbers don't take to this kindly.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Illegal octal digit</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You used an <CODE
CLASS="literal"
>8</CODE
> or <CODE
CLASS="literal"
>9</CODE
> in a octal number.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Illegal octal digit ignored</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You may have tried to use an <CODE
CLASS="literal"
>8</CODE
> or <CODE
CLASS="literal"
>9</CODE
> in a octal
number.  Interpretation of the octal number stopped before the <CODE
CLASS="literal"
>8</CODE
>
or <CODE
CLASS="literal"
>9</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Insecure dependency in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to do something that the tainting mechanism didn't like. 
The tainting mechanism is turned on when you're running setuid or setgid,
or when you specify <B
CLASS="emphasis.bold"
>-T</B
> to turn it on explicitly.  The tainting mechanism
labels all data that's derived directly or indirectly from the user,
who is considered to be unworthy of your trust.  If any such data is
used in a &quot;dangerous&quot; operation, you get this error.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Insecure directory in </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't use <A
CLASS="xref"
HREF="ch03_167.htm"
TITLE="system"
><B
CLASS="xref.cmd"
>system</B
></A
>, <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
>, or a piped <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> in a
setuid or setgid script if <CODE
CLASS="literal"
>$ENV{PATH}</CODE
> contains a directory that
is writable by the world.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Insecure PATH</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't use <A
CLASS="xref"
HREF="ch03_167.htm"
TITLE="system"
><B
CLASS="xref.cmd"
>system</B
></A
>, <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
>, or a piped <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> in a
setuid or setgid script if <CODE
CLASS="literal"
>$ENV{PATH}</CODE
> is derived from data
supplied (or potentially supplied) by the user.  The script must set the
path to a known value, using trustworthy data.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Internal inconsistency in tracking vforks</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A warning peculiar to VMS.  Perl keeps track of the number
of times you've called <A
CLASS="xref"
HREF="ch03_040.htm"
TITLE="fork"
><B
CLASS="xref.cmd"
>fork</B
></A
> and <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
>, in order to determine
whether the current call to <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
> should affect the current
script or a subprocess (see <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
>).  Somehow, this count
has become scrambled, so Perl is making a guess and treating
this <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
> as a request to terminate the Perl script
and execute the specified command.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>internal disaster in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Something went badly wrong in the regular expression parser.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>internal urp in regexp at /</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>/</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Something went badly awry in the regular expression parser.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>invalid [] range in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The range specified in a character class had a minimum character
greater than the maximum character.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>ioctl is not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your machine apparently doesn't implement <EM
CLASS="emphasis"
>ioctl</EM
>(2), which is pretty
strange for a machine that supports C.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>junk on end of regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The regular expression parser is confused.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Label not found for &quot;last </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You named a loop to break out of, but you're not currently in a
loop of that name, not even if you count where you were called from.
See <A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Label not found for &quot;next </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You named a loop to continue, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
<A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Label not found for &quot;redo </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You named a loop to restart, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
<A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>listen() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to do a <A
CLASS="xref"
HREF="ch03_086.htm"
TITLE="listen"
><B
CLASS="xref.cmd"
>listen</B
></A
> on a closed socket.  Did you forget to check
the return value of your <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call?  See <A
CLASS="xref"
HREF="ch03_086.htm"
TITLE="listen"
><B
CLASS="xref.cmd"
>listen</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Literal @</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> now requires backslash</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) It used to be that Perl would try to guess whether you wanted an
array interpolated or a literal <CODE
CLASS="literal"
>@</CODE
>.  It did this when the string was
first used at run-time.  Now strings are parsed at compile time, and
ambiguous instances of <CODE
CLASS="literal"
>@</CODE
> must be disambiguated, either by putting a
backslash to indicate a literal, or by declaring (or using) the array
within the program before the string (lexically).  (Someday it will simply
assume that any unbackslashed <CODE
CLASS="literal"
>@</CODE
> interpolates an array.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Method for operation </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> not found in package </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> during blessing</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An attempt was made to specify an entry in an overloading table that
somehow doesn't point to a valid method.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Might be a runaway multi-line </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> string starting on line </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) This is an advisory indicating that the previously reported error
may have been caused by a missing delimiter on a string or pattern,
because it eventually ended earlier on the current line.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Misplaced _ in number</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) An underline in a decimal constant wasn't on a three-digit boundary.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Missing $ on loop variable</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Apparently you've been programming in <EM
CLASS="emphasis"
>csh</EM
> too much.  Scalar
variables are always introduced with a <CODE
CLASS="literal"
>$</CODE
> in Perl, unlike in the
shells, where it can vary from one line to the next.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Missing comma after first argument to </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> function</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) While certain functions allow you to specify a filehandle or an
&quot;indirect object&quot; before the argument list, this ain't one of 'em.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Missing operator before </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) This is an educated guess made in conjunction with the message &quot;<EM
CLASS="emphasis"
>%s</EM
>
<CODE
CLASS="literal"
>found where operator expected</CODE
>&quot;.  Often the missing operator is a comma.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Missing right bracket</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer counted more opening curly brackets (braces) than closing ones.
Hint: you'll find the missing one near the place you were last editing.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Missing semicolon on previous line?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) This is an educated guess made in conjunction with the message &quot;<EM
CLASS="emphasis"
>%s</EM
>
<CODE
CLASS="literal"
>found where operator expected</CODE
>&quot;.  Don't automatically put a semicolon on
the previous line just because you saw this message.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Modification of a read-only value attempted</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried, directly or indirectly, to change the value of a
constant.  You didn't, of course, try <CODE
CLASS="literal"
>2 = 1</CODE
>, since the compiler
catches that.  But an easy way to do the same thing is:</P
><PRE
CLASS="programlisting"
>sub mod { $_[0] = 1 }
mod(2);</PRE
><P
CLASS="para"
>Another way is to assign to a <A
CLASS="xref"
HREF="ch03_162.htm"
TITLE="substr"
><B
CLASS="xref.cmd"
>substr</B
></A
> that's off the end of the string.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Modification of non-creatable array value attempted, subscript </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to make an array value spring into existence, and the
subscript was probably negative, even counting from end of the array
backwards.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Modification of non-creatable hash value attempted, subscript &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to make a hash value spring into existence, and it couldn't
be created for some peculiar reason.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Module name must be constant</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Only a bare module name is allowed as the first argument to a <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
>.
If you want to get fancier than that, call <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
> within a <CODE
CLASS="literal"
>BEGIN</CODE
> block.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>msg</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You don't have System V message IPC on your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Multidimensional syntax </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> not supported</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) Multidimensional arrays aren't written like <CODE
CLASS="literal"
>$foo[1,2,3]</CODE
>.  They're written
like <CODE
CLASS="literal"
>$foo</CODE
>[1][2][3], as in C.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Negative length</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to do a <A
CLASS="xref"
HREF="ch03_116.htm"
TITLE="read"
><B
CLASS="xref.cmd"
>read</B
></A
>/<A
CLASS="xref"
HREF="ch03_193.htm"
TITLE="write"
><B
CLASS="xref.cmd"
>write</B
></A
>/<A
CLASS="xref"
HREF="ch03_139.htm"
TITLE="send"
><B
CLASS="xref.cmd"
>send</B
></A
>/<A
CLASS="xref"
HREF="ch03_119.htm"
TITLE="recv"
><B
CLASS="xref.cmd"
>recv</B
></A
>
operation with a buffer length that is less than <CODE
CLASS="literal"
>0</CODE
>.  This is
difficult to imagine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>nested *?+ in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't quantify a quantifier without intervening parens.  So things like
<CODE
CLASS="literal"
>**</CODE
> or <CODE
CLASS="literal"
>+*</CODE
> or <CODE
CLASS="literal"
>?*</CODE
> are
illegal, because you can't match things as many times
as you want.</P
><P
CLASS="para"
>Note, however, that the minimal matching quantifiers, <CODE
CLASS="literal"
>*?</CODE
>,
<CODE
CLASS="literal"
>+?</CODE
>, and <CODE
CLASS="literal"
>??</CODE
>, appear to be nested quantifiers,
but aren't.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No #! line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The setuid emulator requires that scripts have a well-formed <CODE
CLASS="literal"
>#!</CODE
> line
even on machines that don't support the <CODE
CLASS="literal"
>#!</CODE
> construct.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> allowed while running setuid</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Certain operations are deemed to be too insecure for a setuid or setgid
script to even be allowed to attempt.  Generally speaking there will be
another way to do what you want that is, if not secure, at least securable.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No -e allowed in setuid scripts</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A setuid script can't be specified by the user.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No comma allowed after </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A list operator that has a filehandle or &quot;indirect object&quot; is not
allowed to have a comma between that and the following arguments.
Otherwise it'd be just another one of the arguments.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No command into which to pipe on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl handles its own command-line redirection,
and found a | at the end of the command line, so it doesn't know whither
to pipe the output from this command.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No DB::DB routine defined</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The currently executing code was compiled with the <B
CLASS="emphasis.bold"
>-d</B
> switch,
but for some reason the <EM
CLASS="emphasis"
>perl5db.pl</EM
> file (or some facsimile thereof)
didn't define a routine to be called at the beginning of each
statement.  Which is odd, because the file should have been <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>d
automatically, and should have blown up the <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
> if it didn't parse
right.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No dbm on this machine</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) This is counted as an internal error, because every machine should
supply dbm nowadays, since Perl comes with SDBM.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No DBsub routine</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The currently executing code was compiled with the <B
CLASS="emphasis.bold"
>-d</B
> switch,
but for some reason the <EM
CLASS="emphasis"
>perl5db.pl</EM
> file (or some facsimile thereof)
didn't define a <CODE
CLASS="literal"
>DB::sub</CODE
> routine to be called at the beginning of each
ordinary subroutine call.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No error file after 2&gt; or 2&gt;&gt; on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl handles its own command-line redirection,
and found a <CODE
CLASS="literal"
>2&gt;</CODE
> or a <CODE
CLASS="literal"
>2&gt;&gt;</CODE
> on the command line, but can't find the name of the
file to which to write data destined for <CODE
CLASS="literal"
>STDERR</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No input file after &lt; on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl handles its own command-line redirection,
and found a <CODE
CLASS="literal"
>&lt;</CODE
> on the command line, but can't find the name of the file from
which to read data for <CODE
CLASS="literal"
>STDIN</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No output file after &gt; on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl handles its own command-line redirection,
and found a lone <CODE
CLASS="literal"
>&gt;</CODE
> at the end of the command line, so it doesn't know whither
you wanted to redirect <CODE
CLASS="literal"
>STDOUT</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No output file after &gt; or &gt;&gt; on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl handles its own command-line redirection,
and found a <CODE
CLASS="literal"
>&gt;</CODE
> or a <CODE
CLASS="literal"
>&gt;&gt;</CODE
> on the command line, but can't find the name of the
file to which to write data destined for <CODE
CLASS="literal"
>STDOUT</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No Perl script found in input</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You called <CODE
CLASS="literal"
>perl -x</CODE
>, but no line was found in the file beginning
with <CODE
CLASS="literal"
>#!</CODE
> and containing the word &quot;<CODE
CLASS="literal"
>perl</CODE
>&quot;.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No setregid available</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) <EM
CLASS="emphasis"
>Configure</EM
> didn't find anything resembling the <EM
CLASS="emphasis"
>setregid</EM
>(2) call for
your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No setreuid available</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) <EM
CLASS="emphasis"
>Configure</EM
> didn't find anything resembling the <EM
CLASS="emphasis"
>setreuid</EM
>(2) call for
your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No space allowed after -I</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The argument to <B
CLASS="emphasis.bold"
>-I</B
> must follow the
<B
CLASS="emphasis.bold"
>-I</B
> immediately with no intervening space.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No such pipe open</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An error peculiar to VMS.  The internal routine <CODE
CLASS="literal"
>my_pclose()</CODE
>
tried to close a pipe that hadn't been opened.  This should have been
caught earlier as an attempt to close an unopened filehandle.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>No such signal: SIG</CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You specified a signal name as a subscript to <B
CLASS="emphasis.bold"
>%SIG</B
> that was
not recognized.  Say <CODE
CLASS="literal"
>kill -l</CODE
> in your shell to see the valid
signal names on your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a CODE reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
> function to find out what kind of reference it really was.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a format reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) I'm not sure how you managed to generate a reference to an anonymous
format, but this indicates you did, and that it didn't exist.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a GLOB reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to evaluate a reference to a typeglob (that is,
a symbol table entry that looks like <CODE
CLASS="literal"
>*foo</CODE
>), but found a reference to
something else instead.  You can use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
> function to find out
what kind of reference it really was.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a HASH reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to evaluate a reference to a hash value, but
found a reference to something else instead.  You can use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
>
function to find out what kind of reference it really was.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a perl script</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The setuid emulator requires that scripts have a well-formed <CODE
CLASS="literal"
>#!</CODE
> line
even on machines that don't support the <CODE
CLASS="literal"
>#!</CODE
> construct.  The line must
mention &quot;<CODE
CLASS="literal"
>perl</CODE
>&quot;.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a SCALAR reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to evaluate a reference to a scalar value, but
found a reference to something else instead.  You can use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
>
function to find out what kind of reference it really was.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a subroutine reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
> function to find out what kind of reference it really was.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not a subroutine reference in %OVERLOAD</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An attempt was made to specify an entry in an overloading table that
somehow doesn't point to a valid subroutine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not an ARRAY reference</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl was trying to evaluate a reference to an array value, but
found a reference to something else instead.  You can use the <A
CLASS="xref"
HREF="ch03_121.htm"
TITLE="ref"
><B
CLASS="xref.cmd"
>ref</B
></A
>
function to find out what kind of reference it really was.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not enough arguments for </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The function requires more arguments than you specified.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Not enough format arguments</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A format specified more picture fields than the subsequent values
line supplied.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Null filename used</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
> the null filename, especially since on many machines
that means the current directory!  See <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>NULL OP IN RUN</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Some internal routine called <CODE
CLASS="literal"
>run()</CODE
> with a null opcode pointer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Null realloc</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An attempt was made to <EM
CLASS="emphasis"
>realloc</EM
>(3) <CODE
CLASS="literal"
>NULL</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>NULL regexp argument</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal pattern-matching routines blew it bigtime.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>NULL regexp parameter</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal pattern-matching routines are out of their gourd.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Odd number of elements in hash list</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) You specified an odd number of elements to a hash list, which is odd,
since hash lists come in key/value pairs.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>oops: oopsAV</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) An internal warning that the grammar is screwed up.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>oops: oopsHV</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) An internal warning that the grammar is screwed up.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Operation `</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>' </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>: no method found</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An attempt was made to use an entry in an overloading table that
somehow no longer points to a valid method.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Operator or semicolon missing before </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) You used a variable or subroutine call where the parser was
expecting an operator.  The parser has assumed you really meant
to use an operator, but this is highly unlikely to be correct.
For example, if you say <CODE
CLASS="literal"
>*foo *foo</CODE
> it will be interpreted as
if you said <CODE
CLASS="literal"
>*foo * 'foo'</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Out of memory for yacc stack</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <EM
CLASS="emphasis"
>byacc</EM
> parser wanted to grow its stack so it could continue
parsing, but <EM
CLASS="emphasis"
>realloc</EM
>(3) wouldn't give it more memory, virtual or
otherwise.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Out of memory!</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(X) <EM
CLASS="emphasis"
>malloc</EM
>(3) returned <CODE
CLASS="literal"
>0</CODE
>, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>page overflow</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A single call to <A
CLASS="xref"
HREF="ch03_193.htm"
TITLE="write"
><B
CLASS="xref.cmd"
>write</B
></A
> produced more lines than can fit on a page.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: ck_grep</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Failed an internal consistency check trying to compile a <A
CLASS="xref"
HREF="ch03_072.htm"
TITLE="grep"
><B
CLASS="xref.cmd"
>grep</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: ck_split</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Failed an internal consistency check trying to compile a <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: corrupt saved stack index</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The savestack was requested to restore more localized values than there
are in the savestack.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: die </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) We popped the context stack to an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> context, and then discovered
it wasn't an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> context.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: do_match</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal <CODE
CLASS="literal"
>pp_match()</CODE
> routine was called with invalid
operational data.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: do_split</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Something terrible went wrong in setting up for the <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: do_subst</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal <CODE
CLASS="literal"
>pp_subst()</CODE
> routine was called with invalid
operational data.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: do_trans</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The internal <CODE
CLASS="literal"
>do_trans()</CODE
> routine was called with invalid
operational data.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: goto</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) We popped the context stack to a context with the specified label,
and then discovered it wasn't a context we know how to do a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
> in.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: INTERPCASEMOD</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The lexer got into a bad state at a character case modifier like
<CODE
CLASS="literal"
>\u</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: INTERPCONCAT</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The lexer got into a bad state parsing a string with brackets.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: last</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) We popped the context stack to a block context, and then discovered
it wasn't a block context.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: leave_scope clearsv</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) A writable lexical variable became read-only somehow within the scope.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: leave_scope inconsistency</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The savestack probably got out of sync.  At any rate, there was an
invalid enum on the top of it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: malloc</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Something requested a negative number of bytes of <EM
CLASS="emphasis"
>malloc</EM
>(3).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: mapstart</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The compiler is screwed up with respect to the <A
CLASS="xref"
HREF="ch03_091.htm"
TITLE="map"
><B
CLASS="xref.cmd"
>map</B
></A
> function.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: null array</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) One of the internal array routines was passed a null AV pointer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_alloc</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The compiler got confused about which scratchpad it was allocating
and freeing temporaries and lexicals from.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_free curpad</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The compiler got confused about which scratchpad it was allocating
and freeing temporaries and lexicals from.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_free po</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An invalid scratchpad offset was detected internally.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_reset curpad</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The compiler got confused about which scratchpad it was allocating
and freeing temporaries and lexicals from.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_sv po</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An invalid scratchpad offset was detected internally.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_swipe curpad</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The compiler got confused about which scratchpad it was allocating
and freeing temporaries and lexicals from.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pad_swipe po</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) An invalid scratchpad offset was detected internally.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: pp_iter</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <B
CLASS="emphasis.bold"
>foreach</B
> iterator got called in a non-loop context frame.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: realloc</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Something requested a negative number of bytes of <EM
CLASS="emphasis"
>realloc</EM
>(3).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: restartop</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) Some internal routine requested a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
> (or something like it), and
didn't supply the destination.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: return</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) We popped the context stack to a subroutine or <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> context, and
then discovered it wasn't a subroutine or <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> context.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: scan_num</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) <CODE
CLASS="literal"
>scan_num()</CODE
> got called on something that wasn't a number.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: sv_insert</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <CODE
CLASS="literal"
>sv_insert()</CODE
> routine was told to remove more string than there
was string.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: top_env</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The compiler attempted to do a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
>, or something weird like that.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>panic: yylex</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The lexer got into a bad state while processing a character case
modifier like <CODE
CLASS="literal"
>\u</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Parens missing around &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; list</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You said something like</P
><PRE
CLASS="programlisting"
>my $foo, $bar = @_;</PRE
><P
CLASS="para"
>when you meant</P
><PRE
CLASS="programlisting"
>my ($foo, $bar) = @_;</PRE
><P
CLASS="para"
>Remember that <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> and <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> bind closer than comma.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Perl </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> required--this is only version </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>, stopped</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The module in question uses features of a version of Perl more recent
than the currently running version.  How long has it been since you upgraded,
anyway?  See <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Permission denied</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The setuid emulator in <EM
CLASS="emphasis"
>suidperl</EM
> decided you were up to no good.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>pid </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> not a child</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A warning peculiar to VMS.  <A
CLASS="xref"
HREF="ch03_190.htm"
TITLE="waitpid"
><B
CLASS="xref.cmd"
>waitpid</B
></A
> was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS's perspective, it's probably not what you intended.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>POSIX getpgrp can't take an argument</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your C compiler uses POSIX <EM
CLASS="emphasis"
>getpgrp</EM
>(2), which takes no
argument, unlike the BSD version, which takes a <EM
CLASS="emphasis"
>pid</EM
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Possible memory corruption: </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> overflowed 3rd argument</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An <EM
CLASS="emphasis"
>ioctl</EM
>(2) or <EM
CLASS="emphasis"
>fcntl</EM
>(2) returned more than Perl was
bargaining for.  Perl guesses a reasonable buffer size, but puts a
sentinel byte at the end of the buffer just in case.  This sentinel byte
got clobbered, and Perl assumes that memory is now corrupted.  You can
try to trap this with <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>, but remember your <EM
CLASS="emphasis"
>malloc</EM
> arena
may have been clobbered.  Expect your program to dump core soon.  If
you're lucky, it won't set fire to the laser printer first.  See
<A
CLASS="xref"
HREF="ch03_077.htm"
TITLE="ioctl"
><B
CLASS="xref.cmd"
>ioctl</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Precedence problem: open </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> should be open(</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The old irregular construct</P
><PRE
CLASS="programlisting"
>open FOO || die;</PRE
><P
CLASS="para"
>is now misinterpreted as</P
><PRE
CLASS="programlisting"
>open(FOO || die);</PRE
><P
CLASS="para"
>because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> was a little of both.) You must put
parens around the filehandle, or use the new <B
CLASS="emphasis.bold"
>or</B
> operator instead of
<CODE
CLASS="literal"
>||</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>print on closed filehandle </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The filehandle you're printing on got itself closed sometime before now.
Check your logic flow.  It may have flowed away.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>printf on closed filehandle </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.  See previous joke.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Probable precedence problem on </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The compiler found a bare word where it expected a conditional,
which often indicates that an <CODE
CLASS="literal"
>||</CODE
> or <CODE
CLASS="literal"
>&amp;&amp;</CODE
> was parsed as part of the
last argument of the previous construct, for example:</P
><PRE
CLASS="programlisting"
>open FOO || die;</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Prototype mismatch: (</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>) vs (</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The subroutine being defined had a predeclared (forward) declaration
with a different function prototype.  The prototypes must match.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Read on closed filehandle &lt;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&gt;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The filehandle you're reading from got itself closed sometime before now.
Check your logic flow.  Don't see the previous joke.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Reallocation too large: </CODE
><EM
CLASS="emphasis"
>%d</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't allocate more than 64K on an MS-DOS machine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Recompile perl with -DDEBUGGING to use -D switch</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You can't use the <B
CLASS="emphasis.bold"
>-D</B
> option unless the
code to produce the 
desired output is compiled into <EM
CLASS="emphasis"
>perl</EM
>, which entails some overhead,
which is why it's currently left out of your copy.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Recursive inheritance detected</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) More than 100 levels of inheritance were used.  Probably indicates
an unintended loop in your inheritance hierarchy.  Use <CODE
CLASS="literal"
>-Do</CODE
> to trace
object method lookups.  (But see previous entry.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Reference miscount in sv_replace()</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The internal <CODE
CLASS="literal"
>sv_replace()</CODE
> function was handed a new SV with a
reference count of other than <CODE
CLASS="literal"
>1</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>regexp memory corruption</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The regular expression engine got confused by what the regular
expression compiler gave it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>regexp out of space</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) A &quot;can't happen&quot; error, because <CODE
CLASS="literal"
>safemalloc()</CODE
> should have
caught it earlier.  If it didn't, your Perl is misconfigured.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>regexp too big</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The current implementation of regular expression uses 16-bit shorts as
address offsets within a string.  Unfortunately this means that if
the regular expression compiles to longer than 32767 bytes, it'll blow up.
Usually when you want a regular expression this big, there is a better
way to do it with multiple statements.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Reversed </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>= operator</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You wrote your assignment operator backward.  The <CODE
CLASS="literal"
>=</CODE
> must always
come last, to avoid ambiguity with subsequent unary operators.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Runaway format</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your format contained the <CODE
CLASS="literal"
>~~</CODE
> repeat-until-blank sequence,
but it produced 200 lines at once, and the 200th line looked exactly
like the 199th line.  Apparently you didn't arrange for the arguments to
exhaust themselves, either by using <CODE
CLASS="literal"
>^</CODE
> instead of <CODE
CLASS="literal"
>@</CODE
> (for
scalar variables), or by shifting or popping (for array variables).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Scalar value @</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>[</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>] better written as $</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>[</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>]</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You've used an array slice (indicated by <CODE
CLASS="literal"
>@</CODE
>) to select a
single value of an array.  Generally it's better to ask for a scalar
value (indicated by <CODE
CLASS="literal"
>$</CODE
>).  The difference is that
<CODE
CLASS="literal"
>$foo[&amp;bar]</CODE
> always behaves like a scalar, both when assigning to
it and when evaluating its argument, while <CODE
CLASS="literal"
>@foo[&amp;bar]</CODE
> behaves
like a list when you assign to it, and provides a list context to its
subscript, which can do weird things if you're only expecting one
subscript.

On the other hand, if you were actually hoping to treat the array
element as a list, you need to look into how references work, since
Perl will not magically convert between scalars and lists for you.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Script is not setuid/setgid in suidperl</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Oddly, the <EM
CLASS="emphasis"
>suidperl</EM
> program was invoked on a script with its setuid
or setgid bit unset.  This doesn't make much sense.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Search pattern not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer couldn't find the final delimiter of a <CODE
CLASS="literal"
>//</CODE
> or <CODE
CLASS="literal"
>m{}</CODE
>
construct.  Remember that bracketing delimiters count nesting level.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>seek() on unopened file</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to use the <A
CLASS="xref"
HREF="ch03_132.htm"
TITLE="seek"
><B
CLASS="xref.cmd"
>seek</B
></A
> function on a filehandle that was either
never opened or has been closed since.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>select not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) This machine doesn't implement the <EM
CLASS="emphasis"
>select</EM
>(2) system call.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>sem</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You don't have System V semaphore IPC on your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>semi-panic: attempt to dup freed string</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The internal <CODE
CLASS="literal"
>newSVsv()</CODE
> routine was called to duplicate a scalar
that had previously been marked as free.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Semicolon seems to be missing</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A nearby syntax error was probably caused by a missing semicolon,
or possibly some other missing operator, such as a comma.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Send on closed socket</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The filehandle you're sending to got itself closed sometime before now.
Check your logic flow.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Sequence (?#... not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  But with the <B
CLASS="emphasis.bold"
>/x</B
> modifier you can use an ordinary
comment starting with <CODE
CLASS="literal"
>#</CODE
>, which doesn't care.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Sequence (?</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>...) not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A proposed regular expression extension has the character reserved
but has not yet been written.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Sequence (?</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>...) not recognized</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You used a regular expression extension that doesn't make sense.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Server error</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) Also known as &quot;<CODE
CLASS="literal"
>500 Server error</CODE
>&quot;.  This is a CGI
error, not a Perl
error.  You need to make sure your script is executable, is accessible
by the user CGI is running the script under (which is probably not
the user account you tested it under), does not rely on any environment
variables (like <CODE
CLASS="literal"
>PATH</CODE
>) from the user it isn't running under, and isn't
in a location where the CGI server can't find it, basically, more or less.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>setegid() not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to assign to <B
CLASS="emphasis.bold"
>$)</B
>, and your operating system doesn't support
the <EM
CLASS="emphasis"
>setegid</EM
>(2) system call (or equivalent), or at least <EM
CLASS="emphasis"
>Configure</EM
> didn't
think so.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>seteuid() not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to assign to <B
CLASS="emphasis.bold"
>$&gt;</B
>, and your operating system doesn't support
the <EM
CLASS="emphasis"
>seteuid</EM
>(2) system call (or equivalent), or at least <EM
CLASS="emphasis"
>Configure</EM
> didn't
think so.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>setrgid() not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to assign to <B
CLASS="emphasis.bold"
>$(</B
>, and your operating system doesn't support
the <EM
CLASS="emphasis"
>setrgid</EM
>(2) system call (or equivalent), or at least <EM
CLASS="emphasis"
>Configure</EM
> didn't
think so.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>setruid() not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to assign to <B
CLASS="emphasis.bold"
>$&lt;</B
>, and your operating system doesn't support
the <EM
CLASS="emphasis"
>setruid</EM
>(2) system call (or equivalent), or at least <EM
CLASS="emphasis"
>Configure</EM
> didn't
think so.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Setuid/gid script is writable by world</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The setuid emulator won't run a script that is writable by the world,
because the world might have written on it already.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>shm</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You don't have System V shared memory IPC on your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>shutdown() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to do a <A
CLASS="xref"
HREF="ch03_148.htm"
TITLE="shutdown"
><B
CLASS="xref.cmd"
>shutdown</B
></A
> on a closed socket.  Seems a bit
superfluous.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>SIG</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> handler &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; not defined.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The signal handler named in <B
CLASS="emphasis.bold"
>%SIG</B
> doesn't, in
fact, exist. Perhaps you put it into the wrong package?</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>sort is now a reserved word</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An ancient error message that almost nobody ever runs into anymore.
But before <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> was a keyword, people sometimes used it as a filehandle.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Sort subroutine didn't return a numeric value</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> comparison routine must return a number.  You probably blew
it by not using <CODE
CLASS="literal"
>&lt;=&gt;</CODE
> or <B
CLASS="emphasis.bold"
>cmp</B
>, or by not using them correctly.
See <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Sort subroutine didn't return single value</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> comparison subroutine may not return a list value with more
or less than one element.  See <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Split loop</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
> was looping infinitely.  (Obviously, a <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>
shouldn't iterate more times than there are characters of input, which
is what happened.)  See <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Stat on unopened file </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to use the <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
> function (or an equivalent file test)
on a filehandle that was either never opened or has been closed since.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Statement unlikely to be reached</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You did an <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
> with some statement after it other than a <A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
>.
This is almost always an error, because <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
> never returns unless
there was a failure.  You probably wanted to use <A
CLASS="xref"
HREF="ch03_167.htm"
TITLE="system"
><B
CLASS="xref.cmd"
>system</B
></A
> instead,
which does return.  To suppress this warning, put the <A
CLASS="xref"
HREF="ch03_033.htm"
TITLE="exec"
><B
CLASS="xref.cmd"
>exec</B
></A
> in a block
by itself.  Or put a <A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
> after it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Subroutine </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> redefined</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You redefined a subroutine.  To suppress this warning, say</P
><PRE
CLASS="programlisting"
>{
    local $^W = 0;
    eval &quot;sub name { ... }&quot;;
}</PRE
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Substitution loop</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(P) The substitution was looping infinitely.  (Obviously, a
substitution shouldn't iterate more times than there are characters of
input, which is what happened.)
See the discussion of substitution in the section &quot;Pattern-Matching Operators&quot; in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Substitution pattern not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer couldn't find the interior delimiter of an <CODE
CLASS="literal"
>s///</CODE
> or
<CODE
CLASS="literal"
>s{}{}</CODE
> construct.  Remember that bracketing delimiters count
nesting level.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Substitution replacement not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer couldn't find the final delimiter of an <CODE
CLASS="literal"
>s///</CODE
> or
<CODE
CLASS="literal"
>s{}{}</CODE
> construct.  Remember that bracketing delimiters count
nesting level.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>substr outside of string</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to reference a <A
CLASS="xref"
HREF="ch03_162.htm"
TITLE="substr"
><B
CLASS="xref.cmd"
>substr</B
></A
> that pointed outside of a string.
That is, the absolute value of the offset was larger than the length of
the string.  See <A
CLASS="xref"
HREF="ch03_162.htm"
TITLE="substr"
><B
CLASS="xref.cmd"
>substr</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>suidperl is no longer needed since...</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your <EM
CLASS="emphasis"
>perl</EM
> was compiled with <CODE
CLASS="literal"
>-DSETUID_SCRIPTS_ARE_SECURE_NOW</CODE
>,
but a version of the setuid emulator somehow got run anyway.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>syntax error</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Probably means you had a syntax error.  Common reasons include:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>A keyword is misspelled.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A semicolon is missing.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A comma is missing.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An opening or closing parenthesis is missing.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>An opening or closing brace is missing.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>A closing quote is missing.</P
></LI
></UL
><P
CLASS="para"
>Often there will be another error message associated with the syntax
error giving more information.  (Sometimes it helps to turn on <B
CLASS="emphasis.bold"
>-w</B
>.)
The error message itself often tells you where it was in the line when
it decided to give up.  Sometimes the actual error is several tokens
before this, since Perl is good at understanding random input.
Occasionally the line number may be misleading, and once in a blue moon
the only way to figure out what's triggering the error is to call
<EM
CLASS="emphasis"
>perl -c</EM
> repeatedly, chopping away half the program each time to see
if the error went away.  Sort of the cybernetic version of 20 Questions.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>syntax error at line </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
>: `</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>' unexpected</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through the Bourne shell instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>System V IPC is not implemented on this machine</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You tried to do something with a function beginning with <B
CLASS="emphasis.bold"
>sem</B
>,
<B
CLASS="emphasis.bold"
>shm</B
> or <B
CLASS="emphasis.bold"
>msg</B
>.  See <A
CLASS="xref"
HREF="ch03_136.htm"
TITLE="semctl"
><B
CLASS="xref.cmd"
>semctl</B
></A
>, for example.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Syswrite on closed filehandle</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.  If you're tired of that, check someone else's.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>tell() on unopened file</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to use the <A
CLASS="xref"
HREF="ch03_169.htm"
TITLE="tell"
><B
CLASS="xref.cmd"
>tell</B
></A
> function on a filehandle that was either
never opened or has been closed since.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Test on unopened file </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to invoke a file test operator on a filehandle that isn't
open.  Check your logic.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>That use of $[ is unsupported</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Assignment to <B
CLASS="emphasis.bold"
>$[</B
> is now strictly circumscribed, and interpreted as
a compiler directive.  You may only say one of</P
><PRE
CLASS="programlisting"
>$[ = 0;
$[ = 1;
...
local $[ = 0;
local $[ = 1;
...</PRE
><P
CLASS="para"
>This is to prevent the problem of one module changing the array base
out from under another module inadvertently.
See the section on <B
CLASS="emphasis.bold"
>$[</B
> in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>The </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> function is unimplemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The function indicated isn't implemented on this architecture, according
to the probings of <EM
CLASS="emphasis"
>Configure</EM
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>The crypt() function is unimplemented due to excessive paranoia.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) <EM
CLASS="emphasis"
>Configure</EM
> couldn't find the <EM
CLASS="emphasis"
>crypt</EM
>(3) function on your machine,
probably because your vendor didn't supply it, probably because they
think the U.S. government thinks it's a secret, or at least that they
will continue to pretend that it is.  And if you quote me on that, I
will deny it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>The stat preceding -l _ wasn't an lstat</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) It makes no sense to test the current stat buffer for symbolic linkhood
if the last <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
> that wrote to the stat buffer already went past
the symlink to get to the real file.  Use an actual filename instead.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>times not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your version of the C library apparently doesn't do <EM
CLASS="emphasis"
>times</EM
>(3).
I suspect you're not running on UNIX.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Too few args to syscall</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) There has to be at least one argument to <A
CLASS="xref"
HREF="ch03_164.htm"
TITLE="syscall"
><B
CLASS="xref.cmd"
>syscall</B
></A
> to specify the
system call to call, silly dilly.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Too many ('s</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Too many )'s</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through <EM
CLASS="emphasis"
>csh</EM
> instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Too many args to syscall</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Perl supports a maximum of 14 args to <A
CLASS="xref"
HREF="ch03_164.htm"
TITLE="syscall"
><B
CLASS="xref.cmd"
>syscall</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Too many arguments for </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The function requires fewer arguments than you specified.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>trailing \ in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The regular expression ends with an unbackslashed backslash.  Backslash
it.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Translation pattern not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer couldn't find the interior delimiter of a <CODE
CLASS="literal"
>tr///</CODE
> or
<CODE
CLASS="literal"
>tr[][]</CODE
> construct.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Translation replacement not terminated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer couldn't find the final delimiter of a <CODE
CLASS="literal"
>tr///</CODE
> or
<CODE
CLASS="literal"
>tr[][]</CODE
> construct.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>truncate not implemented</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your machine doesn't implement a file truncation mechanism that
<EM
CLASS="emphasis"
>Configure</EM
> knows about.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Type of arg </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> to </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> must be </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> (not </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) This function requires the argument in that position to be of a
certain type.  Arrays must be <CODE
CLASS="literal"
>@NAME</CODE
> or
<CODE
CLASS="literal"
>@{</CODE
><CODE
CLASS="replaceable"
><I
>EXPR</I
></CODE
><CODE
CLASS="literal"
>}</CODE
>.  Hashes must be <CODE
CLASS="literal"
>%NAME</CODE
> or
<CODE
CLASS="literal"
>%{</CODE
><CODE
CLASS="replaceable"
><I
>EXPR</I
></CODE
><CODE
CLASS="literal"
>}</CODE
>.  No implicit dereferencing is
allowed&nbsp;- use the <CODE
CLASS="literal"
>{</CODE
><CODE
CLASS="replaceable"
><I
>EXPR</I
></CODE
><CODE
CLASS="literal"
>}</CODE
> forms as an explicit
dereference.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>umask: argument is missing initial 0</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A umask of <CODE
CLASS="literal"
>222</CODE
> is incorrect.  It should be <CODE
CLASS="literal"
>0222</CODE
>,
since octal literals always start with <CODE
CLASS="literal"
>0</CODE
> in Perl, as in C.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unable to create sub named &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You attempted to create or access a subroutine with an illegal name.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unbalanced context: </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> more PUSHes than POPs</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The exit code detected an internal inconsistency in how many execution
contexts were entered and left.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unbalanced saves: </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> more saves than restores</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The exit code detected an internal inconsistency in how many
values were temporarily localized.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unbalanced scopes: </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> more ENTERs than LEAVEs</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The exit code detected an internal inconsistency in how many blocks
were entered and left.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unbalanced tmps: </CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> more allocs than frees</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The exit code detected an internal inconsistency in how many mortal
scalars were allocated and freed.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Undefined format &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_041.htm"
TITLE="format"
><B
CLASS="xref.cmd"
>format</B
></A
> indicated doesn't seem to exist.  Perhaps it's really in
another package?</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Undefined sort subroutine &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> comparison routine specified doesn't seem to exist.  Perhaps
it's in a different package?  See <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Undefined subroutine &amp;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The subroutine indicated hasn't been defined, or if it was, it
has since been undefined.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Undefined subroutine called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The anonymous subroutine you're trying to call hasn't been defined,
or if it was, it has since been undefined.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Undefined subroutine in sort</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> comparison routine specified is declared but doesn't seem to
have been defined yet.  See <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Undefined top format &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <A
CLASS="xref"
HREF="ch03_041.htm"
TITLE="format"
><B
CLASS="xref.cmd"
>format</B
></A
> indicated doesn't seem to exist.  Perhaps it's really in
another package?</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>unexec of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> into </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> failed!</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The <CODE
CLASS="literal"
>unexec()</CODE
> routine failed for some reason.
See your local FSF
representative, who probably put it there in the first place.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unknown BYTEORDER</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) There are no byteswapping functions for a machine with this byte order.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>unmatched () in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Unbackslashed parentheses must always be balanced in regular
expressions.  If you're a <EM
CLASS="emphasis"
>vi</EM
> user, the <CODE
CLASS="literal"
>%</CODE
> key is valuable
for finding the matching parenthesis.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unmatched right bracket</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer counted more closing curly brackets (braces) than opening
ones, so you're probably missing an opening bracket.  As a general
rule, you'll find the missing one (so to speak) near the place you were
last editing.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>unmatched [] in regexp</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The brackets around a character class must match.  If you wish to
include a closing bracket in a character class, backslash it or put it first.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unquoted string &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; may clash with future reserved word</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You used a bareword that might someday be claimed as a reserved word.
It's best to put such a word in quotes, or capitalize it somehow, or insert
an underbar into it.  You might also declare it as a subroutine.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unrecognized character \</CODE
><EM
CLASS="emphasis"
>%d</EM
><CODE
CLASS="literal"
> ignored</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) A garbage character was found in the input, and ignored, in case it's
a weird control character on an EBCDIC machine, or some such.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unrecognized signal name &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You specified a signal name to the <A
CLASS="xref"
HREF="ch03_080.htm"
TITLE="kill"
><B
CLASS="xref.cmd"
>kill</B
></A
> function that was not
recognized.  Say <CODE
CLASS="literal"
>kill -l</CODE
> in your shell to see the valid signal
names on your system.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unrecognized switch: -</CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You specified an illegal option to <EM
CLASS="emphasis"
>perl</EM
>.  Don't do that.
(If you think you <EM
CLASS="emphasis"
>didn't</EM
> do that, check the
<CODE
CLASS="literal"
>#!</CODE
> line to see if it's
supplying the bad switch on your behalf.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unsuccessful </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> on filename containing newline</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) A file operation was attempted on a filename, and that operation
failed, probably because the filename contained a newline, probably
because you forgot to <A
CLASS="xref"
HREF="ch03_014.htm"
TITLE="chop"
><B
CLASS="xref.cmd"
>chop</B
></A
> or <A
CLASS="xref"
HREF="ch03_013.htm"
TITLE="chomp"
><B
CLASS="xref.cmd"
>chomp</B
></A
> it off.
See <A
CLASS="xref"
HREF="ch03_014.htm"
TITLE="chop"
><B
CLASS="xref.cmd"
>chop</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unsupported directory function &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your machine doesn't support <EM
CLASS="emphasis"
>opendir</EM
>(3) and <EM
CLASS="emphasis"
>readdir</EM
>(3).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unsupported function </CODE
><EM
CLASS="emphasis"
>%s</EM
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) This machine doesn't implement the indicated function, apparently.
At least, <EM
CLASS="emphasis"
>Configure</EM
> doesn't think so.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unsupported socket function &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; called</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) Your machine doesn't support the Berkeley socket mechanism, or at
least that's what <EM
CLASS="emphasis"
>Configure</EM
> thought.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Unterminated &lt;&gt; operator</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and not
finding it.  Chances are you left out some needed parentheses earlier in
the line, and you really meant a &quot;less than&quot;.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of $# is deprecated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) This was an ill-advised attempt to emulate a poorly defined <EM
CLASS="emphasis"
>awk</EM
>
feature.  Use an explicit <A
CLASS="xref"
HREF="ch03_111.htm"
TITLE="printf"
><B
CLASS="xref.cmd"
>printf</B
></A
> or <A
CLASS="xref"
HREF="ch03_156.htm"
TITLE="sprintf"
><B
CLASS="xref.cmd"
>sprintf</B
></A
> instead.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of $* is deprecated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) This variable magically turned on multiline pattern matching, both for
you and for any luckless subroutine that you happen to call.  You should
use the new <B
CLASS="emphasis.bold"
>/m</B
> and <B
CLASS="emphasis.bold"
>/s</B
> modifiers now to do
that without the dangerous action-at-a-distance effects of <B
CLASS="emphasis.bold"
>$*</B
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in printf format not supported</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You attempted to use a feature of <A
CLASS="xref"
HREF="ch03_111.htm"
TITLE="printf"
><B
CLASS="xref.cmd"
>printf</B
></A
> that is accessible only
from C.  This usually means there's a better way to do it in Perl.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> is deprecated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) The construct indicated is no longer recommended for use, generally
because there's a better way to do it, and also because the old way has
bad side effects.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of bare &lt;&lt; to mean &lt;&lt;&quot;&quot; is deprecated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) You are now encouraged to use the explicitly quoted form if you
wish to use a blank line as the terminator of the here-document.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of implicit split to @_ is deprecated</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(D) It makes a lot of work for the compiler when you clobber a
subroutine's argument list, so it's better if you assign the results of
a <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
> explicitly to an array (or list).</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Use of uninitialized value</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) An undefined value was used as if it were already defined.  It was
interpreted as a <CODE
CLASS="literal"
>&quot;&quot;</CODE
> or a <CODE
CLASS="literal"
>0</CODE
>, but maybe it was a mistake.
To suppress this warning, assign an initial value to your variables.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Useless use of </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> in void context</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You did something without a side effect in a context that does nothing
with the return value, such as a statement that doesn't return a value
from a block, or the left side of a scalar comma operator.  Very often
this points not to stupidity on your part, but a failure of Perl to parse
your program the way you thought it would.  For example, you'd get this
if you mixed up your C precedence with Python precedence and said</P
><PRE
CLASS="programlisting"
>$one, $two = 1, 2;</PRE
><P
CLASS="para"
>when you meant to say</P
><PRE
CLASS="programlisting"
>($one, $two) = (1, 2);</PRE
><P
CLASS="para"
>Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say</P
><PRE
CLASS="programlisting"
>$array = (1,2);</PRE
><P
CLASS="para"
>when you should have said</P
><PRE
CLASS="programlisting"
>$array = [1,2];</PRE
><P
CLASS="para"
>The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Variable &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; is not exported</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) While <CODE
CLASS="literal"
>use strict</CODE
> in effect, you referred to a global variable
that you thought was imported from another module, because
something else of the same name (usually a subroutine) is exported
by that module.  It usually means you put the wrong funny character
on the front of your variable.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Variable name &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>::</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; used only once: possible typo</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) Typographical errors often show up as unique names.  If you
had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  You might consider declaring
the variable with <CODE
CLASS="literal"
>use vars</CODE
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Variable syntax.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(A) You've accidentally run your script through <EM
CLASS="emphasis"
>csh</EM
> instead
of <EM
CLASS="emphasis"
>perl</EM
>.  Check the <CODE
CLASS="literal"
>#!</CODE
> line, or manually feed your script
into <EM
CLASS="emphasis"
>perl</EM
> yourself.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Warning: unable to close filehandle </CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
> properly.</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) The implicit <A
CLASS="xref"
HREF="ch03_018.htm"
TITLE="close"
><B
CLASS="xref.cmd"
>close</B
></A
> done by an <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> got an error
indication on the <A
CLASS="xref"
HREF="ch03_018.htm"
TITLE="close"
><B
CLASS="xref.cmd"
>close</B
></A
>.  This usually indicates your filesystem ran out
of disk space.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Warning: Use of &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; without parens is ambiguous</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(S) You wrote a unary operator followed by something that looks like a
binary operator that could also have been interpreted as a term or
unary operator.  For instance, if you know that the <A
CLASS="xref"
HREF="ch03_115.htm"
TITLE="rand"
><B
CLASS="xref.cmd"
>rand</B
></A
> function
has a default argument of 1.0, and you write</P
><PRE
CLASS="programlisting"
>rand + 5;</PRE
><P
CLASS="para"
>you may <EM
CLASS="emphasis"
>think</EM
> you wrote the same thing as</P
><PRE
CLASS="programlisting"
>rand() + 5;</PRE
><P
CLASS="para"
>but in actual fact, you got</P
><PRE
CLASS="programlisting"
>rand(+5);</PRE
><P
CLASS="para"
>So put in parentheses to say what you really mean.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Write on closed filehandle</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) The filehandle you're writing to got itself closed sometime before now.
Check your logic flow.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>X outside of string</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You had a <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
> template that specified a relative position before
the beginning of the string being unpacked.  See <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>x outside of string</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) You had a <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
> template that specified a relative position after
the end of the string being unpacked.  See <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Xsub &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot; called in sort</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The use of an external subroutine as a <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>
comparison is not yet supported.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>Xsub called in sort</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) The use of an external subroutine as a <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>
comparison is not yet supported.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>You can't use -l on a filehandle</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) A filehandle represents an opened file, and when you opened the file it
already went past any symlink you are presumably trying to look for.
Use a filename instead.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) And you probably never will, since you probably don't have the
sources to your kernel, and your vendor probably doesn't give a rip
about what you want.  Your best bet is to use the wrapsuid script in
the <EM
CLASS="emphasis"
>eg/</EM
> directory to put a setuid C wrapper around your script.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>You need to quote &quot;</CODE
><EM
CLASS="emphasis"
>%s</EM
><CODE
CLASS="literal"
>&quot;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You assigned a bareword as a signal handler name.  Unfortunately, you
already have a subroutine of that name declared, which means that Perl 5
will try to call the subroutine when the assignment is executed, which is
probably not what you want.  (If it IS what you want, put an
<CODE
CLASS="literal"
>&amp;</CODE
> in front.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>[gs]etsockopt() on closed fd</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) You tried to get or set a socket option on a closed socket.
Did you forget to check the return value of your <A
CLASS="xref"
HREF="ch03_151.htm"
TITLE="socket"
><B
CLASS="xref.cmd"
>socket</B
></A
> call?
See <A
CLASS="xref"
HREF="ch03_068.htm"
TITLE="getsockopt"
><B
CLASS="xref.cmd"
>getsockopt</B
></A
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>\1 better written as $1</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(W) Outside of patterns, backreferences live on as variables.  The use
of backslashes is grandfathered on the righthand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better
if there are more than nine backreferences.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>'|' and '&lt;' may not both be specified on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl does its own command-line redirection, and
found that <CODE
CLASS="literal"
>STDIN</CODE
> was a pipe, and that you also tried to redirect
<CODE
CLASS="literal"
>STDIN</CODE
> using <CODE
CLASS="literal"
>&lt;</CODE
>.  Only one <CODE
CLASS="literal"
>STDIN</CODE
> stream to a customer,
please.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>'|' and '&gt;' may not both be specified on command line</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>(F) An error peculiar to VMS.  Perl does its own command-line redirection, and
thinks you tried to redirect <CODE
CLASS="literal"
>STDOUT</CODE
>
both to a file and into a pipe to another
command.  You need to choose one or the other, though nothing's stopping you
from piping into a program or Perl script which &quot;splits&quot; output into two
streams, such as</P
><PRE
CLASS="programlisting"
>open(OUT,&quot;&gt;$ARGV[0]&quot;) or die &quot;Can't write to $ARGV[0]: $!&quot;;
while (&lt;STDIN&gt;) {
    print STDOUT;
    print OUT;
}
close OUT;</PRE
></DD
></DL
><A
CLASS="indexterm"
NAME="AUTOID-33327"
></A
><A
CLASS="indexterm"
NAME="AUTOID-33328"
></A
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_07.htm"
TITLE="8.7 History Made Practical"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.7 History Made Practical"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="GLOSSARY"
HREF="glossary.htm"
TITLE="Glossary"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: Glossary"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.7 History Made Practical</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>Glossary</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
