<HTML
><HEAD
>
<TITLE>[Chapter 8] 8.2 Common Goofs for Novices</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T02:06:42Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch08_01.htm"
TITLE="8. Other Oddments"><LINK
REL="prev"
HREF="ch08_01.htm"
TITLE="8.1 The Perl Debugger"><LINK
REL="next"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_01.htm"
TITLE="8.1 The Perl Debugger"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.1 The Perl Debugger"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch08_01.htm"
TITLE="8. Other Oddments"
>Chapter 8<BR>Other Oddments</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.3 Efficiency"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2"
>8.2 Common Goofs for Novices</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.TROUBLE1"
></A
><A
CLASS="indexterm"
NAME="CH08.TROUBLE2"
></A
>The biggest goof of all is forgetting to use the <B
CLASS="emphasis.bold"
>-w</B
> switch, which points out many errors.  The second
biggest goof is not using <CODE
CLASS="literal"
>use strict</CODE
> when it's appropriate.</P
><P
CLASS="para"
>Apart from those, there are certain traps that almost everyone falls into, and
other traps you'll fall into only if you come from a particular culture.  We've
separated these out in the following sections.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.1"
>8.2.1 Universal Blunders</A
></H3
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28630"
></A
>Putting a comma after the filehandle in a <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> statement.
Although it looks extremely regular and pretty to say:</P
><PRE
CLASS="programlisting"
>print STDOUT, &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;    # WRONG</PRE
><P
CLASS="para"
>this is nonetheless incorrect, because of that first comma.  What you
want instead is:</P
><PRE
CLASS="programlisting"
>print STDOUT &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;     # ok</PRE
><P
CLASS="para"
>The syntax is this way so that you can say:</P
><PRE
CLASS="programlisting"
>print $filehandle &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;</PRE
><P
CLASS="para"
>where <CODE
CLASS="literal"
>$filehandle</CODE
> is a scalar holding the name of a filehandle at
run-time.  This is distinct from:</P
><PRE
CLASS="programlisting"
>print $notafilehandle, &quot;goodbye&quot;, $adj, &quot;world!\n&quot;;</PRE
><P
CLASS="para"
>where <CODE
CLASS="literal"
>$notafilehandle</CODE
> is simply a string that is added to the list
of things to be printed.  See Indirect Object in the glossary.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28645"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28648"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28651"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28653"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28655"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28658"
></A
>Using <CODE
CLASS="literal"
>==</CODE
> instead of <B
CLASS="emphasis.bold"
>eq</B
> and <CODE
CLASS="literal"
>!=</CODE
> instead of <B
CLASS="emphasis.bold"
>ne</B
>.  The <CODE
CLASS="literal"
>==</CODE
> and
<CODE
CLASS="literal"
>!=</CODE
> operators are
<EM
CLASS="emphasis"
>numeric</EM
> tests.  The other two are
<EM
CLASS="emphasis"
>string</EM
> tests.  The strings
<CODE
CLASS="literal"
>&quot;123&quot;</CODE
> and <CODE
CLASS="literal"
>&quot;123.00&quot;</CODE
> are
equal as numbers, but not equal as strings.  Also, any non-numeric
string is numerically equal to zero.  Unless you are dealing with
numbers, you almost always want the string comparison operators
instead.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-28673"
></A
>
Forgetting the trailing semicolon. Every statement in
Perl is terminated by a semicolon or the end of a block.  Newlines
aren't statement terminators as they are in <EM
CLASS="emphasis"
>awk</EM
>
or Python.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28678"
></A
>Forgetting that a <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
> requires braces.  Naked
statements are not <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>s.  If you are creating a
control structure such as a <B
CLASS="emphasis.bold"
>while</B
> or an
<B
CLASS="emphasis.bold"
>if</B
> that requires one or more
<CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>s, you <EM
CLASS="emphasis"
>must</EM
> use braces
around each <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28689"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28691"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28693"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28695"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28697"
></A
>Not saving <B
CLASS="emphasis.bold"
>$1</B
>, <B
CLASS="emphasis.bold"
>$2</B
>, and so on, across regular expressions.
Remember that every new <CODE
CLASS="literal"
>m/atch/</CODE
> or
<CODE
CLASS="literal"
>s/ubsti/tute/</CODE
> will set (or clear, or mangle) your
<B
CLASS="emphasis.bold"
>$1</B
>, <B
CLASS="emphasis.bold"
>$2</B
>... variables, as well as <B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>`</CODE
>, <B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>'</CODE
>, and
<B
CLASS="emphasis.bold"
>$&amp;</B
>.  One way to save them right
away is to evaluate the match within a list context, as in:</P
><PRE
CLASS="programlisting"
>($one,$two) = /(\w+) (\w+)/;</PRE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28713"
></A
>Not realizing that a <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> also changes
the variable's value within other subroutines called within the scope
of the local.  It's easy to forget that <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> is a run-time statement that does dynamic
scoping, because there's no equivalent in languages like C.  See
<A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3, <CITE
CLASS="chapter"
>Functions</CITE
></A
>.
Usually you wanted a <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> anyway.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Losing track of brace pairings.
A good text editor will help you find the pairs.  Get one.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28724"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28726"
></A
>Using loop control statements in <CODE
CLASS="literal"
>do {} while</CODE
>.
Although the braces in this control structure look suspiciously
like part of a loop <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>, they aren't.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Saying <CODE
CLASS="literal"
>@foo[1]</CODE
> when you mean <CODE
CLASS="literal"
>$foo[1]</CODE
>.
The <CODE
CLASS="literal"
>@foo[1]</CODE
> reference is an array <EM
CLASS="emphasis"
>slice</EM
>, and means an
array consisting of the single element <CODE
CLASS="literal"
>$foo[1]</CODE
>.
Sometimes, this doesn't make any difference, as in:</P
><PRE
CLASS="programlisting"
>print &quot;the answer is @foo[1]\n&quot;;</PRE
><P
CLASS="para"
>but it makes a big difference for things like:</P
><PRE
CLASS="programlisting"
>@foo[1] = &lt;STDIN&gt;;</PRE
><P
CLASS="para"
>which will slurp up all the rest of <CODE
CLASS="literal"
>STDIN</CODE
>,
assign the <EM
CLASS="emphasis"
>first</EM
> line to
<CODE
CLASS="literal"
>$foo[1]</CODE
>, and discard everything else. This is probably not what you
intended.  Get into the habit of thinking that <CODE
CLASS="literal"
>$</CODE
> means a single
value, while <CODE
CLASS="literal"
>@</CODE
> means a list of values, and you'll do okay.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28748"
></A
>Forgetting to select the right filehandle before setting <B
CLASS="emphasis.bold"
>$^</B
>, <B
CLASS="emphasis.bold"
>$~</B
>, or
<B
CLASS="emphasis.bold"
>$|</B
>.  These variables depend on the
currently selected filehandle, as determined by
<CODE
CLASS="literal"
>select</CODE
>(<CODE
CLASS="replaceable"
><I
>FILEHANDLE</I
></CODE
>).
The initial filehandle so selected is <CODE
CLASS="literal"
>STDOUT</CODE
>.  You
should really be using the filehandle methods from the FileHandle
module instead.  See <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7, <CITE
CLASS="chapter"
>The Standard Perl Library</CITE
></A
>.</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.2"
>8.2.2 Frequently Ignored Advice</A
></H3
><P
CLASS="para"
>Practicing Perl Programmers should take note of the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Remember that many operations behave differently in a list context
than they do in a scalar one.  <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
> has all the details.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28767"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28769"
></A
>Avoid barewords if you can, especially all lowercase ones.
You can't tell just by looking at it whether a word is 
a function or a bareword string.  By using quotes on strings and 
parentheses around function call arguments, you won't ever get them confused.
In fact, the pragma <CODE
CLASS="literal"
>use strict</CODE
> at the beginning of your program
makes barewords a compile-time error&nbsp;- probably a good thing.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can't tell just by looking which built-in functions are unary
operators (like <A
CLASS="xref"
HREF="ch03_014.htm"
TITLE="chop"
><B
CLASS="xref.cmd"
>chop</B
></A
> and 
<A
CLASS="xref"
HREF="ch03_011.htm"
TITLE="chdir"
><B
CLASS="xref.cmd"
>chdir</B
></A
>), which are list operators 
(like <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> and <A
CLASS="xref"
HREF="ch03_181.htm"
TITLE="unlink"
><B
CLASS="xref.cmd"
>unlink</B
></A
>),
and which are argumentless (like <A
CLASS="xref"
HREF="ch03_173.htm"
TITLE="time"
><B
CLASS="xref.cmd"
>time</B
></A
>).
You'll want to learn them from <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2, <CITE
CLASS="chapter"
>The Gory Details</CITE
></A
>.  Note also
that user-defined subroutines are by default list operators, but can
be declared as unary operators with a prototype of <CODE
CLASS="literal"
>($)</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>People have a hard time remembering that some functions default to
<B
CLASS="emphasis.bold"
>$_</B
>, or <B
CLASS="emphasis.bold"
>@ARGV</B
>, or whatever, while others do not.  Take
the time to learn which are which, or avoid default arguments.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28788"
></A
><CODE
CLASS="literal"
>&lt;</CODE
><CODE
CLASS="replaceable"
><I
>FH</I
></CODE
><CODE
CLASS="literal"
>&gt;</CODE
> is not the
name of a filehandle, but an angle operator that does a line-input
operation on the handle.  This confusion usually manifests itself when
people try to <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> to the angle
operator:</P
><PRE
CLASS="programlisting"
>print &lt;FH&gt; &quot;hi&quot;;    # WRONG, omit angles</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remember also that data read by the angle operator is assigned to
<B
CLASS="emphasis.bold"
>$_</B
> only when the file read is the sole
condition in a <B
CLASS="emphasis.bold"
>while</B
> loop:</P
><PRE
CLASS="programlisting"
>while (&lt;FH&gt;)      { }
while ($_ = &lt;FH&gt;) { }..
&lt;FH&gt;;  # data discarded!</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Remember not to use <CODE
CLASS="literal"
>=</CODE
> when you need <CODE
CLASS="literal"
>=~</CODE
>;
the two constructs are quite different:</P
><PRE
CLASS="programlisting"
>$x =  /foo/;  # searches $_, puts result in $x
$x =~ /foo/;  # searches $x, discards result</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28811"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28813"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28816"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28819"
></A
>Use <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> for local variables whenever you can get away with 
it (but see &quot;Formats&quot; in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
> for where you can't).  
Using <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> actually gives a local value to a global 
variable, which leaves you open to unforeseen side effects
of dynamic scoping.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Don't localize a module's exported variables.  If you localize an
exported variable, its exported value will not change.  The local name
becomes an alias to a new value but the external name is still an alias
for the original.</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.3"
>8.2.3 Awk Traps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28829"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28832"
></A
>Accustomed <EM
CLASS="emphasis"
>awk</EM
> users should take special note of the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28838"
></A
>The English module, loaded via</P
><PRE
CLASS="programlisting"
>use English;</PRE
><P
CLASS="para"
>allows you to refer to special variables (like <CODE
CLASS="literal"
>$RS</CODE
>) using 
their <EM
CLASS="emphasis"
>awk</EM
> names; see the end of <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
> for details.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Semicolons are required after all simple statements in Perl (except
at the end of a block).  Newline is not a statement delimiter.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28849"
></A
>Braces are required on <B
CLASS="emphasis.bold"
>if</B
> and <B
CLASS="emphasis.bold"
>while</B
> blocks.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Variables begin with <CODE
CLASS="literal"
>$</CODE
> or <CODE
CLASS="literal"
>@</CODE
> in Perl.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Arrays index from <CODE
CLASS="literal"
>0</CODE
>, as do string positions in <A
CLASS="xref"
HREF="ch03_162.htm"
TITLE="substr"
><B
CLASS="xref.cmd"
>substr</B
></A
> and
<A
CLASS="xref"
HREF="ch03_075.htm"
TITLE="index"
><B
CLASS="xref.cmd"
>index</B
></A
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You have to decide whether your array has numeric or string indices.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You have to decide whether you want numeric or string comparisons.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Hash values do not spring into existence upon reference.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28871"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28874"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28877"
></A
>Reading an input line does not split it for you.  You get to split it
yourself to an array.  And the <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
> operator has different
arguments than you might guess.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The current input line is normally in <B
CLASS="emphasis.bold"
>$_</B
>, not <B
CLASS="emphasis.bold"
>$0</B
>.  It
generally does not have the newline stripped.  (<B
CLASS="emphasis.bold"
>$0</B
> is the name of the program executed.)  See
<A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> 
<B
CLASS="emphasis.bold"
>$1</B
>, <B
CLASS="emphasis.bold"
>$2</B
>, and so on, do not refer to fields&nbsp;- they
refer to substrings matched by the last pattern match.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-28892"
></A
>
The <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> operator
does not add field and record separators unless you set <B
CLASS="emphasis.bold"
>$,</B
> and <B
CLASS="emphasis.bold"
>$\</B
>.
(<CODE
CLASS="literal"
>$OFS</CODE
> and <CODE
CLASS="literal"
>$ORS</CODE
> if you're using
English.)  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> 
You must <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> your
files before you <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> to them.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-28905"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28907"
></A
>The range operator is <CODE
CLASS="literal"
>..</CODE
> rather than comma.  The comma operator works (more or less) as in does C.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-28913"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28916"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28918"
></A
>
The match binding operator is
<CODE
CLASS="literal"
>=~</CODE
>, not <CODE
CLASS="literal"
>~</CODE
>.
(<CODE
CLASS="literal"
>~</CODE
> is the 1's complement operator, as in C.)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-28926"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28929"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28931"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28933"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28935"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28937"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28940"
></A
>
The exponentiation operator is
<CODE
CLASS="literal"
>**</CODE
>, not <CODE
CLASS="literal"
>^</CODE
>.
<CODE
CLASS="literal"
>^</CODE
> is the bitwise XOR operator, as in C.  (You
know, one could get the feeling that <EM
CLASS="emphasis"
>awk</EM
> is
basically incompatible with C.)  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> <A
CLASS="indexterm"
NAME="AUTOID-28949"
></A
><A
CLASS="indexterm"
NAME="AUTOID-28951"
></A
>
The concatenation operator is dot
(<CODE
CLASS="literal"
>.</CODE
>), not &quot;nothing&quot;.  (Using &quot;nothing&quot; as an
operator would render <CODE
CLASS="literal"
>/pat/ /pat/</CODE
> unparsable, since
the third slash would be interpreted as a division operator&nbsp;- the
tokener is in fact slightly context sensitive for operators like
<CODE
CLASS="literal"
>/</CODE
>, <CODE
CLASS="literal"
>?</CODE
>, and
<CODE
CLASS="literal"
>&lt;</CODE
>.  And, in fact, a dot itself can be the
beginning of a number.)  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch03_099.htm"
TITLE="next"
><B
CLASS="xref.cmd"
>next</B
></A
>, <A
CLASS="xref"
HREF="ch03_035.htm"
TITLE="exit"
><B
CLASS="xref.cmd"
>exit</B
></A
>, 
and <B
CLASS="emphasis.bold"
>continue</B
>
keywords work differently.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The following variables work differently:<A
CLASS="indexterm"
NAME="AUTOID-28966"
></A
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><EM
CLASS="emphasis"
>awk</EM
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Perl</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ARGC</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
><CODE
CLASS="literal"
>$#ARGV</CODE
> or scalar <CODE
CLASS="literal"
>@ARGV</CODE
></P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ARGV[0]</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$0</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>FILENAME</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$ARGV</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>FNR</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$.</CODE
> - something</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>FS</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>(whatever you like)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>NF</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$#Fld</CODE
>, or some such</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>NR</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$.</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>OFMT</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$#</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>OFS</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$,</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ORS</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$\</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>RLENGTH</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>length($&amp;)</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>RS</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$/</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>RSTART</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>length($`)</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>SUBSEP</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$;</CODE
></TD
></TR
></TBODY
></TABLE
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You cannot set <CODE
CLASS="literal"
>$RS</CODE
> to a pattern, only a string.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>When in doubt, run the <EM
CLASS="emphasis"
>awk</EM
> construct through <EM
CLASS="emphasis"
>a2p</EM
> and see what it
gives you.</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.4"
>8.2.4 C Traps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29058"
></A
><A
CLASS="indexterm"
NAME="AUTOID-29060"
></A
>Cerebral C programmers should take note of the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Curlies are required for <B
CLASS="emphasis.bold"
>if</B
> and <B
CLASS="emphasis.bold"
>while</B
> blocks.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29070"
></A
>You must use <B
CLASS="emphasis.bold"
>elsif</B
> rather than &quot;else if&quot; or &quot;elif&quot;.  Syntax like:</P
><PRE
CLASS="programlisting"
>if (expression) {
    block;
}
else if (another_expression) {
    another_block;
}</PRE
><P
CLASS="para"
>is illegal.  The <B
CLASS="emphasis.bold"
>else</B
> part is always a
block, and a naked <B
CLASS="emphasis.bold"
>if</B
> is not a block.
You mustn't expect Perl to be exactly the same as C.  What you want
instead is:</P
><PRE
CLASS="programlisting"
>if (expression) {
    block;
}
elsif (another_expression) {
    another_block;
}</PRE
><P
CLASS="para"
>Note also that &quot;elif&quot; is &quot;file&quot; spelled backward.  Only
Algol-ers would want a keyword that was the same as another word spelled
backward.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29081"
></A
><A
CLASS="indexterm"
NAME="AUTOID-29083"
></A
>The <CODE
CLASS="literal"
>break</CODE
> and <CODE
CLASS="literal"
>continue</CODE
> keywords from C become in 
Perl <A
CLASS="xref"
HREF="ch03_081.htm"
TITLE="last"
><B
CLASS="xref.cmd"
>last</B
></A
> and <A
CLASS="xref"
HREF="ch03_099.htm"
TITLE="next"
><B
CLASS="xref.cmd"
>next</B
></A
>, respectively.
Unlike in C, these do <EM
CLASS="emphasis"
>not</EM
> work within a <CODE
CLASS="literal"
>do { } while</CODE
> construct.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29093"
></A
>There's no switch statement.  (But it's easy to build one on the fly; see 
&quot;Bare Blocks and Case Structures&quot; in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
>.)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Variables begin with <CODE
CLASS="literal"
>$</CODE
>, <CODE
CLASS="literal"
>@</CODE
>, or <CODE
CLASS="literal"
>%</CODE
> in Perl.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch03_111.htm"
TITLE="printf"
><B
CLASS="xref.cmd"
>printf</B
></A
> does not implement the
<CODE
CLASS="literal"
>*</CODE
> format for interpolating field widths, but it's
trivial to use interpolation of double-quoted strings to achieve the
same effect.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29107"
></A
>Comments begin with <CODE
CLASS="literal"
>#</CODE
>, not <CODE
CLASS="literal"
>/*</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can't take the address of anything, although a similar operator
in Perl is the backslash, which creates a reference.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><CODE
CLASS="literal"
>ARGV</CODE
> must be capitalized.
<CODE
CLASS="literal"
>$ARGV[0]</CODE
> is C's <CODE
CLASS="literal"
>argv[1]</CODE
>, and C's
<CODE
CLASS="literal"
>argv[0]</CODE
> ends up in <B
CLASS="emphasis.bold"
>$0</B
>.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Functions such as <A
CLASS="xref"
HREF="ch03_085.htm"
TITLE="link"
><B
CLASS="xref.cmd"
>link</B
></A
>,
<A
CLASS="xref"
HREF="ch03_181.htm"
TITLE="unlink"
><B
CLASS="xref.cmd"
>unlink</B
></A
>, and <A
CLASS="xref"
HREF="ch03_122.htm"
TITLE="rename"
><B
CLASS="xref.cmd"
>rename</B
></A
> return true for success, not <CODE
CLASS="literal"
>0</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Signal handlers deal with signal names, not numbers.</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.5"
>8.2.5 Sed Traps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29131"
></A
>Seasoned <EM
CLASS="emphasis"
>sed</EM
> programmers should take note of the
following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Backreferences in substitutions use <CODE
CLASS="literal"
>$</CODE
> rather than <CODE
CLASS="literal"
>\</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> The pattern matching metacharacters
<CODE
CLASS="literal"
>(</CODE
>, <CODE
CLASS="literal"
>)</CODE
>, and <CODE
CLASS="literal"
>|</CODE
>
do not have backslashes in front.  The corresponding literal
characters do.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The range operator in Perl is ... rather
than a comma.  </P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.6"
>8.2.6 Shell Traps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29149"
></A
><A
CLASS="indexterm"
NAME="AUTOID-29151"
></A
>Sharp shell programmers should take note of the following:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
>Variables are prefixed with <CODE
CLASS="literal"
>$</CODE
> or <CODE
CLASS="literal"
>@</CODE
> on the left side of
the assignment as well as the right.  A shellish assignment like:</P
><PRE
CLASS="programlisting"
>camel='dromedary';      # WRONG</PRE
><P
CLASS="para"
>won't be parsed the way you expect.  You need:</P
><PRE
CLASS="programlisting"
>$camel='dromedary';     # ok</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The loop variable of a <B
CLASS="emphasis.bold"
>foreach</B
> also requires a <CODE
CLASS="literal"
>$</CODE
>.
Although <EM
CLASS="emphasis"
>csh</EM
> likes:</P
><PRE
CLASS="programlisting"
>foreach hump (one two)
stuff_it $hump
end</PRE
><P
CLASS="para"
>in Perl this is written as:</P
><PRE
CLASS="programlisting"
>foreach $hump (&quot;one&quot;, &quot;two&quot;) {
    stuff_it($hump);
}</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29174"
></A
>The backtick operator does variable interpretation without regard to
the presence of single quotes in the command.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The backtick operator does no translation of the return value.
In Perl, you have to trim the newline explicitly, like this:</P
><PRE
CLASS="programlisting"
>chop($thishost = `hostname`);</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29183"
></A
>Shells (especially <EM
CLASS="emphasis"
>csh</EM
>) do several levels of substitution on each
command line.  Perl does substitution only within certain constructs
such as double quotes, backticks, angle brackets, and search patterns.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Shells tend to interpret scripts a little bit at a time.  Perl compiles
the entire program before executing it (except for <CODE
CLASS="literal"
>BEGIN</CODE
> blocks,
which execute at compile time).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
> The arguments are available via <B
CLASS="emphasis.bold"
>@ARGV</B
>, not <B
CLASS="emphasis.bold"
>$1</B
>,
<B
CLASS="emphasis.bold"
>$2</B
>, and so on.  </P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The environment is not automatically made available as separate scalar
variables.  But see the Env module.</P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-8-SECT-2.7"
>8.2.7 Previous Perl Traps</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH08.PERLOLD1"
></A
><A
CLASS="indexterm"
NAME="CH08.PERLOLD2"
></A
>Penitent Perl 4 (and Prior) Programmers should take note of the following
changes between Release 4 and Release 5 that might affect old scripts:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29207"
></A
><CODE
CLASS="literal"
>@</CODE
> now always interpolates an array in double-quotish strings.
Some programs may now need to use backslash to protect any <CODE
CLASS="literal"
>@</CODE
>
that shouldn't interpolate.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29213"
></A
>Barewords that used to look like strings to Perl will now look like
subroutine calls if a subroutine by that name is defined before the
compiler sees them.  For example:</P
><PRE
CLASS="programlisting"
>sub SeeYa { die &quot;Hasta la vista, baby!&quot; }
$SIG{'QUIT'} = SeeYa;</PRE
><P
CLASS="para"
>In prior versions of Perl, that code would set the signal handler.  Now, it
actually calls the function!  You may use the <B
CLASS="emphasis.bold"
>-w</B
> switch to find such risky usage.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29220"
></A
>Symbols starting with &quot;_&quot; are no longer forced into package main, except
for <B
CLASS="emphasis.bold"
>$_</B
> itself (and <B
CLASS="emphasis.bold"
>@_</B
>, and so on).</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29226"
></A
>Double-colon is now a valid package separator in an identifier.  Thus,
the statement:</P
><PRE
CLASS="programlisting"
>print &quot;$a::$b::$c\n&quot;;</PRE
><P
CLASS="para"
>now parses <CODE
CLASS="literal"
>$a::</CODE
> as the variable reference, where in
prior versions only the <CODE
CLASS="literal"
>$a</CODE
> was considered to be the variable
reference.  Similarly,</P
><PRE
CLASS="programlisting"
>print &quot;$var::abc::xyz\n&quot;;</PRE
><P
CLASS="para"
>is now interpreted as a single variable <CODE
CLASS="literal"
>$var::abc::xyz</CODE
>,
whereas in prior versions, the variable <CODE
CLASS="literal"
>$var</CODE
> would have been
followed by the constant text <CODE
CLASS="literal"
>::abc::xyz</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><CODE
CLASS="literal"
>s'$lhs'$rhs'</CODE
> now does no interpolation on either side.  It used to
interpolate <CODE
CLASS="literal"
>$lhs</CODE
> but not <CODE
CLASS="literal"
>$rhs</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29245"
></A
>The second and third arguments of <A
CLASS="xref"
HREF="ch03_154.htm"
TITLE="splice"
><B
CLASS="xref.cmd"
>splice</B
></A
> are
now evaluated in scalar context (as documented) rather than list context.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29250"
></A
>These are now semantic errors because of precedence:</P
><PRE
CLASS="programlisting"
>shift @list + 20; # now parses like shift(@list + 20), illegal!
$n = keys %map + 20; # now parses like keys(%map + 20), illegal!</PRE
><P
CLASS="para"
>Because if those were to work, then this couldn't:</P
><PRE
CLASS="programlisting"
>sleep $dormancy + 20;</PRE
><P
CLASS="para"
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29258"
></A
>The precedence of assignment operators is now the same as the precedence
of assignment.  Previous versions of Perl mistakenly gave them the
precedence of the associated operator.  So you now must parenthesize
them in expressions like</P
><PRE
CLASS="programlisting"
>/foo/ ? ($a += 2) : ($a -= 2);</PRE
><P
CLASS="para"
>Otherwise:</P
><PRE
CLASS="programlisting"
>/foo/ ? $a += 2 : $a -= 2;</PRE
><P
CLASS="para"
>would be erroneously parsed as:</P
><PRE
CLASS="programlisting"
>(/foo/ ? $a += 2 : $a) -= 2;</PRE
><P
CLASS="para"
>On the other hand,</P
><PRE
CLASS="programlisting"
>$a += /foo/ ? 1 : 2;</PRE
><P
CLASS="para"
>now works as a C programmer would expect.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><CODE
CLASS="literal"
>open FOO || die</CODE
> is now incorrect.  You need parentheses around
the filehandle, because <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> has the precedence of a list operator.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The elements of argument lists for formats are now evaluated in list
context.  This means you can interpolate list values now.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>You can't do a <A
CLASS="xref"
HREF="ch03_071.htm"
TITLE="goto"
><B
CLASS="xref.cmd"
>goto</B
></A
> into a block that is optimized away.  Darn.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>It is no longer syntactically legal to use whitespace as the name
of a variable, or as a delimiter for any kind of quote construct.
Double darn.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29281"
></A
>The <A
CLASS="xref"
HREF="ch03_010.htm"
TITLE="caller"
><B
CLASS="xref.cmd"
>caller</B
></A
> function now returns a false value in a scalar context
if there is no caller.  This lets library modules determine whether
they're being required or run directly.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><CODE
CLASS="literal"
>m//g</CODE
> now attaches its state to the searched string rather than
the regular expression.  See &quot;Regular Expressions&quot; in <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2</A
> for
further details.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><CODE
CLASS="literal"
>reverse</CODE
> is no longer allowed as the name of 
a <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
> subroutine.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29294"
></A
><EM
CLASS="emphasis"
>taintperl</EM
> is no longer a separate executable.  
There is now a <B
CLASS="emphasis.bold"
>-T</B
>
switch to turn on tainting when it isn't turned on automatically.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Double-quoted strings may no longer end with an unescaped <CODE
CLASS="literal"
>$</CODE
> or
<CODE
CLASS="literal"
>@</CODE
>.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The archaic <B
CLASS="emphasis.bold"
>if</B
> <CODE
CLASS="replaceable"
><I
>BLOCK BLOCK</I
></CODE
> syntax is no longer supported.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Negative array subscripts now count from the end of the array.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The comma operator in a scalar context is now guaranteed to give a
scalar context to its arguments.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The <CODE
CLASS="literal"
>**</CODE
> operator now binds more tightly than unary minus.  
It was documented to work this way before, but didn't.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Setting <CODE
CLASS="literal"
>$#array</CODE
> lower now discards array elements immediately.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="xref"
HREF="ch03_026.htm"
TITLE="delete"
><B
CLASS="xref.cmd"
>delete</B
></A
> is not guaranteed to return the deleted value for
<A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>d arrays, since this capability may be onerous for some modules
to implement.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>The construct <CODE
CLASS="literal"
>&quot;this is $$x&quot;</CODE
>, which used to interpolate the pid at that
point, now tries to dereference <CODE
CLASS="literal"
>$x</CODE
>.  <B
CLASS="emphasis.bold"
>$$</B
> by itself still
works fine, however.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-29327"
></A
>The meaning of <B
CLASS="emphasis.bold"
>foreach</B
> has changed slightly when it is iterating over a
list which is not an array.  This used to assign the list to a
temporary array, but for efficiency it no longer does so.  This means
that you'll now be iterating over the actual values, not over copies of
the values.  Modifications to the loop variable can change the original
values.  To retain prior Perl semantics you'd need to assign your list
explicitly to a temporary array and then iterate over that.  For
example, you might need to change:</P
><PRE
CLASS="programlisting"
>foreach $var (grep /x/, @list) { ... }</PRE
><P
CLASS="para"
>to:</P
><PRE
CLASS="programlisting"
>foreach $var (my @tmp = grep /x/, @list) { ... }</PRE
><P
CLASS="para"
>Otherwise changing <CODE
CLASS="literal"
>$var</CODE
> will clobber the values of
<CODE
CLASS="literal"
>@list</CODE
>.  (This most often happens when you use <B
CLASS="emphasis.bold"
>$_</B
> for the
loop variable, and call subroutines in the loop that don't properly
localize <B
CLASS="emphasis.bold"
>$_</B
>.)</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Some error messages will be different.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Some bugs may have been inadvertently removed.[<A
CLASS="footnote"
HREF="#AUTOID-29342"
>4</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-29342"
>[4]</A
> Much to the consternation of Perl poets.</P
></DIV
></BLOCKQUOTE
></LI
></UL
><A
CLASS="indexterm"
NAME="AUTOID-29344"
></A
><A
CLASS="indexterm"
NAME="AUTOID-29345"
></A
><A
CLASS="indexterm"
NAME="AUTOID-29346"
></A
><A
CLASS="indexterm"
NAME="AUTOID-29347"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_01.htm"
TITLE="8.1 The Perl Debugger"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 8.1 The Perl Debugger"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch08_03.htm"
TITLE="8.3 Efficiency"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 8.3 Efficiency"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>8.1 The Perl Debugger</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>8.3 Efficiency</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
