<HTML
><HEAD
>
<TITLE>[Chapter 2] 2.5 Operators</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:39:37Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"><LINK
REL="prev"
HREF="ch02_04.htm"
TITLE="2.4 Pattern Matching"><LINK
REL="next"
HREF="ch02_06.htm"
TITLE="2.6 Statements and Declarations"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_04.htm"
TITLE="2.4 Pattern Matching"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.4 Pattern Matching"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"
>Chapter 2<BR>The Gory Details</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_06.htm"
TITLE="2.6 Statements and Declarations"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.6 Statements and Declarations"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5"
>2.5 Operators</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.OPERATORS"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4535"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4538"
></A
>The terms of an expression often need to be combined and modified
in various ways, and that's what operators are for.  The tightness
with which operators bind is controlled by the <EM
CLASS="emphasis"
>precedence</EM
> of
the operators.
Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.[<A
CLASS="footnote"
HREF="#AUTOID-4542"
>27</A
>]<A
CLASS="indexterm"
NAME="AUTOID-4544"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4546"
></A
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-4542"
>[27]</A
> Classic Camel readers will note that we reversed this table from the old
edition.  The higher precedence operators are now higher on the page,
which makes some kind of metaphorical sense.</P
></DIV
></BLOCKQUOTE
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Associativity</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operators</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Terms and list operators (leftward)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-&gt;</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>++ --</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>**</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>! ~ \</CODE
> and unary <CODE
CLASS="literal"
>+</CODE
> and <CODE
CLASS="literal"
>-</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>=~ !~ </CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>* / % x</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+ - .</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;&lt; &gt;&gt;</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Named unary operators</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt; &gt; &lt;= &gt;= lt gt le ge</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>== != &lt;=&gt; eq ne cmp</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>| ^</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;&amp;</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>||</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>.. ...</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?:</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>= += -= *=</CODE
> and so on</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>, =&gt;</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Nonassociative</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>List operators (rightward)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Right</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>not</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>and</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Left</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>or xor</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>It may seem like there are too many precedence levels.  Well, you're
right, there are.  Fortunately, there are two things going for you here.
First, the precedence levels as they're defined usually follow your
intuition, presuming you're not psychotic.  And second, if you're merely
neurotic, you can always put in extra parentheses to relieve your
anxiety.<A
CLASS="indexterm"
NAME="AUTOID-4652"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4654"
></A
></P
><P
CLASS="para"
>Note that any operators borrowed from C keep the same precedence
relationship with each other, even where C's precedence is slightly screwy.
(This makes learning Perl easier for C folks.)</P
><P
CLASS="para"
>In the following sections, these operators are covered in precedence
order.  With very few exceptions, these all operate on scalar values
only, not list values.  We'll mention the exceptions as they come up.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.1"
>2.5.1 Terms and List Operators (Leftward)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.TERMS1"
></A
><A
CLASS="indexterm"
NAME="CH02.TERMS2"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4666"
></A
>Any <EM
CLASS="emphasis"
>term</EM
> is of highest precedence in Perl.  These include variables,
quote and quotelike operators, any expression in parentheses, and any
function whose arguments are parenthesized.  Actually, there aren't really
any functions in this sense, just list operators and unary operators behaving
as functions because you put parentheses around their arguments.
These operators are
all covered in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.</P
><P
CLASS="para"
>Now, listen carefully.  Here are a couple of rules that are very important
and simplify things greatly, but may occasionally produce counterintuitive
results for the unwary.  If any list operator (such as <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
>) or any
named unary operator (such as <A
CLASS="xref"
HREF="ch03_011.htm"
TITLE="chdir"
><B
CLASS="xref.cmd"
>chdir</B
></A
>) is followed by a left parenthesis as
the next token on the same line,[<A
CLASS="footnote"
HREF="#AUTOID-4673"
>28</A
>]
the operator and its arguments within parentheses are taken to be of
highest precedence, just like a normal function call.  The rule is: If
it <EM
CLASS="emphasis"
>looks</EM
> like a function call, it is a function call.
You can
make it look like a non-function by prefixing the arguments with a unary
plus, which does absolutely nothing, semantically speaking&nbsp;- it doesn't
even convert the argument to numeric.  </P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-4673"
>[28]</A
> And we nearly had you convinced Perl was a free-form language.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>For example, since || has lower
precedence than <A
CLASS="xref"
HREF="ch03_011.htm"
TITLE="chdir"
><B
CLASS="xref.cmd"
>chdir</B
></A
>, we get:<A
CLASS="indexterm"
NAME="AUTOID-4678"
></A
></P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>chdir $foo    || die;       # (chdir $foo) || die
chdir($foo)   || die;       # (chdir $foo) || die
chdir ($foo)  || die;       # (chdir $foo) || die
chdir +($foo) || die;       # (chdir $foo) || die</PRE
></P
><P
CLASS="para"
>but, because <CODE
CLASS="literal"
>*</CODE
> has higher precedence than <A
CLASS="xref"
HREF="ch03_011.htm"
TITLE="chdir"
><B
CLASS="xref.cmd"
>chdir</B
></A
>, we get:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>chdir $foo * 20;            # chdir ($foo * 20)
chdir($foo) * 20;           # (chdir $foo) * 20
chdir ($foo) * 20;          # (chdir $foo) * 20
chdir +($foo) * 20;         # chdir ($foo * 20)</PRE
></P
><P
CLASS="para"
>Likewise for numeric operators:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>rand 10 * 20;               # rand (10 * 20)
rand(10) * 20;              # (rand 10) * 20
rand (10) * 20;             # (rand 10) * 20
rand +(10) * 20;            # rand (10 * 20)</PRE
></P
><P
CLASS="para"
>In the absence of parentheses, the precedence of list operators such
as <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
>, <A
CLASS="xref"
HREF="ch03_153.htm"
TITLE="sort"
><B
CLASS="xref.cmd"
>sort</B
></A
>, or <A
CLASS="xref"
HREF="ch03_012.htm"
TITLE="chmod"
><B
CLASS="xref.cmd"
>chmod</B
></A
> is
either very high or very low depending on whether you look at the left
side of the operator or the right side of it.  (That's what the
&quot;Leftward&quot; is doing in the title of this section.)  For example, in:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@ary = (1, 3, sort 4, 2);
print @ary;         # prints 1324</PRE
></P
><P
CLASS="para"
>the commas on the right of the <B
CLASS="emphasis.bold"
>sort</B
> are evaluated before the <B
CLASS="emphasis.bold"
>sort</B
>, but
the commas on the left are evaluated after.  In other words, a list
operator tends to gobble up all the arguments that follow it, and
then act like a simple term with regard to the preceding expression.
Note that you have to be careful with parentheses:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># These evaluate exit before doing the print:
print($foo, exit);  # Obviously not what you want.
print $foo, exit;   # Nor is this.

# These do the print before evaluating exit:
(print $foo), exit; # This is what you want.
print($foo), exit;  # Or this.
print ($foo), exit; # Or even this.</PRE
></P
><P
CLASS="para"
>Also note that:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print ($foo &amp; 255) + 1, &quot;\n&quot;;   # prints ($foo &amp; 255)</PRE
></P
><P
CLASS="para"
>probably doesn't do what you expect at first glance.  Fortunately,
mistakes of this nature generally produce warnings like &quot;<CODE
CLASS="literal"
>Useless use
of addition in a void context</CODE
>&quot; when you use the <B
CLASS="emphasis.bold"
>-w</B
> command-line switch.</P
><P
CLASS="para"
>Also parsed as terms are the <CODE
CLASS="literal"
>do {}</CODE
> and <CODE
CLASS="literal"
>eval {}</CODE
> constructs,
as well as subroutine and method calls, the anonymous array and hash
composers <CODE
CLASS="literal"
>[]</CODE
> and <CODE
CLASS="literal"
>{}</CODE
>, and the anonymous subroutine
composer <CODE
CLASS="literal"
>sub {}</CODE
>.</P
><A
CLASS="indexterm"
NAME="AUTOID-4713"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4714"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.2"
>2.5.2 The Arrow Operator</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4718"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4721"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4723"
></A
>Just as in C and C++, <CODE
CLASS="literal"
>-&gt;</CODE
> is an infix dereference operator.  If the
right side is either a <CODE
CLASS="literal"
>[...]</CODE
> or <CODE
CLASS="literal"
>{...}</CODE
> subscript, then the left
side must be either a hard or symbolic reference to an array or hash (or
a location capable of holding a hard reference, if it's an lvalue
(assignable)).  More on this in <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
>.</P
><P
CLASS="para"
>Otherwise, the right side must be a method name or a simple scalar
variable containing the method name, and the value of the left side must
either be an object (a blessed reference) or a class name (that is, a
package name).  See <A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Packages, Modules, and Object Classes"
>Chapter 5</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.3"
>2.5.3 Autoincrement and Autodecrement</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4735"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4737"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4739"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4742"
></A
>The <CODE
CLASS="literal"
>++</CODE
> and <CODE
CLASS="literal"
>--</CODE
> operators work as in C.
That is, if placed before a variable, they
increment or decrement the variable before returning the value, and if
placed after, they increment or decrement the variable after returning the
value.  For example, <CODE
CLASS="literal"
>$a++</CODE
> increments the value of scalar variable
<CODE
CLASS="literal"
>$a</CODE
>, returning the value <EM
CLASS="emphasis"
>before</EM
> it performs the increment.
Similarly, <CODE
CLASS="literal"
>--$b{(/(\w+)/)[0]}</CODE
> decrements the element of the
hash <CODE
CLASS="literal"
>%b</CODE
> indexed by the first &quot;word&quot; in the default search
variable (<B
CLASS="emphasis.bold"
>$_</B
>) and returns the value <EM
CLASS="emphasis"
>after</EM
> the decrement.[<A
CLASS="footnote"
HREF="#AUTOID-4754"
>29</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-4754"
>[29]</A
> OK, so that wasn't exactly fair.  We just wanted to make sure you were
paying attention.  Here's how that expression works.  First the pattern
match finds the first word in <B
CLASS="emphasis.bold"
>$_</B
> using the regular expression
<CODE
CLASS="literal"
>\w+</CODE
>.  The parentheses around that causes the word to be returned as
a single-element list value, because the pattern match is in a list
context.  The list context is supplied by the list slice operator,
<CODE
CLASS="literal"
>(...)[0]</CODE
>, which returns the first (and only) element of the list.
That value is then used as the key for the hash, and the hash entry (value) is
decremented and returned.  In general, when confronted with a complex
expression, analyze it from the inside out to see what order things happen in.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The autoincrement operator has a little extra built-in magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has only been used in string contexts since it was set, and
has a value that is not null and matches the pattern
<CODE
CLASS="literal"
>/^[a-zA-Z]*[0-9]*$/</CODE
>, the increment is done as a string, preserving each
character within its range, with carry:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print ++($foo = '99');      # prints '100'
print ++($foo = 'a0');      # prints 'a1'
print ++($foo = 'Az');      # prints 'Ba'
print ++($foo = 'zz');      # prints 'aaa'</PRE
></P
><P
CLASS="para"
>The autodecrement operator, however, is not magical.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.4"
>2.5.4 Exponentiation</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4767"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4770"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4773"
></A
>Binary <CODE
CLASS="literal"
>**</CODE
> is the exponentiation operator.  Note that it binds even
more tightly than unary minus, so <CODE
CLASS="literal"
>-2**4</CODE
> is <CODE
CLASS="literal"
>-(2**4)</CODE
>, not
<CODE
CLASS="literal"
>(-2)**4</CODE
>.  The operator is implemented using C's <EM
CLASS="emphasis"
>pow</EM
>(3) function,
which works with doubles internally.  It calculates using
logarithms, which means that it works with fractional powers, but you
sometimes get results that aren't as exact as a straight multiplication
would produce.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.5"
>2.5.5 Ideographic Unary Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4783"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4786"
></A
>Most unary operators just have names (see &quot;Named Unary and File Test Operators&quot;
below), but some operators are deemed important enough to merit their
own special symbolic representation.  Most of these operators seem to
have something to do with negation.  Blame the mathematicians.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4789"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4792"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4795"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4797"
></A
>Unary ! performs logical negation, that is, &quot;not&quot;.  See also <B
CLASS="emphasis.bold"
>not</B
>
for a lower precedence version of this.  The value of a negated
operation is 1 if the operand is false (numeric 0, string <CODE
CLASS="literal"
>&quot;0&quot;</CODE
>, null
string, or undefined); otherwise, the value is that of the null string.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4803"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4806"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4808"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4811"
></A
>Unary <CODE
CLASS="literal"
>-</CODE
> performs arithmetic negation if the operand is numeric.  If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.  Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned.  One effect of these rules is that <CODE
CLASS="literal"
>-bareword</CODE
> is
equivalent to <CODE
CLASS="literal"
>&quot;-bareword&quot;</CODE
>.  This is most useful for Tk and CGI programmers.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4817"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4820"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4823"
></A
>Unary <CODE
CLASS="literal"
>~</CODE
> performs bitwise negation, that is, 1's complement.
For example, on a 32-bit machine, <CODE
CLASS="literal"
>~123</CODE
> is <CODE
CLASS="literal"
>4294967172</CODE
>.  But you knew
that already.</P
><P
CLASS="para"
>(What you perhaps didn't know is that if the argument to <CODE
CLASS="literal"
>~</CODE
> happens to
be a string instead of a number, a string of identical length is
returned, but with all the bits of the string complemented.  This is
a fast way to flip a lot of bits all at once.  See also the bitwise
logical operators, which also have stringish variants.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4832"
></A
>Unary <CODE
CLASS="literal"
>+</CODE
> has no semantic effect whatsoever, even on strings.  It is
syntactically useful for separating a function name from a parenthesized
expression that would otherwise be interpreted as the complete list of
function arguments.  (See examples above under the section &quot;Terms
and List
Operators&quot;.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4837"
></A
>Unary <CODE
CLASS="literal"
>\</CODE
> creates a reference to whatever follows it (see <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
>).
Do not confuse this behavior with the behavior of backslash within a
string, although both forms do convey the notion of protecting the next
thing from interpretation.  This resemblance is not entirely accidental.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>\</CODE
> operator may also be used on a parenthesized list value in a list
context, in which case it returns references to each element of the list.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.6"
>2.5.6 Binding Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4847"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4850"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4853"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4856"
></A
>Binary <CODE
CLASS="literal"
>=~</CODE
> binds a scalar expression to a pattern match, substitution,
or translation.  These operations search or modify the string <B
CLASS="emphasis.bold"
>$_</B
> by
default.  The binding operator makes those operations work on some other
string instead.  The argument on the right is the search pattern, substitution,
or translation.  The left argument is what is supposed to be searched,
substituted, or translated instead of the default <B
CLASS="emphasis.bold"
>$_</B
>.  The return
value indicates the success of the operation.  If the right argument is
an expression rather than a search pattern, substitution, or
translation, it is interpreted as a search pattern at run-time.  That
is, <CODE
CLASS="literal"
>$_ =~ $pat</CODE
> is equivalent to <CODE
CLASS="literal"
>$_ =~ /$pat/</CODE
>.  This is less
efficient than an explicit search, since the pattern must be compiled
every time the expression is evaluated.  (But <CODE
CLASS="literal"
>/$pat/o</CODE
> doesn't
recompile it because of the <B
CLASS="emphasis.bold"
>/o</B
> modifier.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4866"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4869"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4872"
></A
>Binary <CODE
CLASS="literal"
>!~</CODE
> is just like <CODE
CLASS="literal"
>=~</CODE
> except the return value is negated in
the logical sense.  The following expressions are functionally equivalent:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$string !~ /pattern/
not $string =~ /pattern/</PRE
></P
><P
CLASS="para"
>We said that the return value indicates success, but there are many
kinds of success.  Substitutions return the number of successful
substitutions, as do translations.  (In fact, the translation operator
is often used to count characters.)  Since any non-zero result is true,
it all works out.  The most spectacular kind of true value is a list
value: in a list context, pattern matches can return substrings matched
by the parentheses in the pattern.  But again, according to the rules of
list assignment, the list assignment itself will return true if anything
matched and was assigned, and false otherwise.  So you sometimes see
things like:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>if ( ($k,$v) = $string =~ m/(\w+)=(\w*)/ ) {
    print &quot;KEY $k VALUE $v\n&quot;;
}</PRE
></P
><P
CLASS="para"
>Let's pick that apart.  The <CODE
CLASS="literal"
>=~</CODE
> binds <CODE
CLASS="literal"
>$string</CODE
> to the
pattern match on the right, which is scanning for occurrences of things
that look like <CODE
CLASS="replaceable"
><I
>KEY=VALUE</I
></CODE
> in your string.  It's in a list context because
it's on the right side of a list assignment.  If it matches, it
does a list assignment to <CODE
CLASS="literal"
>$k</CODE
> and <CODE
CLASS="literal"
>$v</CODE
>.  The list
assignment itself is in a scalar context, so it returns <CODE
CLASS="literal"
>2</CODE
>, the number of
values on the right side of the assignment.  And <CODE
CLASS="literal"
>2</CODE
> happens to be true,
since our scalar context is also a Boolean context.  When the match
fails, no values are assigned, which returns 0, which is false.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.7"
>2.5.7 Multiplicative Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4892"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4894"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4897"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4900"
></A
>Perl provides the C-like operators <CODE
CLASS="literal"
>*</CODE
> (multiply),
<CODE
CLASS="literal"
>/</CODE
> (divide),
and <CODE
CLASS="literal"
>%</CODE
> (modulus).
The <CODE
CLASS="literal"
>*</CODE
> and <CODE
CLASS="literal"
>/</CODE
> work exactly as you might expect, multiplying or
dividing their two operands.  Division is done in floating-point,
unless you've used the integer library module.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4909"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4912"
></A
>The <CODE
CLASS="literal"
>%</CODE
> operator converts its operands to integers before finding the
remainder according to integer division.  For the same operation in
floating-point, you may prefer to use the <CODE
CLASS="literal"
>fmod()</CODE
> function from the
POSIX module (see <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
>).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4918"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4920"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4923"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4926"
></A
>Binary <B
CLASS="emphasis.bold"
>x</B
> is the repetition operator.  In scalar context, it
returns a concatenated string consisting of the left operand repeated
the number of times specified by the right operand.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print '-' x 80;             # print row of dashes

print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);      # tab over</PRE
></P
><P
CLASS="para"
>In list context, if the left operand is a list in parentheses, the <B
CLASS="emphasis.bold"
>x</B
>
works as a list replicator rather than a string replicator.  This is
useful for initializing all the elements of an array of indeterminate
length to the same value:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@ones = (1) x 80;           # a list of 80 1's
@ones = (5) x @ones;        # set all elements to 5</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4936"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4939"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4942"
></A
>Similarly, you can also use <B
CLASS="emphasis.bold"
>x</B
> to initialize array and hash slices:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@keys = qw(perls before swine);
@hash{@keys} = (&quot;&quot;) x @keys;</PRE
></P
><P
CLASS="para"
>If this mystifies you, note that <CODE
CLASS="literal"
>@keys</CODE
> is being
used both as a list on the left side of the assignment, and as a scalar
value (returning the array length) on the right side of the assignment.
The above has the same effect on <CODE
CLASS="literal"
>%hash</CODE
> as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$hash{perls}  = &quot;&quot;;
$hash{before} = &quot;&quot;;
$hash{swine}  = &quot;&quot;;</PRE
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.8"
>2.5.8 Additive Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4956"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4958"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4961"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4964"
></A
>Strangely enough, Perl also has the customary <CODE
CLASS="literal"
>+</CODE
> (addition) and <CODE
CLASS="literal"
>-</CODE
>
(subtraction) operators.  Both operators convert their arguments
from strings to numeric values if necessary, and return a numeric result.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4970"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4973"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4975"
></A
>Additionally, Perl provides a string concatenation operator &quot;<CODE
CLASS="literal"
>.</CODE
>&quot;.  For
example:</P
><PRE
CLASS="programlisting"
>$almost = &quot;Fred&quot; . &quot;Flintstone&quot;;    # returns FredFlintstone</PRE
><P
CLASS="para"
>Note that Perl does not place a space between the strings being
concatenated.  If you want the space, or if you have more than two
strings to concatenate, you can use the <A
CLASS="xref"
HREF="ch03_078.htm"
TITLE="join"
><B
CLASS="xref.cmd"
>join</B
></A
> operator, described in
<A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.  Most often, though, people do their
concatenation implicitly inside a double-quoted string:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$fullname = &quot;$firstname $lastname&quot;;</PRE
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.9"
>2.5.9 Shift Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4988"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4990"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4992"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4995"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4998"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5000"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5003"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5005"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5008"
></A
>The bit-shift operators (<CODE
CLASS="literal"
>&lt;&lt;</CODE
> and <CODE
CLASS="literal"
>&gt;&gt;</CODE
>) return the value of the
left argument shifted to the left (<CODE
CLASS="literal"
>&lt;&lt;</CODE
>) or to the right
(<CODE
CLASS="literal"
>&gt;&gt;</CODE
>) by the number of
bits specified by the right argument.  The arguments should be integers.
For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>1 &lt;&lt; 4;     # returns 16
32 &gt;&gt; 4;    # returns 2</PRE
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.10"
>2.5.10 Named Unary and File Test Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.UNARY1"
></A
><A
CLASS="indexterm"
NAME="CH02.UNARY2"
></A
><A
CLASS="indexterm"
NAME="CH02.UNARY3"
></A
>Some of &quot;functions&quot; described in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
> are really unary operators,
including:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>-X (file tests)</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>gethostbyname</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>localtime</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>rmdir</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>alarm</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>getnetbyname</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>log</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>scalar</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>caller</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>getpgrp</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>lstat</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>sin</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>chdir</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>getprotobyname</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>my</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>sleep</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>chroot</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>glob</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>oct</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>sqrt</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>cos</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>gmtime</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ord</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>srand</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>defined</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>goto</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>quotemeta</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>stat</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>delete</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>hex</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>rand</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>uc</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>do</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>int</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>readlink</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ucfirst</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>eval</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>lc</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ref</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>umask</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>exists</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>lcfirst</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>require</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>undef</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>exit</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>length</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>reset</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>exp</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>local</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>return</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>These are all unary operators, with a higher precedence than some of the
other binary operators.  For example:</P
><PRE
CLASS="programlisting"
>sleep 4 | 3;</PRE
><P
CLASS="para"
>does not sleep for 7 seconds; it sleeps for 4 seconds, and then takes the
return value of <A
CLASS="xref"
HREF="ch03_150.htm"
TITLE="sleep"
><B
CLASS="xref.cmd"
>sleep</B
></A
> (typically zero) and ORs that with 3, as if
the expression were parenthesized as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(sleep 4) | 3;</PRE
></P
><P
CLASS="para"
>Compare this with:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print 4 | 3;</PRE
></P
><P
CLASS="para"
>which <EM
CLASS="emphasis"
>does</EM
> take the value of 4 ORed with 3 before printing it (7 in
this case), as if it were written:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print (4 | 3);</PRE
></P
><P
CLASS="para"
>This is because <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
> is a list operator, not a simple unary
operator.  Once you've learned which operators are list operators, you'll
have no trouble telling them apart.  When in doubt, you can always use
parentheses to turn a named unary operator into a function.  Remember, if it
looks like a function, it is a function.</P
><P
CLASS="para"
>Another funny thing about named unary operators is that many of them
default to <B
CLASS="emphasis.bold"
>$_</B
> if you don't supply an argument.  However, if the
thing following the named unary operator looks like it might be the
start of an argument, Perl will get confused.  When the next character in
your program is one of the following characters, the Perl tokener returns
different token types depending on whether a term or operator is expected:<A
CLASS="indexterm"
NAME="AUTOID-5117"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5119"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5121"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5123"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5125"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5127"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5129"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5131"
></A
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Char</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operator</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Term</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Addition</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Unary plus</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Subtraction</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Unary minus</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Multiplication</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*typeglob</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>/</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Division</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>/pattern/</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than, left shift</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;HANDLE&gt;, &lt;&lt;END</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>.</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Concatenation</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>.3333</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?:</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?pattern?</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>%</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Modulo</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>%assoc</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;, &amp;&amp;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&amp;subroutine</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>So a typical boo-boo is:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>next if length &lt; 80;</PRE
></P
><P
CLASS="para"
>in which the <CODE
CLASS="literal"
>&lt;</CODE
> looks to the parser like the beginning of the
<CODE
CLASS="literal"
>&lt;&gt;</CODE
> input symbol (a term) instead of the &quot;less than&quot; (an operator) you
were thinking of.  There's really no way to fix this, and still keep Perl
pathologically eclectic.  If you're so incredibly lazy that you cannot
bring yourself to type the two characters <B
CLASS="emphasis.bold"
>$_</B
>, then say one of these
instead:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>next if length() &lt; 80;
next if (length) &lt; 80;
next if 80 &gt; length;
next unless length &gt;= 80;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5205"
></A
>A file test operator is a unary operator that takes one argument, either a
filename or a filehandle, and tests the associated file to see if something
is true about it.  If the argument is omitted, it tests <B
CLASS="emphasis.bold"
>$_</B
>, except for
<CODE
CLASS="literal"
>-t</CODE
>, which tests <CODE
CLASS="literal"
>STDIN</CODE
>.  Unless otherwise documented, it returns
<CODE
CLASS="literal"
>1</CODE
> for true and <CODE
CLASS="literal"
>&quot;&quot;</CODE
> for false, or the undefined
value if the file doesn't exist.  The operator may be any of the following:<A
CLASS="indexterm"
NAME="AUTOID-5212"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5214"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5216"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5218"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5220"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5222"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5224"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5226"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5228"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5230"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5232"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5234"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5236"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5238"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5240"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5242"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5244"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5246"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5248"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5250"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5252"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5254"
></A
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Operator</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-r</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is readable by effective uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-w</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is writable by effective uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is executable by effective uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-o</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is owned by effective uid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-R</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is readable by real uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-W</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is writable by real uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-X</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is executable by real uid/gid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-O</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is owned by real uid.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File exists.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-z</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has zero size.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has non-zero size (returns size).</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a plain file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-d</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a directory.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-l</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a symbolic link.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-p</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a named pipe (FIFO).</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-S</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a socket.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a block special file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-c</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a character special file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-t</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Filehandle is opened to a tty.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-u</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has setuid bit set.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-g</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has setgid bit set.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-k</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File has sticky bit set.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-T</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a text file.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-B</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>File is a binary file (opposite of <CODE
CLASS="literal"
>-T</CODE
>).</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-M</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Age of file (at startup) in days since modification.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-A</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Age of file (at startup) in days since last access.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>-C</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Age of file (at startup) in days since inode change.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The interpretation of the file permission operators
<CODE
CLASS="literal"
>-r</CODE
>, <CODE
CLASS="literal"
>-R</CODE
>, <CODE
CLASS="literal"
>-w</CODE
>,
<CODE
CLASS="literal"
>-W</CODE
>, <CODE
CLASS="literal"
>-x</CODE
>, and <CODE
CLASS="literal"
>-X</CODE
>
is based solely on the mode of the file and the user and group IDs of
the user.  There may be other reasons you can't actually read, write,
or execute the file, such as Andrew File System (AFS) access control lists.  Also note that
for the superuser, <CODE
CLASS="literal"
>-r</CODE
>, <CODE
CLASS="literal"
>-R</CODE
>,
<CODE
CLASS="literal"
>-w</CODE
>, and <CODE
CLASS="literal"
>-W</CODE
> always return 1, and
<CODE
CLASS="literal"
>-x</CODE
>, and <CODE
CLASS="literal"
>-X</CODE
> return 1 if any
execute bit is set in the mode.  Scripts run by the superuser may thus
need to do a <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
> in order to determine
the actual mode of the file, or temporarily set the uid to something
else. Example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while (&lt;&gt;) {
    chomp;
    next unless -f $_;      # ignore &quot;special&quot; files
    ...
}</PRE
></P
><P
CLASS="para"
>Note that <CODE
CLASS="literal"
>-s/a/b/</CODE
> does not do a negated substitution.  Saying
<CODE
CLASS="literal"
>-exp($foo)</CODE
> still works as expected, however&nbsp;- only single letters
following a minus are interpreted as file tests.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5410"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5412"
></A
>The <CODE
CLASS="literal"
>-T</CODE
> and <CODE
CLASS="literal"
>-B</CODE
> switches work as follows.  The first block or so
of the file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many odd characters (&gt;30%) are
found, it's a <CODE
CLASS="literal"
>-B</CODE
> file, otherwise it's a <CODE
CLASS="literal"
>-T</CODE
> file.  Also, any
file containing null in the first block is considered a binary file.  If
<CODE
CLASS="literal"
>-T</CODE
> or <CODE
CLASS="literal"
>-B</CODE
> is used on a
filehandle, the current input (standard I/O or &quot;stdio&quot;)
buffer is examined rather than the first block of the file.
Both <CODE
CLASS="literal"
>-T</CODE
> and <CODE
CLASS="literal"
>-B</CODE
> return
true on a null file, or on a file at EOF (end of file) when testing a
filehandle.  Because you have to read a file to do the <CODE
CLASS="literal"
>-T</CODE
> test, on
most occasions you want to use a <CODE
CLASS="literal"
>-f</CODE
> against the file first, as in:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>next unless -f $file &amp;&amp; -T _;</PRE
></P
><P
CLASS="para"
>If any of the file tests (or either the <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
> or <A
CLASS="xref"
HREF="ch03_090.htm"
TITLE="lstat"
><B
CLASS="xref.cmd"
>lstat</B
></A
> operators)
are given the special filehandle consisting of a solitary underline,
then the <EM
CLASS="emphasis"
>stat</EM
> structure of the previous file test (or <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
> operator) is
used, thereby saving a system call.  (This doesn't work with <CODE
CLASS="literal"
>-t</CODE
>, and
you need to remember that <A
CLASS="xref"
HREF="ch03_090.htm"
TITLE="lstat"
><B
CLASS="xref.cmd"
>lstat</B
></A
> and <CODE
CLASS="literal"
>-l</CODE
> will leave values in the
<EM
CLASS="emphasis"
>stat</EM
> structure for the symbolic link, not the real file.)[<A
CLASS="footnote"
HREF="#AUTOID-5435"
>30</A
>]
Example:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-5435"
>[30]</A
> Likewise, <CODE
CLASS="literal"
>-l _</CODE
> will always be false after a normal <A
CLASS="xref"
HREF="ch03_159.htm"
TITLE="stat"
><B
CLASS="xref.cmd"
>stat</B
></A
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print &quot;Can do.\n&quot; if -r $a || -w _ || -x _;

stat($filename);
print &quot;Readable\n&quot; if -r _;
print &quot;Writable\n&quot; if -w _;
print &quot;Executable\n&quot; if -x _;
print &quot;Setuid\n&quot; if -u _;
print &quot;Setgid\n&quot; if -g _;
print &quot;Sticky\n&quot; if -k _;
print &quot;Text\n&quot; if -T _;
print &quot;Binary\n&quot; if -B _;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5442"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5444"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5446"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5448"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5451"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5454"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5457"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5460"
></A
>File ages for <CODE
CLASS="literal"
>-M</CODE
>, <CODE
CLASS="literal"
>-A</CODE
>, and <CODE
CLASS="literal"
>-C</CODE
> are returned in days
(including fractional days) since the time when the script started running.
(This time is stored in
the special variable <B
CLASS="emphasis.bold"
>$^T</B
>.)  Thus, if the file changed after the
script started, you would get a negative time.
Note that most times (86,399 out of 86,400, on average) are fractional,
so testing for equality with an integer without using the <A
CLASS="xref"
HREF="ch03_076.htm"
TITLE="int"
><B
CLASS="xref.cmd"
>int</B
></A
>
function is usually futile.  Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>next unless -M $file &gt; .5;      # files older than 12 hours
&amp;newfile if -M $file &lt; 0;       # file is newer than process
&amp;mailwarning if int(-A) == 90;  # file ($_) accessed 90 days ago today</PRE
></P
><P
CLASS="para"
>To reset the script's start time to the current time, change <B
CLASS="emphasis.bold"
>$^T</B
>
as follows:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$^T = time;</PRE
></P
><A
CLASS="indexterm"
NAME="AUTOID-5474"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5475"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5476"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.11"
>2.5.11 Relational Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5480"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5482"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5484"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5486"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5488"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5490"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5493"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5496"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5499"
></A
>Perl has two classes of relational operators.  One class operates on
numeric values, and the other class operates on string values.  To
repeat the table given in the overview:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Numeric</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>String</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&gt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>gt</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&gt;=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ge</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Greater than or equal to</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>lt</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>le</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Less than or equal to</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>These operators return <CODE
CLASS="literal"
>1</CODE
> for true, and <CODE
CLASS="literal"
>&quot;&quot;</CODE
> for false.  String
comparisons are based on the ASCII collating sequence, and unlike in some
languages, trailing spaces count in the comparison. 
Note that relational operators are non-associating, which means that
<CODE
CLASS="literal"
>$a &lt; $b &lt; $c</CODE
> is a syntax error.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.12"
>2.5.12 Equality Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5541"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5543"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5545"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5547"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5550"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5553"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5556"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5559"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5562"
></A
>The equality operators are much like the relational operators.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Numeric</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>String</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>==</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>eq</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Equal to</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>!=</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>ne</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Not equal to</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&lt;=&gt;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>cmp</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Comparison, with signed result</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>The equal and not-equal operators return 1 for true, and <CODE
CLASS="literal"
>&quot;&quot;</CODE
> for false (just as
the relational operators do).  The <CODE
CLASS="literal"
>&lt;=&gt;</CODE
> and <B
CLASS="emphasis.bold"
>cmp</B
> operators return
-1 if the left operand is less than the right operand, 0 if they are
equal, and +1 if the left operand is greater than the right.  Although
these appear to be very similar to the relational operators, they do
have a different precedence level, so <CODE
CLASS="literal"
>$a &lt; $b &lt;=&gt; $c &lt; $d</CODE
> is
syntactically valid.</P
><P
CLASS="para"
>For reasons that are apparent to anyone who has seen <EM
CLASS="emphasis"
>Star Wars</EM
>, the <CODE
CLASS="literal"
>&lt;=&gt;</CODE
>
operator is known as the &quot;spaceship&quot; operator.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.13"
>2.5.13 Bitwise Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5601"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5605"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5608"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5610"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5613"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5616"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5619"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5621"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5623"
></A
>Like C, Perl has bitwise AND, OR, and XOR (exclusive
OR) operators: <CODE
CLASS="literal"
>&amp;</CODE
>, <CODE
CLASS="literal"
>|</CODE
>, and <CODE
CLASS="literal"
>^</CODE
>.  Note from the table at the
start of this section that bitwise-AND has a higher precedence.  These
operators work differently on numeric values than they do on strings.
(This is one of the few places where Perl cares about the difference.)
If either operand is a number (or has been used as a number), then both
operands are converted to type integer, and the bitwise operation is
performed between the two integers.  These integers are guaranteed to
be at least 32 bits long, but may be 64 bits on some machines.  The point
is that there's an arbitrary limit imposed by the machine's architecture.</P
><P
CLASS="para"
>If both operands are strings (and have not been used as numbers since
being set), these operators do bitwise operations between corresponding
bits from the two strings.  In this case, there's no arbitrary limit,
since strings aren't arbitrarily limited in size.  If one string is
longer than the other, the shorter string is considered to have a sufficient
number of 0 bits on the end to make up the difference.</P
><P
CLASS="para"
>For example, if you AND together two strings:</P
><PRE
CLASS="programlisting"
>&quot;123.45&quot; &amp; &quot;234.56&quot;</PRE
><P
CLASS="para"
>you get another string:</P
><PRE
CLASS="programlisting"
>&quot;020.44&quot;</PRE
><P
CLASS="para"
>But if you AND together a string and a number:</P
><PRE
CLASS="programlisting"
>&quot;123.45&quot; &amp; 234.56</PRE
><P
CLASS="para"
>The string is first converted to a number, giving:</P
><PRE
CLASS="programlisting"
>123.45 &amp; 234.56</PRE
><P
CLASS="para"
>The numbers are then converted to integer:</P
><PRE
CLASS="programlisting"
>123 &amp; 234</PRE
><P
CLASS="para"
>which evaluates to 106.</P
><P
CLASS="para"
>Note that all bit strings are true
(unless they come out to being the string &quot;<CODE
CLASS="literal"
>0</CODE
>&quot;).  This means
that tests of the form:</P
><PRE
CLASS="programlisting"
>if ( &quot;fred&quot; &amp; &quot;\1\2\3\4&quot; ) { ... }</PRE
><P
CLASS="para"
>would need to be written instead as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>if ( (&quot;fred&quot; &amp; &quot;\1\2\3\4&quot;) =~ /[^\0]/ ) { ... }</PRE
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.14"
>2.5.14 C-style Logical (Short Circuit) Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5650"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5653"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5656"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5659"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5661"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5664"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5666"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5668"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5671"
></A
>Like C, Perl provides the <CODE
CLASS="literal"
>&amp;&amp;</CODE
> (logical AND)
and <CODE
CLASS="literal"
>||</CODE
> (logical OR) operators.  They evaluate from
left to right (with <CODE
CLASS="literal"
>&amp;&amp;</CODE
> having slightly
higher precedence than <CODE
CLASS="literal"
>||</CODE
>) testing the truth of the
statement.  These operators are known as short-circuit operators
because they determine the truth of the statement by evaluating the
fewest number of operands possible.  For example, if the left operand
of an <CODE
CLASS="literal"
>&amp;&amp;</CODE
> operator is false, the right operand
is never evaluated because the result of the operator is false
regardless of the value of the right operand.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Example</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Name</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Result</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a &amp;&amp; $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>And</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> is false, <CODE
CLASS="literal"
>$b</CODE
> otherwise</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a || $b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Or</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$a</CODE
> if <CODE
CLASS="literal"
>$a</CODE
> is true, <CODE
CLASS="literal"
>$b</CODE
> otherwise</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Such short circuits are not only time savers, but are frequently used
to control the flow of evaluation.  For example, an oft-appearing idiom
in Perl programs is:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>open(FILE, &quot;somefile&quot;) || die &quot;Cannot open somefile: $!\n&quot;;</PRE
></P
><P
CLASS="para"
>In this case, Perl first evaluates the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> function.  If the value
is true (because <EM
CLASS="emphasis"
>somefile</EM
> was successfully opened), the execution
of the <A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
> function is unnecessary, and is skipped.  You can read
this literally as &quot;Open some file or die!&quot;</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>||</CODE
> and <CODE
CLASS="literal"
>&amp;&amp;</CODE
> operators differ from C's in that, rather than
returning 0 or 1, they return the last value evaluated.  This has the
delightful result that you can select the first of a series of values
that happens to be true.  Thus, a reasonably portable way to find out
the home directory might be:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$home = $ENV{HOME} 
     || $ENV{LOGDIR} 
     || (getpwuid($&lt;))[7] 
     || die &quot;You're homeless!\n&quot;;</PRE
></P
><P
CLASS="para"
>Perl also provides lower precedence <B
CLASS="emphasis.bold"
>and</B
> and <B
CLASS="emphasis.bold"
>or</B
> operators that are
more readable and don't force you to use parentheses as much.  They also
short-circuit.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.15"
>2.5.15 Range Operator</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.RANGE1"
></A
><A
CLASS="indexterm"
NAME="CH02.RANGE2"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5725"
></A
>The <CODE
CLASS="literal"
>..</CODE
> range operator is really two different
operators depending on the context.  In a list context, it returns a
list of values counting (by ones) from the left value to the right
value.  This is useful for writing <CODE
CLASS="literal"
>for (1..10)</CODE
> loops and for doing
slice operations on arrays.[<A
CLASS="footnote"
HREF="#AUTOID-5730"
>31</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-5730"
>[31]</A
> Be aware that under the current implementation,
a temporary array is created, so you'll burn a <EM
CLASS="emphasis"
>lot</EM
> of memory if you 
write something like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>for (1 .. 1_000_000) {
    # code
}</PRE
></P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5736"
></A
>In a scalar context, <CODE
CLASS="literal"
>..</CODE
> returns a Boolean value.  The operator
is bi-stable, like an electronic flip-flop, and emulates the line-range
(comma) operator of <EM
CLASS="emphasis"
>sed</EM
>, <EM
CLASS="emphasis"
>awk</EM
>, and various editors.  Each
scalar <CODE
CLASS="literal"
>..</CODE
> operator maintains its own Boolean state.  It is false
as long as its left operand is false.  Once the left operand is true,
the range operator stays true until the right operand is true,
<EM
CLASS="emphasis"
>after</EM
> which the range operator becomes false again.  (The operator doesn't
become false until the next time it is evaluated.  It can test the right operand
and become false on the same evaluation as the one where it became true (the way
<EM
CLASS="emphasis"
>awk</EM
>'s range operator behaves), but it still returns true once.  If you
don't want it to test the right operand until the next evaluation (which is how
<EM
CLASS="emphasis"
>sed</EM
>'s range operator works), just use three dots (<CODE
CLASS="literal"
>...</CODE
>) instead of
two.)  The right operand is not evaluated while the operator is in the false
state, and the left operand is not evaluated while the operator is in the true
state.</P
><P
CLASS="para"
>The precedence is a little lower than <CODE
CLASS="literal"
>||</CODE
> and <CODE
CLASS="literal"
>&amp;&amp;</CODE
>.
The value returned is
either the null string for false, or a sequence number (beginning with
<CODE
CLASS="literal"
>1</CODE
>) for true.  The sequence number is reset for each range encountered.
The final sequence number in a range has the string &quot;E0&quot; appended to it,
which doesn't affect its numeric value, but gives you something to
search for if you want to exclude the endpoint.  You can exclude the
beginning point by waiting for the sequence number to be greater than 1.
If either operand of scalar <CODE
CLASS="literal"
>..</CODE
> is a numeric literal, that operand is
evaluated by comparing it to the <B
CLASS="emphasis.bold"
>$.</B
> variable, which contains the current
line number for your input file.  Examples:</P
><P
CLASS="para"
>As a scalar operator:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>if (101 .. 200) { print; }  # print 2nd hundred lines
next line if (1 .. /^$/);   # skip header lines
s/^/&gt; / if (/^$/ .. eof()); # quote body</PRE
></P
><P
CLASS="para"
>As a list operator:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>for (101 .. 200) { print; }            # prints 101102...199200
@foo = @foo[0 .. $#foo];               # an expensive no-op
@foo = @foo[ -5 .. -1];                # slice last 5 items</PRE
></P
><P
CLASS="para"
>The range operator (in a list context) makes use of the magical
autoincrement algorithm if the operands are strings.[<A
CLASS="footnote"
HREF="#AUTOID-5760"
>32</A
>]
So you can say:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-5760"
>[32]</A
> If the final value specified is not in the sequence that the magical increment
would produce, the sequence goes until the next value would be longer than
the final value specified.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@alphabet = ('A' .. 'Z');</PRE
></P
><P
CLASS="para"
>to get all the letters of the alphabet, or:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$hexdigit = (0 .. 9, 'a' .. 'f')[$num &amp; 15];</PRE
></P
><P
CLASS="para"
>to get a hexadecimal digit, or:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@z2 = ('01' .. '31');  print $z2[$mday];</PRE
></P
><P
CLASS="para"
>to get dates with leading zeros.  You can also say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@combos = ('aa' .. 'zz');</PRE
></P
><P
CLASS="para"
>to get all combinations of two lowercase letters. However, be careful of
something like:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@bigcombos = ('aaaaaa' .. 'zzzzzz');</PRE
></P
><P
CLASS="para"
>since that will require lots of memory.  More precisely, it'll need
space to store 308,915,776 scalars.  Let's hope you allocated a <EM
CLASS="emphasis"
>large</EM
>
swap partition.  Perhaps you should consider an iterative approach instead.</P
><A
CLASS="indexterm"
NAME="AUTOID-5778"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5779"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.16"
>2.5.16 Conditional Operator</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5783"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5785"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5788"
></A
>Trinary <CODE
CLASS="literal"
>?:</CODE
> is the conditional operator, just as in C.  It works as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
><CODE
CLASS="replaceable"
><I
>TEST_EXPR</I
></CODE
> ? <CODE
CLASS="replaceable"
><I
>IF_TRUE_EXPR</I
></CODE
> : <CODE
CLASS="replaceable"
><I
>IF_FALSE_EXPR</I
></CODE
></PRE
></P
><P
CLASS="para"
>much like an if-then-else, except that it can safely be embedded within other
operations and functions.  If the <CODE
CLASS="replaceable"
><I
>TEST_EXPR</I
></CODE
> is true, only the
<CODE
CLASS="replaceable"
><I
>IF_TRUE_EXPR</I
></CODE
> is evaluated, and the value of that expression becomes
the value of the entire expression.  Otherwise, only the <CODE
CLASS="replaceable"
><I
>IF_FALSE_EXPR</I
></CODE
>
is evaluated, and its value becomes the value of the entire
expression.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>printf &quot;I have %d dog%s.\n&quot;, $n, 
        ($n == 1) ? &quot;&quot; : &quot;s&quot;;</PRE
></P
><P
CLASS="para"
>Scalar or list context propagates downward into the second
or third argument, whichever is selected. (The first argument is always
in scalar context, since it's a conditional.)</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = $ok ? $b : $c;  # get a scalar
@a = $ok ? @b : @c;  # get an array
$a = $ok ? @b : @c;  # get a count of elements in one of the arrays</PRE
></P
><P
CLASS="para"
>You can assign to the conditional operator[<A
CLASS="footnote"
HREF="#AUTOID-5806"
>33</A
>]
if both the second and third
arguments are
legal lvalues (meaning that you can assign to them), provided that both are
scalars or both are lists (or Perl won't know which context to supply to
the right side of the assignment):</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-5806"
>[33]</A
> This is not necessarily guaranteed to contribute to the readability of your 
program.  But it can be used to create some cool entries in an Obfuscated
Perl contest.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($a_or_b ? $a : $b) = $c;  # sets either $a or $b to equal $c</PRE
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.17"
>2.5.17 Assignment Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5813"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5815"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5818"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5821"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5824"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5827"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5830"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5833"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5836"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5839"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5841"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5844"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5847"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5850"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5853"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5856"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5859"
></A
>
Perl recognizes the C assignment operators, as well as providing some of its
own.  There are quite a few of them:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>=    **=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=
            -=    /=    |=    &gt;&gt;=    ||=
            .=    %=    ^=
                  x=</PRE
></P
><P
CLASS="para"
>Each operator requires an lvalue (a variable or array element) on the left
side, and some expression on the right side.  For the simple assignment
operator, <CODE
CLASS="literal"
>=</CODE
>, the value of the expression is stored into the designated
variable.  For the other operators, Perl evaluates the expression:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$var <CODE
CLASS="replaceable"
><I
>OP</I
></CODE
>= $value</PRE
></P
><P
CLASS="para"
>as if it were written:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$var = $var <CODE
CLASS="replaceable"
><I
>OP</I
></CODE
> $value</PRE
></P
><P
CLASS="para"
>except that <CODE
CLASS="literal"
>$var</CODE
> is evaluated only once.  Compare the following two
operations:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$var[$a++] += $value;               # $a is incremented once
$var[$a++] = $var[$a++] + $value;   # $a is incremented twice</PRE
></P
><P
CLASS="para"
>Unlike in C, the assignment operator produces a valid lvalue.  Modifying
an assignment is equivalent to doing the assignment and then modifying
the variable that was assigned to.  This is useful for modifying
a copy of something, like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($tmp = $global) += $constant;</PRE
></P
><P
CLASS="para"
>which is the equivalent of:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$tmp = $global + $constant;</PRE
></P
><P
CLASS="para"
>Likewise:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($a += 2) *= 3;</PRE
></P
><P
CLASS="para"
>is equivalent to:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a += 2;
$a *= 3;</PRE
></P
><P
CLASS="para"
>That's not actually very useful, but you often see this idiom:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($new = $old) =~ s/foo/bar/g;</PRE
></P
><P
CLASS="para"
>In all cases, the value of the assignment is the new value of the variable.
Since assignment operators associate right-to-left, this can be used to assign
many variables the same value, as in:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = $b = $c = 0;</PRE
></P
><P
CLASS="para"
>which assigns <CODE
CLASS="literal"
>0</CODE
> to <CODE
CLASS="literal"
>$c</CODE
>, and the result of that (still <CODE
CLASS="literal"
>0</CODE
>) to
<CODE
CLASS="literal"
>$b</CODE
>, and the result of that (<EM
CLASS="emphasis"
>still</EM
> <CODE
CLASS="literal"
>0</CODE
>) to <CODE
CLASS="literal"
>$a</CODE
>.</P
><P
CLASS="para"
>List assignment may be done only with the plain assignment operator, <CODE
CLASS="literal"
>=</CODE
>.
In a list context, list assignment returns the list of new values just as
scalar assignment does.  In a scalar context, list assignment returns the
number of values that were available on the right side of the assignment,
as we mentioned earlier in &quot;List Values and Arrays&quot;.  This makes it
useful for testing functions that return a null list when they're
&quot;unsuccessful&quot;, as in:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while (($key, $value) = each %gloss) { ... }

next unless ($dev, $ino, $mode) = stat $file;</PRE
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.18"
>2.5.18 Comma Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5910"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5913"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5917"
></A
>Binary &quot;<CODE
CLASS="literal"
>,</CODE
>&quot; is the comma operator.  In a scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.
For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$a = (1, 3);</PRE
></P
><P
CLASS="para"
>assigns <CODE
CLASS="literal"
>3</CODE
> to <CODE
CLASS="literal"
>$a</CODE
>.  Do not confuse the scalar context use with the list
context use.  In a list context, it's just the list argument separator, and 
inserts both its arguments into the <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>.  It does not throw any values
away.  </P
><P
CLASS="para"
>For example, if you change the above to:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@a = (1, 3);</PRE
></P
><P
CLASS="para"
>you are constructing a two-element list, while:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>atan2(1, 3);</PRE
></P
><P
CLASS="para"
>is calling the function <A
CLASS="xref"
HREF="ch03_006.htm"
TITLE="atan2"
><B
CLASS="xref.cmd"
>atan2</B
></A
> with two arguments.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5937"
></A
>The <CODE
CLASS="literal"
>=&gt;</CODE
> digraph is mostly just a synonym for the comma operator.
It's useful for documenting arguments that come in pairs.  It also
forces any identifier to the left of it to be interpreted as a string.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.19"
>2.5.19 List Operators (Rightward)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5944"
></A
>The right side of a list operator governs all the list operator's
arguments, which are comma separated, so the precedence of list operators is
looser than comma if you're looking to the right.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.20"
>2.5.20 Logical and, or, not, and xor</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5949"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5952"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5955"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5957"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5959"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5961"
></A
><A
CLASS="indexterm"
NAME="AUTOID-5963"
></A
>As more readable alternatives to <CODE
CLASS="literal"
>&amp;&amp;</CODE
>, <CODE
CLASS="literal"
>||</CODE
>, and <CODE
CLASS="literal"
>!</CODE
>,
Perl provides the <B
CLASS="emphasis.bold"
>and</B
>, <B
CLASS="emphasis.bold"
>or</B
> and <B
CLASS="emphasis.bold"
>not</B
> operators.  The
behavior of these operators is identical&nbsp;- in particular, they
short-circuit the same way.[<A
CLASS="footnote"
HREF="#AUTOID-5972"
>34</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-5972"
>[34]</A
> Obviously the unary <B
CLASS="emphasis.bold"
>not</B
> doesn't short circuit, just as <CODE
CLASS="literal"
>!</CODE
> doesn't.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The precedence of these operators is much lower, however, so you can
safely use them after a list operator without the need for
parentheses:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>unlink &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;
        or gripe(), next LINE;</PRE
></P
><P
CLASS="para"
>With the C-style operators that would have to be written like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>unlink(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)
        || (gripe(), next LINE);</PRE
></P
><P
CLASS="para"
>There is also a logical <B
CLASS="emphasis.bold"
>xor</B
> operator that has no exact counterpart in
C or Perl, since the other XOR operator (<CODE
CLASS="literal"
>^</CODE
>) works on bits.  The
best equivalent for <CODE
CLASS="literal"
>$a xor $b</CODE
> is perhaps <CODE
CLASS="literal"
>!$a != !$b</CODE
>.[<A
CLASS="footnote"
HREF="#AUTOID-5987"
>35</A
>]
This operator can't short-circuit either, since both sides must be evaluated.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-5987"
>[35]</A
> One could also write <CODE
CLASS="literal"
>!$a ^ !$b</CODE
> or even <CODE
CLASS="literal"
>$a ? !$b : !!$b</CODE
>,
of course.  The point is that both <CODE
CLASS="literal"
>$a</CODE
> and <CODE
CLASS="literal"
>$b</CODE
> have to
evaluate to true or false in a Boolean context, and the existing bitwise
operator doesn't provide a Boolean context.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-5.21"
>2.5.21 C Operators Missing from Perl</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-5996"
></A
>Here is what C has that Perl doesn't:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>unary &amp;</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The address-of operator.  Perl's <CODE
CLASS="literal"
>\</CODE
> operator (for taking a reference)
fills the same ecological niche, however:<A
CLASS="indexterm"
NAME="AUTOID-6005"
></A
></P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$ref_to_var = \$var;</PRE
></P
><P
CLASS="para"
>But references are much safer than addresses.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>unary *</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The dereference-address operator.  Since Perl doesn't have addresses, it
doesn't need to dereference addresses.  It does have references though,
so Perl's variable prefix characters serve as dereference operators,
and indicate type as well: <CODE
CLASS="literal"
>$</CODE
>, <CODE
CLASS="literal"
>@</CODE
>, <CODE
CLASS="literal"
>%</CODE
> and
<CODE
CLASS="literal"
>&amp;</CODE
>.  Oddly enough, there actually is a <CODE
CLASS="literal"
>*</CODE
> dereference
operator, but since <CODE
CLASS="literal"
>*</CODE
> is the funny character
indicating a typeglob, you wouldn't use it the same way.<A
CLASS="indexterm"
NAME="AUTOID-6022"
></A
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(TYPE)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The typecasting operator.  Nobody likes to be typecast anyway.<A
CLASS="indexterm"
NAME="AUTOID-6030"
></A
></P
></DD
></DL
><A
CLASS="indexterm"
NAME="AUTOID-6032"
></A
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_04.htm"
TITLE="2.4 Pattern Matching"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.4 Pattern Matching"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_06.htm"
TITLE="2.6 Statements and Declarations"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.6 Statements and Declarations"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>2.4 Pattern Matching</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>2.6 Statements and Declarations</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
