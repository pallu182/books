<HTML
><HEAD
>
<TITLE>[Chapter 5] 5.4 Using Tied Variables</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:58:53Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch05_01.htm"
TITLE="5. Packages, Modules, and Object Classes"><LINK
REL="prev"
HREF="ch05_03.htm"
TITLE="5.3 Objects"><LINK
REL="next"
HREF="ch05_05.htm"
TITLE="5.5 Some Hints About Object Design"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_03.htm"
TITLE="5.3 Objects"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3 Objects"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch05_01.htm"
TITLE="5. Packages, Modules, and Object Classes"
>Chapter 5<BR>Packages, Modules, and Object Classes</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_05.htm"
TITLE="5.5 Some Hints About Object Design"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5 Some Hints About Object Design"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-5-SECT-4"
>5.4 Using Tied Variables</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH05.TIE1"
></A
><A
CLASS="indexterm"
NAME="CH05.TIE2"
></A
><A
CLASS="indexterm"
NAME="CH05.TIE3"
></A
><A
CLASS="indexterm"
NAME="AUTOID-15920"
></A
>In older versions of Perl, a user could call <A
CLASS="xref"
HREF="ch03_024.htm"
TITLE="dbmopen"
><B
CLASS="xref.cmd"
>dbmopen</B
></A
> to
tie a hash to a UNIX DBM file.  Whenever the
hash was accessed, the database file on disk (really just a hash,
not a full relational database) would be magically[<A
CLASS="footnote"
HREF="#AUTOID-15923"
>16</A
>]
read from or written to.  In modern versions of Perl, you can bind any
ordinary variable (scalar, array, or hash) to an implementation
class by using <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>.  (The class may or may not implement a
DBM file.)  You can break this association with <A
CLASS="xref"
HREF="ch03_184.htm"
TITLE="untie"
><B
CLASS="xref.cmd"
>untie</B
></A
>.<A
CLASS="indexterm"
NAME="AUTOID-15927"
></A
></P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-15923"
>[16]</A
> In this case, magically means &quot;transparently doing something very
complicated&quot;.  You know the old saying&nbsp;- any technology sufficiently
advanced is indistinguishable from a Perl script.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> function creates the association by creating an object
internally to represent the variable to the class.  If you have a tied
variable, but want to get at the underlying object, there are
two ways to do it.  First, the <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>
function returns a reference to the object.  
But if you didn't bother to store that object reference
anywhere, you could still retrieve it using the <A
CLASS="xref"
HREF="ch03_172.htm"
TITLE="tied"
><B
CLASS="xref.cmd"
>tied</B
></A
> function.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$object = tie <CODE
CLASS="replaceable"
><I
>VARIABLE</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>CLASSNAME</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>
untie <CODE
CLASS="replaceable"
><I
>VARIABLE</I
></CODE
>
$object = tied <CODE
CLASS="replaceable"
><I
>VARIABLE</I
></CODE
></PRE
></P
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> function binds the variable to the class package that
provides the methods for that variable.  Once
this magic has been performed, accessing a tied variable automatically
triggers method calls in the proper class.  All the complexity of the
class is hidden behind magic method calls.  The method names are
predetermined, since they're called implicitly from within the innards
of Perl.  These names are in <CODE
CLASS="literal"
>ALL CAPS</CODE
>, which is a convention in Perl
culture that indicates that the routines are called implicitly rather than
explicitly&nbsp;- just like <CODE
CLASS="literal"
>BEGIN</CODE
>, <CODE
CLASS="literal"
>END</CODE
>, and <CODE
CLASS="literal"
>DESTROY</CODE
>.
And <CODE
CLASS="literal"
>AUTOLOAD</CODE
> too, for that matter.</P
><P
CLASS="para"
>You can almost think of <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> as a funny kind of <A
CLASS="xref"
HREF="ch03_009.htm"
TITLE="bless"
><B
CLASS="xref.cmd"
>bless</B
></A
>, except
that it blesses a bare variable instead of a thingy reference, and
takes extra parameters, like a constructor.  That's because it actually
does call a constructor internally.  (That's one of the magic methods we
mentioned.)  This constructor is passed the <CODE
CLASS="replaceable"
><I
>CLASSNAME</I
></CODE
> you specified, as
well as any additional arguments you supply in the <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>.  It is not
passed the <CODE
CLASS="replaceable"
><I
>VARIABLE</I
></CODE
>, however.  The only way the constructor can
tell which kind of <CODE
CLASS="replaceable"
><I
>VARIABLE</I
></CODE
> is being tied is by knowing its
own method name.  This is not the customary constructor name,
<CODE
CLASS="literal"
>new</CODE
>, but rather one of <CODE
CLASS="literal"
>TIESCALAR</CODE
>, <CODE
CLASS="literal"
>TIEARRAY</CODE
>, or
<CODE
CLASS="literal"
>TIEHASH</CODE
>.  (You can likely figure out which name goes with which
variable type.)  The constructor just returns an object reference in the
normal fashion, and doesn't worry about whether it was called from
<A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>&nbsp;- which it may not have been, since you can call these methods
directly if you like.  (Indeed, if you've tied your variable to a class
that provides other methods not accessible through the variable,
you <EM
CLASS="emphasis"
>must</EM
> call the other methods directly yourself, via the object
reference.  These extra methods might provide services like file locking
or other forms of transaction protection.)</P
><P
CLASS="para"
>As in any constructor, these constructors must <B
CLASS="emphasis.bold"
>bless</B
> a reference to a
thingy and return it as the implementation object.  The thingy inside
the implementation object doesn't have to be of the same type as the
variable you're tying to.  It does have to be a properly blessed
object, though.  See the example below on tied arrays, which uses a hash
object to hold information about an array.</P
><P
CLASS="para"
>The <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> function will not <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> or <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
> a module for you&nbsp;- you
must do that explicitly yourself.  (On the other hand, the <A
CLASS="xref"
HREF="ch03_024.htm"
TITLE="dbmopen"
><B
CLASS="xref.cmd"
>dbmopen</B
></A
>
emulator function will, for backward compatibility, attempt to
use one or another DBM implementation.  But you can
preempt its selection with an explicit <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
>, provided the module
you <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> is one of the modules in <A
CLASS="xref"
HREF="ch03_024.htm"
TITLE="dbmopen"
><B
CLASS="xref.cmd"
>dbmopen</B
></A
>'s list of modules
to try.
See the AnyDBM_File module in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
> for a fuller explanation.)</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-5-SECT-4.1"
>5.4.1 Tying Scalars</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH05.SCAL"
></A
>A class implementing a tied scalar must define the following methods:
<CODE
CLASS="literal"
>TIESCALAR</CODE
>, <CODE
CLASS="literal"
>FETCH</CODE
>, <CODE
CLASS="literal"
>STORE</CODE
>, and possibly
<CODE
CLASS="literal"
>DESTROY</CODE
>.  These routines will be invoked implicitly when you
<A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> a variable (<CODE
CLASS="literal"
>TIESCALAR</CODE
>), read a tied variable
(<CODE
CLASS="literal"
>FETCH</CODE
>), or assign a value to a tied variable (<CODE
CLASS="literal"
>STORE</CODE
>).  The
<CODE
CLASS="literal"
>DESTROY</CODE
> method is called (as always) when the last reference to
the object disappears.  (This may or may not happen when you call
<A
CLASS="xref"
HREF="ch03_184.htm"
TITLE="untie"
><B
CLASS="xref.cmd"
>untie</B
></A
>, which destroys the reference used by the tie, but doesn't
destroy any outstanding references you may have squirreled away
elsewhere.)  The <CODE
CLASS="literal"
>FETCH</CODE
> and <CODE
CLASS="literal"
>STORE</CODE
> methods are triggered
when you access the variable that's been tied, not the object it's been
tied to.  If you have a handle on the object (either returned by the
initial <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> or retrieved later via <A
CLASS="xref"
HREF="ch03_172.htm"
TITLE="tied"
><B
CLASS="xref.cmd"
>tied</B
></A
>), you can access the
underlying object yourself without automatically triggering its
<CODE
CLASS="literal"
>FETCH</CODE
> or <CODE
CLASS="literal"
>STORE</CODE
> methods.</P
><P
CLASS="para"
>Let's look at each of these methods in turn, using as our example an
imaginary class called <CODE
CLASS="literal"
>Nice</CODE
>.[<A
CLASS="footnote"
HREF="#AUTOID-15995"
>17</A
>]
Variables tied to this class are scalars containing process priorities,
and each such variable is implicitly associated with an object that
contains a particular process ID, such the ID of the currently running
process or of the parent process.  (Presumably you'd name your variables
to remind you which process you're referring to.)  Variables are tied to
the class this way:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-15995"
>[17]</A
> UNIX priorities are associated with the word &quot;nice&quot; because they're
inverted from what you'd expect.  Higher priorities run slower, hence
are &quot;nicer&quot; to other processes.  A more portable module might prefer a
less UNIX-centric name like <CODE
CLASS="literal"
>Priority</CODE
>.  But if we were writing this
class for the Perl library, we'd probably call it <CODE
CLASS="literal"
>Tie::Priority</CODE
> or
some such, to fit the library's hierarchical naming scheme.  Not
everything can be a top-level class, or things will get rather confused.
Not to mention people.</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>use Nice;       # load the Nice.pm module

tie $his_speed, 'Nice', getppid();
tie $my_speed,  'Nice', $$;</PRE
><P
CLASS="para"
>Once the variables have been tied, their previous contents are no longer
accessible.  The internally forged connection between the variable and
the object takes precedence over ordinary variable semantics.</P
><P
CLASS="para"
>For example, let's say you copy a variable that's been tied:</P
><PRE
CLASS="programlisting"
>$speed = $his_speed;</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16004"
></A
>Instead of reading the value in the ordinary fashion from the
<CODE
CLASS="literal"
>$his_speed</CODE
> scalar variable, Perl implicitly calls the
<CODE
CLASS="literal"
>FETCH</CODE
> method on the associated underlying object.  It's as
though you'd written this:</P
><PRE
CLASS="programlisting"
>$speed = (tied $his_speed)-&gt;FETCH():</PRE
><P
CLASS="para"
>Or if you'd captured the object returned by the <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>, you
could simply use that reference instead of the <A
CLASS="xref"
HREF="ch03_172.htm"
TITLE="tied"
><B
CLASS="xref.cmd"
>tied</B
></A
> function, as in the following sample code.</P
><PRE
CLASS="programlisting"
>$myobj = tie $my_speed, 'Nice', $$;
$speed = $my_speed;       # through the implicit interface
$speed = $myobj-&gt;FETCH(); # same thing, explicitly</PRE
><P
CLASS="para"
>You can use <CODE
CLASS="literal"
>$myobj</CODE
> to call methods other than the implicit ones, such
as those provided by the <CODE
CLASS="literal"
>DB_File</CODE
> class (see <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
>).
However, one normally minds one's own business and leaves the underlying
object alone, which is why you often see the return value from <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>
ignored.  You can still get at it if you need it later.</P
><P
CLASS="para"
>That's the external view of it.  For our implementation, we'll use the
<CODE
CLASS="literal"
>BSD::Resource</CODE
> class (found in CPAN, but not included with
Perl) to access the <CODE
CLASS="literal"
>PRIO_PROCESS</CODE
>, <CODE
CLASS="literal"
>PRIO_MIN</CODE
>, and
<CODE
CLASS="literal"
>PRIO_MAX</CODE
> constants from your system.  Here's the
preamble of our class, which we will put into a file named <EM
CLASS="emphasis"
>Nice.pm</EM
>:</P
><PRE
CLASS="programlisting"
>package Nice;
use Carp;            # Propagates error messages nicely.
use BSD::Resource;   # Use these hooks into the OS.
use strict;          # Enforce some discipline on ourselves,
use vars '$DEBUG';   # but exempt $DEBUG from discipline.</PRE
><P
CLASS="para"
>The Carp module provides methods <CODE
CLASS="literal"
>carp()</CODE
>, <CODE
CLASS="literal"
>croak()</CODE
>,
and <CODE
CLASS="literal"
>confess()</CODE
>, which we'll use in various spots below.  As
usual, see <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
> for more about Carp.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16031"
></A
>The <CODE
CLASS="literal"
>use strict</CODE
> would ordinarily disallow the use of unqualified
package variables like <CODE
CLASS="literal"
>$DEBUG</CODE
>, but we then declared the global
with <CODE
CLASS="literal"
>use vars</CODE
>, so it's exempt.  Otherwise we'd have to say
<CODE
CLASS="literal"
>$Nice::DEBUG</CODE
> everywhere.  But it is a global, and other modules
can turn on debugging in our module by setting <CODE
CLASS="literal"
>$Nice::DEBUG</CODE
> to
some other value before using our module.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>TIESCALAR</CODE
> <CODE
CLASS="replaceable"
><I
>CLASSNAME</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16046"
></A
>The <CODE
CLASS="literal"
>TIESCALAR</CODE
> method of the class (that is, the
class package, but we're going to stop reminding you of that) is
implicitly invoked whenever <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> is
called on a scalar variable.  The <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> contains
any optional parameters needed to properly initialize an object of the
given class.  (In our example, there is only one parameter, the
process ID.)  The method is expected to return an object, which may or
may not contain an anonymous scalar as its blessed thingy.  In our
example, it does.</P
><PRE
CLASS="programlisting"
>sub TIESCALAR {
    my $class = shift;
    my $pid   = shift;

    $pid ||= $$;              # arg of 0 defaults to my process

    if ($pid =~ /\D/) {
        carp &quot;Nice::TIESCALAR got non-numeric pid $pid&quot; if $^W;
        return undef;
    }

    unless (kill 0, $pid) {   # EPERM or ERSCH, no doubt
        carp &quot;Nice::TIESCALAR got bad pid $pid: $!&quot; if $^W;
        return undef;
    }

    return bless \$pid, $class;
}</PRE
><P
CLASS="para"
>Recall that the statement with the <CODE
CLASS="literal"
>||=</CODE
> operator is just shorthand for</P
><PRE
CLASS="programlisting"
>$pid = $pid || $$;      # set if not set</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16056"
></A
><A
CLASS="indexterm"
NAME="AUTOID-16059"
></A
>We say the object contains an anonymous scalar, but it doesn't really
become anonymous until <CODE
CLASS="literal"
>my $pid</CODE
> goes out of scope, since that's the
variable we're generating a reference to when we bestow the blessing.
When returning a reference to an array or hash, one could use the same
approach by employing a lexically scoped array or hash variable, but
usually people just use the anonymous array or hash composers,
<CODE
CLASS="literal"
>[]</CODE
> and <CODE
CLASS="literal"
>{}</CODE
>.  There is no similar composer for anonymous
scalars.</P
><P
CLASS="para"
>On the subject of subterfuge, the <A
CLASS="xref"
HREF="ch03_080.htm"
TITLE="kill"
><B
CLASS="xref.cmd"
>kill</B
></A
> isn't really killing the
process.  On most UNIX systems, a signal 0 merely checks to see whether the
process is there.</P
><P
CLASS="para"
>This particular <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> class has chosen to return an error value rather
than raise an exception if its constructor fails.  Other classes may
not wish to be so forgiving.  (In any event, the <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
> itself will
throw an exception when the constructor fails to return an object.  But
you get more error messages this way, which many folks seem to prefer.)
This routine checks the global variable <B
CLASS="emphasis.bold"
>$^W</B
> (which reflects Perl's
<B
CLASS="emphasis.bold"
>-w</B
> flag) to see whether to emit its extra bit of noise.</P
><P
CLASS="para"
>But for all that, it's an ordinary constructor, and doesn't know it's being
called from <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>.  It just suspects it strongly.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>FETCH</CODE
> <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16080"
></A
>This method is triggered every time the tied variable is accessed
(that is, read).  It takes no arguments beyond a reference to the object
that is tied to the variable.  (The <CODE
CLASS="literal"
>FETCH</CODE
> methods for arrays and
hashes do, though.)  Since in this case we're just using a scalar
thingy as the tied object, a simple scalar dereference, <CODE
CLASS="literal"
>$$self</CODE
>,
allows the method to get at the real value stored in its object.  In the
example below, that real value is the process ID to which we've tied our
variable.</P
><PRE
CLASS="programlisting"
>sub FETCH {
    my $self = shift;       # ref to scalar

    confess &quot;wrong type&quot; unless ref $self;
    croak &quot;too many arguments&quot; if @_;

    my $nicety;
    local $! = 0;           # preserve errno
    $nicety = getpriority(PRIO_PROCESS, $$self);
    if ($!) { croak &quot;getpriority failed: $!&quot; }
    return $nicety;
}</PRE
><P
CLASS="para"
>This time we've decided to blow up (raise an exception) if the
<A
CLASS="xref"
HREF="ch03_057.htm"
TITLE="getpriority"
><B
CLASS="xref.cmd"
>getpriority</B
></A
> function fails&nbsp;- there's no place for us to return an
error otherwise, and it's probably the right thing to do.</P
><P
CLASS="para"
>Note the absence of a <CODE
CLASS="literal"
>$</CODE
> on <CODE
CLASS="literal"
>PRIO_PROCESS</CODE
>.  That's really a
subroutine call into <CODE
CLASS="literal"
>BSD::Resource</CODE
> that returns the appropriate constant
to feed back into <A
CLASS="xref"
HREF="ch03_057.htm"
TITLE="getpriority"
><B
CLASS="xref.cmd"
>getpriority</B
></A
>.  The <CODE
CLASS="literal"
>PRIO_PROCESS</CODE
>
declaration was imported by the <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> declaration.  And that's why
there's no <CODE
CLASS="literal"
>$</CODE
> on the front of it&nbsp;- it's not a variable.  (If you
had put a <CODE
CLASS="literal"
>$</CODE
>, the <CODE
CLASS="literal"
>use strict</CODE
> would have caught it for you
as an unqualified global.)</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>STORE</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, VALUE</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16103"
></A
>This method is triggered every time the tied variable is set
(assigned).  The first argument, <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
>, is again a reference to
the object associated with the variable, and <CODE
CLASS="replaceable"
><I
>VALUE</I
></CODE
> is the value the
user is assigning to the variable.</P
><PRE
CLASS="programlisting"
>sub STORE {
    my $self = shift;
    my $new_nicety = shift;

    confess &quot;wrong type&quot; unless ref $self;
    croak &quot;too many arguments&quot; if @_;

    if ($new_nicety &lt; PRIO_MIN) {
        carp sprintf
          &quot;WARNING: priority %d less than minimum system priority %d&quot;,
              $new_nicety, PRIO_MIN if $^W;
        $new_nicety = PRIO_MIN;
    }

    if ($new_nicety &gt; PRIO_MAX) {
        carp sprintf
          &quot;WARNING: priority %d greater than maximum system priority %d&quot;,
              $new_nicety, PRIO_MAX if $^W;
        $new_nicety = PRIO_MAX;
    }

    unless (defined setpriority(PRIO_PROCESS, $$self, $new_nicety)) {
        confess &quot;setpriority failed: $!&quot;;
    }
    return $new_nicety;
}</PRE
><P
CLASS="para"
>There doesn't appear to be anything worth explaining there, except maybe
that we return the new value because that's what an assignment returns.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>DESTROY</CODE
> <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16115"
></A
>This method is triggered when the object associated with the
tied variable needs to be destructed (usually only when it goes out of
scope).  As with other object classes, such a method is seldom necessary,
since Perl deallocates the moribund object's memory for you automatically.
Here, we'll use a <CODE
CLASS="literal"
>DESTROY</CODE
> method for debugging purposes only.</P
><PRE
CLASS="programlisting"
>sub DESTROY {
    my $self = shift;
    confess &quot;wrong type&quot; unless ref $self;
    carp &quot;[ Nice::DESTROY pid $$self ]&quot; if $DEBUG;
}</PRE
><P
CLASS="para"
>That's about all there is to it.  Actually, it's more than all there
is to it, since we've done a few nice things here for the sake
of completeness, robustness, and general aesthetics (or lack thereof).
Simpler <CODE
CLASS="literal"
>TIESCALAR</CODE
> classes are certainly possible.</P
></DD
></DL
><A
CLASS="indexterm"
NAME="AUTOID-16121"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-5-SECT-4.2"
>5.4.2 Tying Arrays</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH05.ARRAY"
></A
>A class implementing a tied ordinary array must define the following
methods: <CODE
CLASS="literal"
>TIEARRAY</CODE
>, <CODE
CLASS="literal"
>FETCH</CODE
>, <CODE
CLASS="literal"
>STORE</CODE
>, and perhaps
<CODE
CLASS="literal"
>DESTROY</CODE
>.</P
><P
CLASS="para"
>Tied arrays are incomplete.  There are, as yet,
no defined methods to deal with <CODE
CLASS="literal"
>$#ARRAY</CODE
> access
(which is hard, since it's an lvalue), nor with the other obvious
array functions, like <A
CLASS="xref"
HREF="ch03_112.htm"
TITLE="push"
><B
CLASS="xref.cmd"
>push</B
></A
>, <A
CLASS="xref"
HREF="ch03_108.htm"
TITLE="pop"
><B
CLASS="xref.cmd"
>pop</B
></A
>, <A
CLASS="xref"
HREF="ch03_143.htm"
TITLE="shift"
><B
CLASS="xref.cmd"
>shift</B
></A
>,
<A
CLASS="xref"
HREF="ch03_183.htm"
TITLE="unshift"
><B
CLASS="xref.cmd"
>unshift</B
></A
>, and <A
CLASS="xref"
HREF="ch03_154.htm"
TITLE="splice"
><B
CLASS="xref.cmd"
>splice</B
></A
>.  This means that a tied array doesn't
behave like an untied one.  You can't even determine the length of the
array.  But if you use the tied arrays only for simple read and write
access you'll be OK.  These restrictions will be removed in a future
release.</P
><P
CLASS="para"
>For the purpose of this discussion, we will implement an array whose indices are fixed at
its creation.  If you try to access anything beyond those bounds, you will
cause an exception.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>require Bounded_Array;
tie @ary, 'Bounded_Array', 2;   # maximum allowable subscript is 2
$| = 1;
for $i (0 .. 10) {
    print &quot;setting index $i: &quot;;
    $ary[$i] = 10 * $i;         # should raise exception on 3
    print &quot;value of element $i now $ary[$i]\n&quot;;
}</PRE
></P
><P
CLASS="para"
>The preamble code for the class is as follows:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>package Bounded_Array;
use Carp;
use strict;</PRE
></P
><P
CLASS="para"
></P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>TIEARRAY</CODE
> <CODE
CLASS="replaceable"
><I
>CLASSNAME</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16154"
></A
>This is the constructor for the class.  That means it is expected to
return a blessed reference through which the new array (probably an
anonymous array reference) will be accessed.</P
><P
CLASS="para"
>In our example, just to demonstrate that you don't really have to
use an array thingy, we'll choose a hash thingy to
represent our object.  A hash works out well as a generic record type:
the <CODE
CLASS="literal"
>{BOUND}</CODE
> field will store the maximum bound allowed, and the
<CODE
CLASS="literal"
>{ARRAY}</CODE
> field will hold the true array reference.  Anyone outside
the class who tries to dereference the object returned (doubtless thinking
it an array reference), will blow up.  This just goes to show
that you should respect an object's privacy (unless you're well
acquainted and committed to maintaining a good relationship for the
rest of your life).</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub TIEARRAY {
    my $class = shift;
    my $bound = shift;

    confess &quot;usage: tie(\@ary, 'Bounded_Array', max_subscript)&quot;
        if @_ or $bound =~ /\D/;

    return bless {
        BOUND =&gt; $bound,
        ARRAY =&gt; [],
    }, $class;
}</PRE
></P
><P
CLASS="para"
>In this case we have used the anonymous hash composer rather than a
lexically scoped variable that goes out of scope.  We also used the
array composer within the hash composer.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>FETCH</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, INDEX</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16168"
></A
>This method will be triggered every time an individual element in the
tied array is accessed (read).  It takes one argument beyond its self
reference: the index we're trying to fetch.  (The index is an
integer, but just because the caller thinks of it as a mundane integer
doesn't mean you have to do anything &quot;linear&quot; with it.
You could use it to seed a random number generator, for instance, or
process it with a hash function to do a random lookup in a hash table.)</P
><P
CLASS="para"
>Here we use list assignment rather than <A
CLASS="xref"
HREF="ch03_143.htm"
TITLE="shift"
><B
CLASS="xref.cmd"
>shift</B
></A
> to process the
method arguments.  TMTOWTDI.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub FETCH {
    my ($self, $idx) = @_;
    if ($idx &gt; $self-&gt;{BOUND}) {
        confess &quot;Array OOB: $idx &gt; $self-&gt;{BOUND}&quot;;
    }
    return $self-&gt;{ARRAY}[$idx];
}</PRE
></P
><P
CLASS="para"
>As you may have noticed, the names of the <CODE
CLASS="literal"
>FETCH</CODE
>, <CODE
CLASS="literal"
>STORE</CODE
>, and
<CODE
CLASS="literal"
>DESTROY</CODE
> methods are
the same for all tied classes, even though the constructors differ in name
(<CODE
CLASS="literal"
>TIESCALAR</CODE
> versus <CODE
CLASS="literal"
>TIEARRAY</CODE
>).  While in theory you could have the
same class servicing several tied types, in practice this becomes
cumbersome, and it's easiest to simply write them with one type per
class.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>STORE</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, INDEX, VALUE</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16186"
></A
>This method will be triggered every time an element in the tied array is set
(written).  It takes two arguments beyond its self reference: the index at
which we're trying to store something and the value we're trying to put
there.  For example:</P
><PRE
CLASS="programlisting"
>sub STORE {
    my ($self, $idx, $value) = @_;
    if ($idx &gt; $self-&gt;{BOUND} ) {
        confess &quot;Array OOB: $idx &gt; $self-&gt;{BOUND}&quot;;
    }
    return $self-&gt;{ARRAY}[$idx] = $value;
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>DESTROY</CODE
> <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16195"
></A
>This method will be triggered when the tied object needs to be
deallocated.  As with the scalar tie class, this is almost never needed
in a language that does its own storage allocation, so this time we'll
just leave it out.</P
><P
CLASS="para"
>The code we presented at the beginning of this section attempts several
out-of-bounds accesses.  It will therefore generate the following output:</P
><PRE
CLASS="programlisting"
>setting index 0: value of element 0 now 0
setting index 1: value of element 1 now 10
setting index 2: value of element 2 now 20
setting index 3: Array OOB: 3 &gt; 2 at Bounded_Array.pm line 39
        Bounded_Array::FETCH called at testba line 12</PRE
><A
CLASS="indexterm"
NAME="AUTOID-16199"
></A
></DD
></DL
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-5-SECT-4.3"
>5.4.3 Tying Hashes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH05.HASH"
></A
><A
CLASS="indexterm"
NAME="AUTOID-16206"
></A
>For historical reasons, hashes have the most complete and useful <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>
implementation.  A class implementing a tied associative array must
define various methods.  <CODE
CLASS="literal"
>TIEHASH</CODE
> is the constructor.  <CODE
CLASS="literal"
>FETCH</CODE
> and
<CODE
CLASS="literal"
>STORE</CODE
> access the key/value pairs.  <CODE
CLASS="literal"
>EXISTS</CODE
> reports
whether a key is present in the hash, and <CODE
CLASS="literal"
>DELETE</CODE
> deletes one.
<CODE
CLASS="literal"
>CLEAR</CODE
> empties the hash by deleting all the key/value pairs.
<CODE
CLASS="literal"
>FIRSTKEY</CODE
> and <CODE
CLASS="literal"
>NEXTKEY</CODE
> implement the <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
> and
<A
CLASS="xref"
HREF="ch03_030.htm"
TITLE="each"
><B
CLASS="xref.cmd"
>each</B
></A
> built-in functions to iterate over all the keys.  And
<CODE
CLASS="literal"
>DESTROY</CODE
> (if defined) is called when the tied object is
deallocated.</P
><P
CLASS="para"
>If this seems like a lot, then feel free to inherit most of these
methods from the standard Tie::Hash module, redefining only the
interesting ones.  See the Tie::Hash module documentation in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
> for
details.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16224"
></A
><A
CLASS="indexterm"
NAME="AUTOID-16226"
></A
>Remember that Perl distinguishes a key not existing in the hash from
a key that exists with an undefined value.
The two possibilities can be tested with the <A
CLASS="xref"
HREF="ch03_034.htm"
TITLE="exists"
><B
CLASS="xref.cmd"
>exists</B
></A
> and
<A
CLASS="xref"
HREF="ch03_025.htm"
TITLE="defined"
><B
CLASS="xref.cmd"
>defined</B
></A
> functions, respectively.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16231"
></A
>Because functions like <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
> and <A
CLASS="xref"
HREF="ch03_187.htm"
TITLE="values"
><B
CLASS="xref.cmd"
>values</B
></A
> may return huge array
values when used on large hashes (like tied DBM files), you may
prefer to use the <A
CLASS="xref"
HREF="ch03_030.htm"
TITLE="each"
><B
CLASS="xref.cmd"
>each</B
></A
> function to iterate over such.
For example:</P
><PRE
CLASS="programlisting"
># print out B-news history file offsets
use NDBM_File;
tie(%HIST, 'NDBM_File', '/usr/lib/news/history', 1, 0);
while (($key,$val) = each %HIST) {
    print $key, ' = ', unpack('L',$val), &quot;\n&quot;;
}
untie(%HIST);</PRE
><P
CLASS="para"
>(But does anyone run B-news any more?)</P
><P
CLASS="para"
>Here's an example of a somewhat peculiar tied hash class:  it gives you
a hash representing a particular user's dotfiles (that is, files whose
names begin with a period).  You index into the hash
with the name of the file (minus the period) and you get back that dotfile's
contents.  For example:</P
><PRE
CLASS="programlisting"
>use DotFiles;
tie %dot, &quot;DotFiles&quot;;
if ( $dot{profile} =~ /MANPATH/ or
     $dot{login}   =~ /MANPATH/ or
     $dot{cshrc}   =~ /MANPATH/    )
{
    print &quot;you've set your manpath\n&quot;;
}</PRE
><P
CLASS="para"
>Here's another way to use our tied class:</P
><PRE
CLASS="programlisting"
># third argument is name of user whose dot files we will tie to
tie %him, 'DotFiles', 'daemon';
foreach $f ( keys %him ) {
    printf &quot;daemon dot file %s is size %d\n&quot;,
        $f, length $him{$f};
}</PRE
><P
CLASS="para"
>In our DotFiles example we implement the object as a regular hash
containing several important fields, of which only the <CODE
CLASS="literal"
>{CONTENTS}</CODE
>
field will be what the user thinks of as the real hash.  Here are the
fields:</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>USER</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Whose dot files this object represents</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>HOME</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Where those dotfiles live</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>CLOBBER</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>Whether we are allowed to change or remove those dot files</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>CONTENTS</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>The hash of dotfile names and content mappings</P
></DD
></DL
><P
CLASS="para"
>Here's the start of <EM
CLASS="emphasis"
>DotFiles.pm</EM
>:</P
><PRE
CLASS="programlisting"
>package DotFiles;
use Carp;
sub whowasi { (caller(1))[3] . '()' }
my $DEBUG = 0;
sub debug { $DEBUG = @_ ? shift : 1 }</PRE
><P
CLASS="para"
>For our example, we want to be able to emit debugging information to help in
tracing during development.  We also keep one convenience function around
internally to help print out warnings; <CODE
CLASS="literal"
>whowasi()</CODE
> returns the name
of the function that called the current function (<CODE
CLASS="literal"
>whowasi()</CODE
>'s
&quot;grandparent&quot; function).</P
><P
CLASS="para"
>Here are the methods for the DotFiles tied hash.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>TIEHASH</CODE
> <CODE
CLASS="replaceable"
><I
>CLASSNAME</I
></CODE
>, <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16280"
></A
>This is the constructor for the class.  That means it is expected to
return a blessed reference through which the new object may be accessed.
Again, the user of the tied class probably has little need of the object.
It's Perl itself that needs the returned object so that it can magically
call the right methods when the tied variable is accessed.</P
><P
CLASS="para"
>Here's the constructor:</P
><PRE
CLASS="programlisting"
>sub TIEHASH {
    my $self = shift;
    my $user = shift || $&gt;;
    my $dotdir = shift || &quot;&quot;;

    croak &quot;usage: @{[&amp;whowasi]} [USER [DOTDIR]]&quot; if @_;

    $user = getpwuid($user) if $user =~ /^\d+$/;
    my $dir = (getpwnam($user))[7]
            or croak &quot;@{[&amp;whowasi]}: no user $user&quot;;
    $dir .= &quot;/$dotdir&quot; if $dotdir;

    my $node = {
        USER        =&gt; $user,
        HOME        =&gt; $dir,
        CONTENTS    =&gt; {},
        CLOBBER     =&gt; 0,
    };

    opendir DIR, $dir
            or croak &quot;@{[&amp;whowasi]}: can't opendir $dir: $!&quot;;
    foreach $dot ( grep /^\./ &amp;&amp; -f &quot;$dir/$_&quot;, readdir(DIR)) {
        $dot =~ s/^\.//;
        $node-&gt;{CONTENTS}{$dot} = undef;
    }
    closedir DIR;

    return bless $node, $self;
}</PRE
><P
CLASS="para"
>It's probably worth mentioning that if you're going to filetest the
return values returned by that <A
CLASS="xref"
HREF="ch03_117.htm"
TITLE="readdir"
><B
CLASS="xref.cmd"
>readdir</B
></A
>, you'd better prepend the
directory in question (as we do).  Otherwise, since no <A
CLASS="xref"
HREF="ch03_011.htm"
TITLE="chdir"
><B
CLASS="xref.cmd"
>chdir</B
></A
> was
done, you'd test the wrong file.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>FETCH</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, KEY</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16293"
></A
>This method will be triggered every time an element in the tied hash is
accessed (read).  It takes one argument beyond its self reference: the key
whose value we're trying to fetch.  The key is a string, and you can
do anything you like with it (consistent with its being a string).</P
><P
CLASS="para"
>Here's the fetch for our DotFiles example.</P
><PRE
CLASS="programlisting"
>sub FETCH {
    carp &amp;whowasi if $DEBUG;
    my $self = shift;
    my $dot = shift;
    my $dir = $self-&gt;{HOME};
    my $file = &quot;$dir/.$dot&quot;;

    unless (exists $self-&gt;{CONTENTS}-&gt;{$dot} || -f $file) {
        carp &quot;@{[&amp;whowasi]}: no $dot file&quot; if $DEBUG;
        return undef;
    }

    # Implement a cache.
    if (defined $self-&gt;{CONTENTS}-&gt;{$dot}) {
        return $self-&gt;{CONTENTS}-&gt;{$dot};
    } else {
        return $self-&gt;{CONTENTS}-&gt;{$dot} = `cat $dir/.$dot`;
    }
}</PRE
><P
CLASS="para"
>This function was easy to write by having it call the UNIX
<EM
CLASS="emphasis"
>cat</EM
>(1) command, but it would be more portable (and
somewhat more efficient) to open the file ourselves.  On the other hand,
since dot files are a UNIXy concept, we're not that concerned.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>STORE</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, KEY, VALUE</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16305"
></A
>This method will be triggered every time an element in the tied hash is set
(written).  It takes two arguments beyond its self reference: the key under
which we're storing the value and the value we're putting there.</P
><P
CLASS="para"
>Here in our DotFiles example we won't let users overwrite a file without
first calling the <CODE
CLASS="literal"
>clobber()</CODE
>
method on the original object reference returned by <A
CLASS="xref"
HREF="ch03_171.htm"
TITLE="tie"
><B
CLASS="xref.cmd"
>tie</B
></A
>.</P
><PRE
CLASS="programlisting"
>sub STORE {
    carp &amp;whowasi if $DEBUG;
    my $self = shift;
    my $dot = shift;
    my $value = shift;
    my $file = $self-&gt;{HOME} . &quot;/.$dot&quot;;

    croak &quot;@{[&amp;whowasi]}: $file not clobberable&quot;
        unless $self-&gt;{CLOBBER};

    open(F, &quot;&gt; $file&quot;) or croak &quot;can't open $file: $!&quot;;
    print F $value;
    close(F);
}</PRE
><P
CLASS="para"
>If they want to clobber something, they can say:</P
><PRE
CLASS="programlisting"
>$ob = tie %daemon_dots, 'daemon';
$ob-&gt;clobber(1);
$daemon_dots{signature} = &quot;A true daemon\n&quot;;</PRE
><P
CLASS="para"
>But there's also the <A
CLASS="xref"
HREF="ch03_172.htm"
TITLE="tied"
><B
CLASS="xref.cmd"
>tied</B
></A
> function, so they could alternatively
set <CODE
CLASS="literal"
>clobber</CODE
> using:</P
><PRE
CLASS="programlisting"
>tie %daemon_dots, 'daemon';
tied(%daemon_dots)-&gt;clobber(1);</PRE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>clobber</CODE
> method is simply:</P
><PRE
CLASS="programlisting"
>sub clobber {
    my $self = shift;
    $self-&gt;{CLOBBER} = @_ ? shift : 1;
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>DELETE</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, KEY</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16326"
></A
>This method is triggered when we remove an element from the hash,
typically by using the <A
CLASS="xref"
HREF="ch03_026.htm"
TITLE="delete"
><B
CLASS="xref.cmd"
>delete</B
></A
> function.  Again, we'll
be careful to check whether the user really wants to clobber files.</P
><PRE
CLASS="programlisting"
>sub DELETE   {
    carp &amp;whowasi if $DEBUG;

    my $self = shift;
    my $dot = shift;
    my $file = $self-&gt;{HOME} . &quot;/.$dot&quot;;
    croak &quot;@{[&amp;whowasi]}: won't remove file $file&quot;
        unless $self-&gt;{CLOBBER};
    delete $self-&gt;{CONTENTS}-&gt;{$dot};
    unlink $file or carp &quot;@{[&amp;whowasi]}: can't unlink $file: $!&quot;;
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>CLEAR</CODE
> <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16336"
></A
>This method is triggered when the whole hash is to be cleared, usually by
assigning the empty list to it.</P
><P
CLASS="para"
>In our example, that would remove all the user's dotfiles!  It's such a
dangerous thing that we'll require <CODE
CLASS="literal"
>CLOBBER</CODE
>
to be set higher than <CODE
CLASS="literal"
>1</CODE
> before this can happen.</P
><PRE
CLASS="programlisting"
>sub CLEAR {
    carp &amp;whowasi if $DEBUG;
    my $self = shift;
    croak &quot;@{[&amp;whowasi]}: won't remove all dotfiles for $self-&gt;{USER}&quot;
        unless $self-&gt;{CLOBBER} &gt; 1;
    my $dot;
    foreach $dot ( keys %{$self-&gt;{CONTENTS}}) {
        $self-&gt;DELETE($dot);
    }
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>EXISTS</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, KEY</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16348"
></A
>This method is triggered when the user invokes the <A
CLASS="xref"
HREF="ch03_034.htm"
TITLE="exists"
><B
CLASS="xref.cmd"
>exists</B
></A
> function
on a particular hash.  In our example, we'll look at the <CODE
CLASS="literal"
>{CONTENTS}</CODE
>
hash element to find the answer:</P
><PRE
CLASS="programlisting"
>sub EXISTS   {
    carp &amp;whowasi if $DEBUG;
    my $self = shift;
    my $dot = shift;
    return exists $self-&gt;{CONTENTS}-&gt;{$dot};
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>FIRSTKEY</CODE
> <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16359"
></A
>This method is triggered when the user begins to iterate through the
hash, such as with a <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
> or <A
CLASS="xref"
HREF="ch03_030.htm"
TITLE="each"
><B
CLASS="xref.cmd"
>each</B
></A
> call.  By calling <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
> in a scalar context, we reset its internal
state to ensure that the next <A
CLASS="xref"
HREF="ch03_030.htm"
TITLE="each"
><B
CLASS="xref.cmd"
>each</B
></A
> used
in the <A
CLASS="xref"
HREF="ch03_125.htm"
TITLE="return"
><B
CLASS="xref.cmd"
>return</B
></A
> statement will get the
first key.</P
><PRE
CLASS="programlisting"
>sub FIRSTKEY {
    carp &amp;whowasi if $DEBUG;
    my $self = shift;
    my $a    = keys %{$self-&gt;{CONTENTS}};
    return scalar each %{$self-&gt;{CONTENTS}};
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>NEXTKEY</CODE
> <CODE
CLASS="replaceable"
><I
>THIS, LASTKEY</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16373"
></A
>This method is triggered during a <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
>
or <A
CLASS="xref"
HREF="ch03_030.htm"
TITLE="each"
><B
CLASS="xref.cmd"
>each</B
></A
> iteration.  It has a second
argument which is the last key that has been accessed.  This is useful
if the <CODE
CLASS="literal"
>NEXTKEY</CODE
> method needs to know its previous
state to calculate the next state.</P
><P
CLASS="para"
>For our example, we are using a real hash to represent the tied
hash's data, except that this hash is stored in the hash's
<CODE
CLASS="literal"
>CONTENTS</CODE
> field instead of in the hash itself.  So we can just
rely on Perl's <A
CLASS="xref"
HREF="ch03_030.htm"
TITLE="each"
><B
CLASS="xref.cmd"
>each</B
></A
> iterator:</P
><PRE
CLASS="programlisting"
>sub NEXTKEY  {
    carp &amp;whowasi if $DEBUG;
    my $self = shift;
    return scalar each %{ $self-&gt;{CONTENTS} }
}</PRE
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>DESTROY</CODE
> <CODE
CLASS="replaceable"
><I
>THIS</I
></CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-16388"
></A
>This method is triggered when a tied hash's object is about to be
deallocated.  You don't really need it except for debugging and extra
cleanup.  Here's a very simple
function:</P
><PRE
CLASS="programlisting"
>sub DESTROY  {
    carp &amp;whowasi if $DEBUG;
}</PRE
><A
CLASS="indexterm"
NAME="AUTOID-16391"
></A
><A
CLASS="indexterm"
NAME="AUTOID-16392"
></A
><A
CLASS="indexterm"
NAME="AUTOID-16393"
></A
><A
CLASS="indexterm"
NAME="AUTOID-16394"
></A
></DD
></DL
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_03.htm"
TITLE="5.3 Objects"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 5.3 Objects"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch05_05.htm"
TITLE="5.5 Some Hints About Object Design"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 5.5 Some Hints About Object Design"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>5.3 Objects</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>5.5 Some Hints About Object Design</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
