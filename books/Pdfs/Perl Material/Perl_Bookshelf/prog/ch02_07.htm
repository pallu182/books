<HTML
><HEAD
>
<TITLE>[Chapter 2] 2.7 Subroutines</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:44:24Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"><LINK
REL="prev"
HREF="ch02_06.htm"
TITLE="2.6 Statements and Declarations"><LINK
REL="next"
HREF="ch02_08.htm"
TITLE="2.8 Formats"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_06.htm"
TITLE="2.6 Statements and Declarations"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.6 Statements and Declarations"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"
>Chapter 2<BR>The Gory Details</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_08.htm"
TITLE="2.8 Formats"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.8 Formats"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-7"
>2.7 Subroutines</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.SUB"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6766"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6769"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6772"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6775"
></A
>Like many languages, Perl provides for user-defined subroutines.  (We'll
also call them <EM
CLASS="emphasis"
>functions</EM
>, but functions are the
same thing as subroutines in Perl.)
These subroutines may be defined anywhere in the main program, loaded in
from other files via the <A
CLASS="xref"
HREF="ch03_028.htm"
TITLE="do"
><B
CLASS="xref.cmd"
>do</B
></A
>, <A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>, or <A
CLASS="xref"
HREF="ch03_185.htm"
TITLE="use"
><B
CLASS="xref.cmd"
>use</B
></A
> keywords, or even
generated on the fly using <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>.  You can generate anonymous
subroutines, accessible only through references.  You can even call a
subroutine indirectly using a variable containing either its name or a
reference to the routine.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6784"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6787"
></A
>To declare a subroutine, use one of these forms:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub <CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
>;              # A &quot;forward&quot; declaration.
sub <CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
> (<CODE
CLASS="replaceable"
><I
>PROTO</I
></CODE
>);      # Ditto, but with prototype.</PRE
></P
><P
CLASS="para"
>To declare and define a subroutine, use one of these forms:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub <CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
> <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>         # A declaration and a definition.
sub <CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
> (<CODE
CLASS="replaceable"
><I
>PROTO</I
></CODE
>) <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
> # Ditto, but with prototype.</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6803"
></A
>To define an anonymous subroutine or closure at run-time, use a statement
like:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$subref = sub <CODE
CLASS="replaceable"
><I
>BLOCK</I
></CODE
>;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6810"
></A
>To import subroutines defined in another package, say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>use <CODE
CLASS="replaceable"
><I
>PACKAGE</I
></CODE
> qw(<CODE
CLASS="replaceable"
><I
>NAME1 NAME2 NAME3</I
></CODE
>...);</PRE
></P
><P
CLASS="para"
>To call subroutines directly:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
><CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
>(<CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>);            # &amp; is optional with parentheses.
<CODE
CLASS="replaceable"
><I
>NAME</I
></CODE
> <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>;             # Parens optional if predeclared/imported.
&amp;<CODE
CLASS="replaceable"
><I
>NAME;</I
></CODE
>                 # Passes current @_ to subroutine.</PRE
></P
><P
CLASS="para"
>To call subroutines indirectly (by name or by reference):</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>&amp;$subref(<CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>);        # &amp; is not optional on indirect call.
&amp;$subref;              # Passes current @_ to subroutine.</PRE
></P
><P
CLASS="para"
>The Perl model for passing data into and out of a subroutine is simple:
all function parameters are passed as one single, flat list of scalars,
and multiple return values are likewise returned to the caller as one single, flat
list of scalars.  As with any <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>, any arrays or hashes passed in these
lists will interpolate their values into the flattened list, losing
their identities&nbsp;- but there are several ways to get around this, and the
automatic list interpolation is frequently quite useful.  Both parameter
lists and return lists may contain as many or as few scalar elements as
you'd like (though you may put constraints on the parameter list using
prototypes).  Indeed, Perl is designed around this notion of <EM
CLASS="emphasis"
>variadic</EM
>
functions (those taking any number of arguments), unlike C, where they're sort of grudgingly kludged in so that
you can call <EM
CLASS="emphasis"
>printf</EM
>(3).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6834"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6837"
></A
>Now, if you're going to design a language around the notion of passing
varying numbers of arbitrary arguments, you'd better make it easy to
process those arbitrary lists of arguments.  In the interests of dealing
with the function parameters as a list, any arguments passed to a
Perl routine come in as the array <CODE
CLASS="literal"
>@_</CODE
>.  If you call a function with
two arguments, those would be stored in <CODE
CLASS="literal"
>$_[0]</CODE
> and <CODE
CLASS="literal"
>$_[1]</CODE
>.
Since <CODE
CLASS="literal"
>@_</CODE
> is an array, you can use any array operations you like
on the parameter list.  (This is an area where Perl is <EM
CLASS="emphasis"
>more</EM
>
orthogonal than the typical computer language.)  The array <CODE
CLASS="literal"
>@_</CODE
> is a
local array, but its values are implicit references to the actual scalar
parameters.  Thus you can modify the actual parameters if you modify the
corresponding element of <CODE
CLASS="literal"
>@_</CODE
>.  (This is rarely done, however,
since it's so easy to return interesting values in Perl.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6848"
></A
>The return value of the subroutine (or of any other block, for that
matter) is the value of the last expression evaluated.  Or you may use
an explicit <B
CLASS="emphasis.bold"
>return</B
> statement to specify the return value and exit the
subroutine from any point in the subroutine.  Either way, as the
subroutine is called in a scalar or list context, so also is the final
expression of the routine evaluated in the same scalar or list context.</P
><P
CLASS="para"
>Perl does not have named formal parameters, but in practice all you do is
assign the contents of <CODE
CLASS="literal"
>@_</CODE
> to a <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> list, which serves nicely for
a list of formal parameters.  But you don't have to, which is the whole
point of the <CODE
CLASS="literal"
>@_</CODE
> array.  </P
><P
CLASS="para"
>For example, to calculate a maximum, the
following routine just iterates over <CODE
CLASS="literal"
>@_</CODE
> directly:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub max {
    my $max = shift(@_);
    foreach $foo (@_) {
        $max = $foo if $max &lt; $foo;
    }
    return $max;
}
$bestday = max($mon,$tue,$wed,$thu,$fri);</PRE
></P
><P
CLASS="para"
>Here's a routine that ignores its parameters entirely, since it wants to
keep a global lookahead variable:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># Get a line, combining continuation lines that start with whitespace

sub get_line {
    my $thisline = $LOOKAHEAD;
    LINE: while ($LOOKAHEAD = &lt;STDIN&gt;) {
        if ($LOOKAHEAD =~ /^[ \t]/) {
            $thisline .= $LOOKAHEAD;
        }
        else {
            last LINE;
        }
    }
    $thisline;
}

$LOOKAHEAD = &lt;STDIN&gt;;       # get first line
while ($_ = get_line()) {
    ...
}</PRE
></P
><P
CLASS="para"
>Use list assignment to a private list to name your formal arguments:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub maybeset {
    my($key, $value) = @_;
    $Foo{$key} = $value unless $Foo{$key};
}</PRE
></P
><P
CLASS="para"
>This also has the effect of turning call-by-reference into call-by-value
(to borrow some fancy terms from computer science), since the assignment copies
the values.</P
><P
CLASS="para"
>Here's an example of <EM
CLASS="emphasis"
>not</EM
> naming your formal arguments, so that you
can modify your actual arguments:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>upcase_in($v1, $v2);  # this changes $v1 and $v2
sub upcase_in {
    for (@_) { tr/a-z/A-Z/ } 
}</PRE
></P
><P
CLASS="para"
>You aren't allowed to modify constants in this way, of course.  If an
argument were actually a literal and you tried to change it, you'd take an
exception (presumably fatal, possibly career-threatening).   For
example, this won't work:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>upcase_in(&quot;frederick&quot;);</PRE
></P
><P
CLASS="para"
>It would be much safer if the <CODE
CLASS="literal"
>upcase_in()</CODE
> function were written to
return a copy of its parameters instead of changing them in place:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($v3, $v4) = upcase($v1, $v2);
sub upcase {
    my @parms = @_;
    for (@parms) { tr/a-z/A-Z/ } 
    # wantarray checks whether we were called in list context
    return wantarray ? @parms : $parms[0];
}</PRE
></P
><P
CLASS="para"
>Notice how this (unprototyped) function doesn't care whether it was passed
real scalars or arrays.  Perl will see everything as one big, long, flat
<CODE
CLASS="literal"
>@_</CODE
> parameter list.  This is one of the ways where Perl's simple
argument-passing style shines.  The <CODE
CLASS="literal"
>upcase</CODE
> function will work
perfectly well without changing the <CODE
CLASS="literal"
>upcase</CODE
> definition even if we feed
it things like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@newlist   = upcase(@list1, @list2);
@newlist   = upcase( split /:/, $var );</PRE
></P
><P
CLASS="para"
>Do not, however, be tempted to do this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(@a, @b)   = upcase(@list1, @list2);   # WRONG</PRE
></P
><P
CLASS="para"
>Why not? Because, like the flat incoming parameter list, the return list is also
flat.  So all you have managed to do here is store everything in
<CODE
CLASS="literal"
>@a</CODE
> and make <CODE
CLASS="literal"
>@b</CODE
> an empty list.
See the later section on &quot;Passing References&quot; for alternatives.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6890"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6893"
></A
>The official name of a subroutine includes the <CODE
CLASS="literal"
>&amp;</CODE
> prefix.  A
subroutine may be called using the prefix, but the <CODE
CLASS="literal"
>&amp;</CODE
> is usually
optional, and so are the parentheses if the subroutine has been predeclared.
(Note, however, that the <CODE
CLASS="literal"
>&amp;</CODE
> is not optional when you're
just naming the subroutine, such as when it's used as an argument to
<A
CLASS="xref"
HREF="ch03_025.htm"
TITLE="defined"
><B
CLASS="xref.cmd"
>defined</B
></A
> or <A
CLASS="xref"
HREF="ch03_180.htm"
TITLE="undef"
><B
CLASS="xref.cmd"
>undef</B
></A
>, or when you want to generate a reference
to a named subroutine by saying <CODE
CLASS="literal"
>$subref = \&amp;name</CODE
>.  Nor is the
<CODE
CLASS="literal"
>&amp;</CODE
> optional when you want to do an indirect subroutine call with
a subroutine name or reference using the <CODE
CLASS="literal"
>&amp;$subref()</CODE
> or
<CODE
CLASS="literal"
>&amp;{$subref}()</CODE
> constructs.  See <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
> for more on that.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6907"
></A
>Subroutines may be called recursively.  If a subroutine is called using
the <CODE
CLASS="literal"
>&amp;</CODE
> form, the argument list is optional, and if omitted, no <CODE
CLASS="literal"
>@_</CODE
>
array is set up for the subroutine: the <CODE
CLASS="literal"
>@_</CODE
> array of the calling
routine at the time of the call is visible to called subroutine instead.
This is an efficiency mechanism that new users may wish to avoid.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>&amp;foo(1,2,3);    # pass three arguments
foo(1,2,3);     # the same

foo();          # pass a null list
&amp;foo();         # the same

&amp;foo;           # foo() gets current args, like foo(@_) !!
foo;            # like foo() if sub foo pre-declared, else bareword &quot;foo&quot;</PRE
></P
><P
CLASS="para"
>Not only does the <CODE
CLASS="literal"
>&amp;</CODE
> form make the argument list optional, but it also
disables any prototype checking on the arguments you do provide.  This
is partly for historical reasons, and partly for having a convenient way
to cheat if you know what you're doing.  See the section on
&quot;Prototypes&quot; later in this chapter.</P
><P
CLASS="para"
>Any variables you use in the function that aren't declared private are
global variables.  For more on creating private variables,
see <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-7.1"
>2.7.1 Passing Symbol Table Entries (Typeglobs)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6923"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6925"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6927"
></A
>Note that the mechanism described in this section was originally the only
way to simulate pass-by-reference in older versions of Perl.  While it
still works fine in modern versions, the new reference mechanism is
generally easier to work with.  See below.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6931"
></A
><A
CLASS="indexterm"
NAME="AUTOID-6934"
></A
>Sometimes you don't want to pass the value of an array to a subroutine
but rather the name of it, so that the subroutine can modify the global
copy of it rather than working with a local copy.  In Perl you can
refer to all objects of a particular name by prefixing the name
with a star: <CODE
CLASS="literal"
>*foo</CODE
>.  This is often known as a <EM
CLASS="emphasis"
>typeglob</EM
>, since the
star on the front can be thought of as a wildcard match for all the
funny prefix characters on variables and subroutines and such.</P
><P
CLASS="para"
>When evaluated, a typeglob produces a scalar value that represents all
the objects of that name, including any scalar, array, or hash variable,
and also any filehandle, format, or subroutine.  When assigned to, a typeglob
sets up its own name to be an alias for whatever typeglob value was
assigned to it.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub doubleary {
    local(*someary) = @_;
    foreach $elem (@someary) {
        $elem *= 2;
    }
}
doubleary(*foo);
doubleary(*bar);</PRE
></P
><P
CLASS="para"
>Note that scalars are already passed by reference, so you can modify
scalar arguments without using this mechanism by referring explicitly
to <CODE
CLASS="literal"
>$_[0]</CODE
>, and so on.  You can modify all the elements of an array by passing
all the elements as scalars, but you have to use the <CODE
CLASS="literal"
>*</CODE
> mechanism (or
the equivalent reference mechanism described below)
to <B
CLASS="emphasis.bold"
>push</B
>, <B
CLASS="emphasis.bold"
>pop</B
>, or change the size of
an array.  It will certainly be faster to pass the typeglob (or reference)
than to push a bunch of scalars onto the argument stack only to pop
them all back off again.</P
><P
CLASS="para"
>Even if you don't want to modify an array, this mechanism is useful for
passing multiple arrays in a single <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>, since normally the
<CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>
mechanism will flatten all the list values so that you can't extract out
the individual arrays.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-7.2"
>2.7.2 Passing References</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.PASS1"
></A
><A
CLASS="indexterm"
NAME="CH02.PASS2"
></A
>If you want to pass more than one array or hash into or out of a function
and have them maintain their integrity, then you're
going to want to use an explicit pass-by-reference.  Before you do that,
you need to understand references as detailed in <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
>.  This
section may not make much sense to you otherwise.  But hey, you can
always look at the pictures.</P
><P
CLASS="para"
>Here are a few simple examples.  First, let's pass in several
arrays to a function and have it <B
CLASS="emphasis.bold"
>pop</B
> each of them, returning a new
list of all their former last elements:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@tailings = popmany ( \@a, \@b, \@c, \@d );

sub popmany {
    my $aref;
    my @retlist = ();
    foreach $aref ( @_ ) {
        push @retlist, pop @$aref;
    } 
    return @retlist;
}</PRE
></P
><P
CLASS="para"
>Here's how you might write a function that returns a 
list of keys occurring in all the hashes passed to it:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@common = inter( \%foo, \%bar, \%joe ); 
sub inter {
    my ($k, $href, %seen); # locals
    foreach $href (@_) {
        while ( ($k) = each %$href ) {
            $seen{$k}++;
        } 
    } 
    return grep { $seen{$_} == @_ } keys %seen;
}</PRE
></P
><P
CLASS="para"
>So far, we're just using the normal list return mechanism.
What happens if you want to pass or return a hash?  Well, 
if you're only using one of them, or you don't mind them 
concatenating, then the normal calling convention is OK, although
a little expensive.</P
><P
CLASS="para"
>Where people get into trouble is here:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(@a, @b) = func(@c, @d);</PRE
></P
><P
CLASS="para"
>or here:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(%a, %b) = func(%c, %d);</PRE
></P
><P
CLASS="para"
>That syntax simply won't work.  It just sets <CODE
CLASS="literal"
>@a</CODE
> or <CODE
CLASS="literal"
>%a</CODE
> and clears
<CODE
CLASS="literal"
>@b</CODE
> or <CODE
CLASS="literal"
>%b</CODE
>.  Plus the function doesn't get two
separate arrays or hashes as arguments: it gets one long list in <CODE
CLASS="literal"
>@_</CODE
>,
as always.</P
><P
CLASS="para"
>If you can arrange for the function to receive references as its parameters and
return them as its return results, it's cleaner code, although not so nice to
look at.  Here's a function that takes two array references as arguments,
returning the two array references ordered according to how many elements they
have in them:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($aref, $bref) = func(\@c, \@d);
print &quot;@$aref has more than @$bref\n&quot;;
sub func {
    my ($cref, $dref) = @_;
    if (@$cref &gt; @$dref) {
        return ($cref, $dref);
    } else {
        return ($dref, $cref);
    } 
}</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6984"
></A
>It turns out that you can actually mix the typeglob approach with the
reference approach, like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(*a, *b) = func(\@c, \@d);
print &quot;@a has more than @b\n&quot;;
sub func {
    local (*c, *d) = @_;
    if (@c &gt; @d) {
        return (\@c, \@d);
    } else {
        return (\@d, \@c);
    } 
}</PRE
></P
><P
CLASS="para"
>Here we're using the typeglobs to do symbol table aliasing.  It's a tad
subtle, though, and also won't work if you're using <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> variables,
since only globals (well, and <A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
>s) are in the symbol table. 
When you assign a reference to a typeglob like that, only the one element
from the typeglob (in this case, the array element) is aliased, instead of
all the similarly named elements, since the reference knows what it's
referring to.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-6993"
></A
>If you're passing around filehandles, you can usually just use the bare
typeglob, like <CODE
CLASS="literal"
>*STDOUT</CODE
>, but references to typeglobs work even better
because they still behave properly under <CODE
CLASS="literal"
>use strict 'refs'</CODE
>.  For
example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>splutter(\*STDOUT);
sub splutter {
    my $fh = shift;
    print $fh &quot;her um well a hmmm\n&quot;;
}

$rec = get_rec(\*STDIN);
sub get_rec {
    my $fh = shift;
    return scalar &lt;$fh&gt;;
}</PRE
></P
><P
CLASS="para"
>If you're planning on generating new filehandles, see the <B
CLASS="emphasis.bold"
>open</B
> entry in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
> for an example using the FileHandle
module.<A
CLASS="indexterm"
NAME="AUTOID-7003"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7004"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-7.3"
>2.7.3 Prototypes</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.PROTO"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7010"
></A
>As of the 5.003 release of Perl, you can declare your subroutines to
take arguments just like many of the built-ins, that is, with certain
constraints on the number and types of arguments.  For instance,
if you declare:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub mypush (\@@)</PRE
></P
><P
CLASS="para"
>then <CODE
CLASS="literal"
>mypush</CODE
> takes arguments exactly like <A
CLASS="xref"
HREF="ch03_112.htm"
TITLE="push"
><B
CLASS="xref.cmd"
>push</B
></A
> does.  The
declaration of the function to be called must be visible at compile time.
The prototype only affects the interpretation of new-style calls to the
function, where new-style is defined as &quot;not using the <CODE
CLASS="literal"
>&amp;</CODE
>
character&quot;.
In other words, if you call it like a built-in function, then it behaves
like a built-in function.  If you call it like an old-fashioned subroutine,
then it behaves like an old-fashioned subroutine.  It naturally falls out
from this rule that prototypes have no influence on subroutine references
like <CODE
CLASS="literal"
>\&amp;foo</CODE
> or on indirect subroutine calls like <CODE
CLASS="literal"
>&amp;{$subref}</CODE
>.</P
><P
CLASS="para"
>Method calls are not influenced by prototypes either. This is because the
function to be called is indeterminate at compile-time, depending as
it does on inheritance, which is dynamically determined in Perl.</P
><P
CLASS="para"
>Since the intent is primarily to let you define subroutines that work
like built-in commands, here are the prototypes for some other functions
that parse almost exactly like the corresponding built-ins.  (Note that
the &quot;<CODE
CLASS="literal"
>my</CODE
>&quot; on the front of each is just part of the name we picked, and
has nothing to do with Perl <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
> operator.  You can name your prototyped
functions anything you like&nbsp;- we just picked our names to parallel the
built-in functions.)</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Declared as</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Called as</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mylink ($$)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mylink $old, $new</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub myvec ($$$)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>myvec $var, $offset, 1</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub myindex ($$;$)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>myindex &amp;getstring, &quot;substr&quot;</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mysyswrite ($$$;$)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mysyswrite $buf, 0, length($buf) - $off, $off</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub myreverse (@)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>myreverse $a,$b,$c</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub myjoin ($@)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>myjoin &quot;:&quot;,$a,$b,$c</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mypop (\@)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mypop @array</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mysplice (\@$$@)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mysplice @array,@array,0,@pushme</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mykeys (\%)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mykeys %{$hashref}</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub myopen (*;$)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>myopen HANDLE, $name</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mypipe (**)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mypipe READHANDLE, WRITEHANDLE</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mygrep (&amp;@)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mygrep { /foo/ } $a,$b,$c</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub myrand ($)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>myrand 42</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>sub mytime ()</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>mytime</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Any backslashed prototype character (shown between parentheses in the
left column above) represents an actual argument (exemplified in the
right column) that absolutely must start with that character.  Just as
the first argument to <A
CLASS="xref"
HREF="ch03_079.htm"
TITLE="keys"
><B
CLASS="xref.cmd"
>keys</B
></A
> must start
with <CODE
CLASS="literal"
>%</CODE
>, so too must the first argument to
<CODE
CLASS="literal"
>mykeys</CODE
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-7107"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7110"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7113"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7116"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7118"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7121"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7124"
></A
>Unbackslashed prototype characters have special meanings.  Any
unbackslashed @ or % eats all the rest of the actual arguments, and
forces list context.  (It's equivalent to <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> in
a syntax diagram.) An argument represented by $ forces scalar context
on it.  An &amp; requires an anonymous subroutine (which, if passed as
the first argument, does not require the &quot;<CODE
CLASS="literal"
>sub</CODE
>&quot; keyword or a subsequent
comma).  And a <CODE
CLASS="literal"
>*</CODE
> does whatever it has to do to turn the argument into
a reference to a symbol table entry.  It's typically used for
filehandles.</P
><P
CLASS="para"
>A semicolon separates mandatory arguments from optional arguments.
(It would be redundant before <CODE
CLASS="literal"
>@</CODE
> or <CODE
CLASS="literal"
>%</CODE
>, since lists can be null.)</P
><P
CLASS="para"
>Note how the last three examples above are treated specially by the
parser.  <CODE
CLASS="literal"
>mygrep</CODE
> is parsed as a true list operator,
<CODE
CLASS="literal"
>myrand</CODE
> is parsed as a true unary operator with
unary precedence the same as <A
CLASS="xref"
HREF="ch03_115.htm"
TITLE="rand"
><B
CLASS="xref.cmd"
>rand</B
></A
>, and
<CODE
CLASS="literal"
>mytime</CODE
> is truly argumentless, just like <A
CLASS="xref"
HREF="ch03_173.htm"
TITLE="time"
><B
CLASS="xref.cmd"
>time</B
></A
>.  </P
><P
CLASS="para"
>That is, if you say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>mytime +2;</PRE
></P
><P
CLASS="para"
>you'll get <CODE
CLASS="literal"
>mytime() + 2</CODE
>, not
<CODE
CLASS="literal"
>mytime(2)</CODE
>, which is how it would be parsed without
the prototype, or with a unary prototype.</P
><P
CLASS="para"
>The interesting thing about <CODE
CLASS="literal"
>&amp;</CODE
> is that you can generate new
syntax with it:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub try (&amp;$) {
    my($try,$catch) = @_;
    eval { &amp;$try };
    if ($@) {
        local $_ = $@;
        &amp;$catch;
    }
}
sub catch (&amp;) { shift }

try {
    die &quot;phooey&quot;;
} catch {
    /phooey/ and print &quot;unphooey\n&quot;;
};</PRE
></P
><P
CLASS="para"
>This prints &quot;<CODE
CLASS="literal"
>unphooey</CODE
>&quot;.  What happens is that <CODE
CLASS="literal"
>try</CODE
> is called with two
arguments, the anonymous function <CODE
CLASS="literal"
>{die &quot;phooey&quot;;}</CODE
> and the return value
of the <CODE
CLASS="literal"
>catch</CODE
> function, which in this case is nothing but its own
argument, the entire block of yet another anonymous function.  Within
<CODE
CLASS="literal"
>try</CODE
>, the first function argument is called while protected within an
<A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> block to trap anything that blows up.  If something does blow up, the
second function is called with a local version of the global <CODE
CLASS="literal"
>$_</CODE
> variable
set to the raised exception.[<A
CLASS="footnote"
HREF="#AUTOID-7157"
>47</A
>]
If this all sounds like pure gobbledygook, you'll have to read about
<A
CLASS="xref"
HREF="ch03_027.htm"
TITLE="die"
><B
CLASS="xref.cmd"
>die</B
></A
> and <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>, and then go
check out anonymous functions in <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
>.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-7157"
>[47]</A
> Yes, there are still unresolved issues having to do with the visibility of
<CODE
CLASS="literal"
>@_</CODE
>.  We're ignoring that question for the moment.  (But note that if we
make <CODE
CLASS="literal"
>@_</CODE
> lexically scoped someday, those anonymous subroutines can act like
closures. (Gee, is this sounding a little Lispish?  (Nevermind.)))</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>And here's a reimplementation of the <A
CLASS="xref"
HREF="ch03_072.htm"
TITLE="grep"
><B
CLASS="xref.cmd"
>grep</B
></A
> operator (the built-in one is
more efficient, of course):</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub mygrep (&amp;@) {
    my $coderef = shift;
    my @result;
    foreach $_ (@_) {
        push(@result, $_) if &amp;$coderef;
    }
    @result;
}</PRE
></P
><P
CLASS="para"
>Some folks would prefer to see full alphanumeric prototypes.
Alphanumerics have been intentionally left out of prototypes for the
express purpose of someday adding named, formal parameters.
(Maybe.)  The current mechanism's main goal is to let module writers
provide better diagnostics for module users.  Larry feels that the notation
is quite understandable to Perl programmers, and that it will not intrude
greatly upon the meat of the module, nor make it harder to read.  The
line noise is visually encapsulated into a small pill that's easy to
swallow.</P
><P
CLASS="para"
>One note of caution.  It's probably best to put prototypes on new functions,
not retrofit prototypes onto older ones.  That's because you must be
especially careful about silently imposing a different context.  Suppose,
for example, you decide that a function should take just one parameter,
like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub func ($) {
    my $n = shift;
    print &quot;you gave me $n\n&quot;;
}</PRE
></P
><P
CLASS="para"
>and someone has been calling it with an array or expression
returning a single-element list:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>func(@foo);
func( split /:/ );</PRE
></P
><P
CLASS="para"
>Then you've just supplied an implicit <A
CLASS="xref"
HREF="ch03_131.htm"
TITLE="scalar"
><B
CLASS="xref.cmd"
>scalar</B
></A
> in front of their
argument, which can be more than a bit surprising.  The old <CODE
CLASS="literal"
>@foo</CODE
>
that used to hold one thing doesn't get passed in.  Instead, 1 (the
number of elements in <CODE
CLASS="literal"
>@foo</CODE
>) is now passed to <CODE
CLASS="literal"
>func</CODE
>.
And the <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
> gets called in a scalar context and
starts scribbling on your <B
CLASS="emphasis.bold"
>@_</B
> parameter list.</P
><P
CLASS="para"
>But if you're careful, you can do a lot of neat things with prototypes.
This is all very powerful, of course, and should only be used in moderation
to make the world a better place.<A
CLASS="indexterm"
NAME="AUTOID-7184"
></A
><A
CLASS="indexterm"
NAME="AUTOID-7185"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_06.htm"
TITLE="2.6 Statements and Declarations"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.6 Statements and Declarations"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_08.htm"
TITLE="2.8 Formats"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.8 Formats"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>2.6 Statements and Declarations</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>2.8 Formats</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
