<HTML
><HEAD
>
<TITLE>[Chapter 2] 2.4 Pattern Matching</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:38:51Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"><LINK
REL="prev"
HREF="ch02_03.htm"
TITLE="2.3 Terms"><LINK
REL="next"
HREF="ch02_05.htm"
TITLE="2.5 Operators"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_03.htm"
TITLE="2.3 Terms"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.3 Terms"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"
>Chapter 2<BR>The Gory Details</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_05.htm"
TITLE="2.5 Operators"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.5 Operators"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4"
>2.4 Pattern Matching</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.PAT"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3223"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3225"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3227"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3229"
></A
>The two main pattern matching operators are <CODE
CLASS="literal"
>m//</CODE
>,
the match operator, and <CODE
CLASS="literal"
>s///</CODE
>, the substitution
operator.  There is also a <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>
operator, which takes an ordinary match operator as its first argument
but otherwise behaves like a function, and is therefore documented in
<A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.</P
><P
CLASS="para"
>Although we write <CODE
CLASS="literal"
>m//</CODE
> and <CODE
CLASS="literal"
>s///</CODE
> here, you'll recall that you can
pick your own quote characters.  On the other hand, for the <CODE
CLASS="literal"
>m//</CODE
>
operator only, the <CODE
CLASS="literal"
>m</CODE
> may be omitted if the delimiters you pick are in
fact slashes.  (You'll often see patterns written this way, for
historical reasons.)</P
><P
CLASS="para"
>Now that we've gone to all the trouble of enumerating these weird,
quote-like operators, you might
wonder what it is we've gone to all the trouble of quoting.  The answer
is that the string inside the quotes specifies a <EM
CLASS="emphasis"
>regular expression</EM
>.
We'll discuss regular expressions in the next section, because there's a lot
to discuss.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3243"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3245"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3247"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3249"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3251"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3255"
></A
>The matching operations can have various modifiers, some of which affect
the interpretation of the regular expression inside:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>i</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Do case-insensitive pattern matching.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Treat string as multiple lines (<CODE
CLASS="literal"
>^</CODE
>
and <CODE
CLASS="literal"
>$</CODE
> match internal <CODE
CLASS="literal"
>\n</CODE
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Treat string as single line (<CODE
CLASS="literal"
>^</CODE
> and 
<CODE
CLASS="literal"
>$</CODE
> ignore <CODE
CLASS="literal"
>\n</CODE
>, but <CODE
CLASS="literal"
>.</CODE
>
matches <CODE
CLASS="literal"
>\n</CODE
>).</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Extend your pattern's legibility with whitespace and comments.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3294"
></A
>These are usually written as &quot;the <B
CLASS="emphasis.bold"
>/x</B
> modifier&quot;, even though the
delimiter in question might not actually be a slash.  In fact, any of
these modifiers may also be embedded within the regular expression
itself using the <CODE
CLASS="literal"
>(?...)</CODE
> construct.  See the section
&quot;Regular Expression Extensions&quot; later in this chapter.</P
><P
CLASS="para"
>The <B
CLASS="emphasis.bold"
>/x</B
> modifier itself needs a little more explanation.  It tells
the regular expression parser to ignore whitespace that is not
backslashed or within a character class.  You can use this modifier to break up
your regular expression into (slightly) more readable parts.  <A
CLASS="indexterm"
NAME="AUTOID-3301"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3304"
></A
>
The <CODE
CLASS="literal"
>#</CODE
>
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  Taken together, these features go a
long way toward making Perl a readable language.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4.1"
>2.4.1 Regular Expressions</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.RE"
></A
>The regular expressions used in the pattern matching and substitution
operators are syntactically similar to those used by the UNIX <EM
CLASS="emphasis"
>egrep</EM
> program.  When
you write a regular expression, you're actually writing a grammar for a
little language.  The regular expression interpreter (which we'll call
the Engine) takes your grammar and compares it to the string you're
doing pattern matching on.  If some portion of the string can be parsed
as a sentence of your little language, it says &quot;yes&quot;.  If not, it says
&quot;no&quot;.</P
><P
CLASS="para"
>What happens after the Engine has said &quot;yes&quot; depends on how you invoked
it.  An ordinary pattern match is usually used as a conditional
expression, in which case you don't care <EM
CLASS="emphasis"
>where</EM
> it matched, only
<EM
CLASS="emphasis"
>whether</EM
> it matched.  (But you can also find out where it matched if
you need to know that.)  A substitution command will take the part that
matched and replace it with some other string of your choice.  And the
<A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
> operator will return (as a
list) all the places your pattern didn't match.</P
><P
CLASS="para"
>Regular expressions are powerful, packing a lot of meaning into a
short space.  They can therefore be quite daunting if you try to
intuit the meaning of a large regular expression as a whole.  But if you
break it up into its parts, and if you know how the Engine interprets
those parts, you can understand any regular expression.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4.1.1"
>2.4.1.1 The regular expression bestiary</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3322"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3325"
></A
>Before we dive into the rules for interpreting regular expressions,
let's take a look at some of the things you'll see in regular expressions.
First of all, you'll see literal strings.  Most characters[<A
CLASS="footnote"
HREF="#AUTOID-3327"
>23</A
>]
in a regular expression simply match themselves.  If you string several
characters in a row, they must match in order, just as you'd expect.  So
if you write the pattern match:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-3327"
>[23]</A
> In this section we are misusing the term &quot;character&quot; to mean &quot;byte&quot;.
So far, Perl only knows about byte-sized characters, but this will
change someday, at which point &quot;character&quot; will be a more appropriate
word.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/Fred/</PRE
></P
><P
CLASS="para"
>you can know that the pattern won't match unless the string contains
the substring &quot;<CODE
CLASS="literal"
>Fred</CODE
>&quot; somewhere.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3334"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3336"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3339"
></A
>Other characters don't match themselves, but are <EM
CLASS="emphasis"
>metacharacters</EM
>.
(Before we explain what metacharacters do, we should reassure
you that you can always match such a character literally by putting a
backslash in front of it.  For example, backslash is itself a
metacharacter, so to match a literal backslash, you'd backslash the
backslash: <CODE
CLASS="literal"
>\\</CODE
>.)  The list of metacharacters is:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>\ | ( ) [  {  ^ $ * + ? .</PRE
></P
><P
CLASS="para"
>We said that backslash turns a metacharacter into a literal character,
but it does the opposite to an alphanumeric character: it turns
the literal character into a sort of metacharacter or sequence.  So
whenever you see a two-character sequence:</P
><PRE
CLASS="programlisting"
>\b \D \t \3 \s</PRE
><P
CLASS="para"
>you'll know that the sequence matches something strange.  A <CODE
CLASS="literal"
>\b</CODE
>
matches a word boundary, for instance, while <CODE
CLASS="literal"
>\t</CODE
> matches an ordinary
tab character.  Notice that a word boundary is zero characters wide,
while a tab character is one character wide.  Still, they're alike in
that they both assert that something is true about a particular spot
in the string.  Most of the things in a regular expression fall into the
class of assertions, including the ordinary characters that simply
assert that they match themselves.  (To be precise, they also assert
that the next thing will match one character later in the string, which
is why we talk about the tab character being &quot;one character wide&quot;.  Some
assertions eat up some of the string as they match, and others don't.
But we usually reserve the term &quot;assertion&quot; for the zero-width
assertions.  We'll call these assertions with nonzero width <EM
CLASS="emphasis"
>atoms</EM
>.)<A
CLASS="indexterm"
NAME="AUTOID-3352"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3354"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3357"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3359"
></A
>
You'll also see some things that aren't assertions.  Alternation is indicated
with a vertical bar:</P
><PRE
CLASS="programlisting"
>/Fred|Wilma|Barney|Betty/</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3364"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3366"
></A
>That means that any of those strings can trigger a match.
Grouping of various sorts is done with parentheses, including grouping
of alternating substrings within a longer regular expression:</P
><PRE
CLASS="programlisting"
>/(Fred|Wilma|Pebbles) Flintstone/</PRE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3370"
></A
>Another thing you'll see are what we call quantifiers.  They say how many
of the previous thing should match in a row.  Quantifiers look like:</P
><PRE
CLASS="programlisting"
>* + ? *? {2,5}</PRE
><P
CLASS="para"
>Quantifiers only make sense when attached to atoms, that is, assertions
that have width.  Quantifiers attach only to the previous atom, which in
human terms means they only quantify one character.  So if you want to
match three copies of &quot;<CODE
CLASS="literal"
>moo</CODE
>&quot; in a row, you need to group the
&quot;<CODE
CLASS="literal"
>moo</CODE
>&quot; with
parentheses, like this:</P
><PRE
CLASS="programlisting"
>/(moo){3}/</PRE
><P
CLASS="para"
>That will match &quot;<CODE
CLASS="literal"
>moomoomoo</CODE
>&quot;.  If you'd said <CODE
CLASS="literal"
>/moo{3}/</CODE
>, it
would only have matched &quot;<CODE
CLASS="literal"
>moooo</CODE
>&quot;.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3382"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3384"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3386"
></A
>Since patterns are processed as double-quoted strings, the normal
double-quoted interpolations will work.  (See &quot;String Literals&quot; earlier in
this chapter.)  These are applied before the string is interpreted as
a regular expression.  One caveat though: any <CODE
CLASS="literal"
>$</CODE
> immediately followed
by a vertical bar, closing parenthesis, or the end of the string will
be interpreted as an end-of-line assertion rather than a variable
interpolation.  So if you say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$foo = &quot;moo&quot;;
/$foo$/;</PRE
></P
><P
CLASS="para"
>it's equivalent to saying:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/moo$/;</PRE
></P
><P
CLASS="para"
>You should also know that interpolating variables into a pattern slows
down the pattern matcher considerably, because it feels it needs to recompile the
pattern each time through, since the variable might have changed.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4.1.2"
>2.4.1.2 The rules of regular expression matching</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3399"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3401"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3403"
></A
><A
CLASS="indexterm"
NAME="CH02.OREM"
></A
><A
CLASS="indexterm"
NAME="CH02.REMO"
></A
><A
CLASS="indexterm"
NAME="CH02.PMO"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3414"
></A
>Now that you've seen some regular expressions, we'll lay out
the rules that the Engine uses to match your pattern against the string.
The Perl Engine uses a nondeterministic finite-state automaton (NFA) to
find a match.  That just means that it keeps track of what it has tried
and what it hasn't, and when something doesn't pan out, it backs up and
tries something else.  This is called
<EM
CLASS="emphasis"
>backtracking</EM
>.  The Perl Engine is capable of
trying a million things at one spot, then giving up on all those,
backing up to within one choice of the beginning, and trying the million
things again at a different spot.  If you're cagey, you can write
efficient patterns that don't do a lot of silly backtracking.</P
><P
CLASS="para"
>The order of the rules below specifies which order the Engine tries
things.  So when someone trots out a stock phrase like &quot;left-most,
longest match&quot;, you'll know that overall Perl prefers left-most over
longest.  But the Engine doesn't realize it's preferring anything at
that level.  The global preferences result from a lot of localized
choices.  The Engine thinks locally and acts globally.</P
><P
CLASS="para"
><B
CLASS="emphasis.bold"
>Rule 1.</B
>  The Engine tries to match as far left in the string
as it can, such that the entire regular expression matches under Rule 2.</P
><P
CLASS="para"
>In order to do this, its first choice is to start just before the first
character (it could have started anywhere), and to try to match the
entire regular expression at that point.  The regular expression matches
if and only if Engine reaches the end of the regular expression before
it runs off the end of the string.  If it matches, it quits
immediately&nbsp;- it doesn't keep looking for a &quot;better&quot; match, even though
the regular expression could match in many different ways.  The match
only has to reach the end of the regular expression; it doesn't have to
reach the end of the string, unless there's an assertion in the regular
expression that says it must.  If it exhausts all possibilities at the
first position, it realizes that its very first choice was wrong, and
proceeds to its second choice.  It goes to the second position in the
string (between the first and second characters), and tries all the
possibilities again.  If it succeeds, it stops.  If it fails, it
continues on down the string.  The pattern match as a whole doesn't fail
until it has tried to match the entire regular expression at every
position in the string, including after the last character in the
string.</P
><P
CLASS="para"
>Note that the positions it's trying to match at are <EM
CLASS="emphasis"
>between</EM
> the
characters of the string.  This rule sometimes surprises people when
they write a pattern like <CODE
CLASS="literal"
>/x*/</CODE
> that can match zero or more <CODE
CLASS="literal"
>x</CODE
>'s.
If you try the pattern on a string like &quot;<CODE
CLASS="literal"
>fox</CODE
>&quot;, it will match the null
string before the &quot;<CODE
CLASS="literal"
>f</CODE
>&quot; in preference to the &quot;<CODE
CLASS="literal"
>x</CODE
>&quot; that's later in the
string.  If you want it to match one or more <CODE
CLASS="literal"
>x</CODE
>'s, you need to tell
it that by using <CODE
CLASS="literal"
>/x+/</CODE
> instead.  See the quantifiers under Rule 5.</P
><P
CLASS="para"
>A corollary to this rule is that any regular expression that can match
the null string is guaranteed to match at the leftmost position in the string.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3433"
></A
><B
CLASS="emphasis.bold"
>Rule 2.</B
>  For this rule, the whole
regular expression is regarded as a set of alternatives (where the
degenerate case is just a set with one alternative). If there are two
or more alternatives, they are syntactically separated by the
<CODE
CLASS="literal"
>|</CODE
> character (usually called a vertical bar). A set 
of alternatives matches a string if any of the
alternatives match under Rule 3.  It tries the alternatives
left-to-right (according to their position in the regular expression),
and stops on the first match that allows successful completion of the
entire regular expression.  If none of the alternatives matches, it
backtracks to the Rule that invoked this Rule, which is usually Rule 1,
but could be Rule 4 or 6.  That rule will then look for a new position
at which to apply Rule 2.</P
><P
CLASS="para"
>If there's only
one alternative, then it either it matches or doesn't, and the rule
still applies.  (There's no such thing as zero alternatives, because a
null string can always match something of zero width.)</P
><P
CLASS="para"
><B
CLASS="emphasis.bold"
>Rule 3.</B
>  Any particular alternative matches if every item in the
alternative matches sequentially according to Rules 4 and 5 (such that the
entire regular expression can be satisfied).  An item consists of either
an assertion, which is covered in Rule 4, or a quantified atom, which is
covered by Rule 5.  Items that have choices on how to match are given
&quot;pecking order&quot; from left to right.  If the items cannot be matched in
order, the Engine backtracks to the next alternative under Rule 2.</P
><P
CLASS="para"
>Items that must be matched sequentially aren't separated in the regular
expression by anything
syntactic&nbsp;- they're merely juxtaposed in the order they must match.
When you ask to match <CODE
CLASS="literal"
>/^foo/</CODE
>, you're actually asking for four items
to be matched one after the other.  The first is a zero-width assertion,
and the other three are ordinary letters that must match themselves, one
after the other.</P
><P
CLASS="para"
>The left-to-right pecking order means that in a pattern like:</P
><PRE
CLASS="programlisting"
>/x*y*/</PRE
><P
CLASS="para"
><CODE
CLASS="literal"
>x</CODE
> gets to pick one way to match, and then <CODE
CLASS="literal"
>y</CODE
> tries all its ways.  If that
fails, then <CODE
CLASS="literal"
>x</CODE
> gets to pick its second choice, and make <CODE
CLASS="literal"
>y</CODE
> try all of its
ways again.  And so on.  The items to the right vary faster, to borrow
a phrase from multi-dimensional arrays.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3450"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3452"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3455"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3458"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3461"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3463"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3465"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3467"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3469"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3471"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3474"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3477"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3480"
></A
><B
CLASS="emphasis.bold"
>Rule 4.</B
>  An assertion must match according to this table.  If the
assertion does not match at the current position, the Engine backtracks to
Rule 3 and retries higher-pecking-order items with different choices.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Assertion</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>^</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the beginning of the string (or line, if <B
CLASS="emphasis.bold"
>/m</B
> used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the end of the string (or line, if <B
CLASS="emphasis.bold"
>/m</B
> used)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at word boundary (between <CODE
CLASS="literal"
>\w</CODE
> and <CODE
CLASS="literal"
>\W</CODE
>)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\B</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches except at word boundary</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\A</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the beginning of the string</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\Z</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches at the end of the string</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\G</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches where previous <CODE
CLASS="literal"
>m//g</CODE
> left off</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>(?=...)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches if engine would match <CODE
CLASS="literal"
>...</CODE
> next</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>(?!...)</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Matches if engine wouldn't match <CODE
CLASS="literal"
>...</CODE
> next</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3545"
></A
>The <CODE
CLASS="literal"
>$</CODE
> and <CODE
CLASS="literal"
>\Z</CODE
> assertions can match not only at the end of the
string, but also one character earlier than that, if the last character
of the string happens to be a newline.</P
><P
CLASS="para"
>The positive <CODE
CLASS="literal"
>(?=...)</CODE
> and negative <CODE
CLASS="literal"
>(?!...)</CODE
> lookahead assertions are
zero-width themselves, but assert that the regular expression
represented above by <CODE
CLASS="literal"
>...</CODE
> would (or would not) match at this point,
were we to attempt it.  In fact, the Engine does attempt it.  The Engine
goes back to Rule 2 to test the subexpression, and then wipes out any
record of how much string was eaten, returning only the success or
failure of the subexpression as the value of the assertion.  We'll show
you some examples later.&#13;</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3555"
></A
><A
CLASS="indexterm"
NAME="CH02.ATOMS"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3560"
></A
><B
CLASS="emphasis.bold"
>Rule 5.</B
>  A quantified atom matches only if the atom itself matches
some number of times allowed by the quantifier.  (The atom is matched
according to Rule 6.) Different quantifiers require different numbers of
matches, and most of them allow a range of numbers of matches.  Multiple
matches must all match in a row, that is, they must be adjacent within
the string.  An unquantified atom is assumed to have a quantifier
requiring exactly one match.  Quantifiers constrain and control matching
according to the table below.  If no match can be found at the current
position for any allowed quantity of the atom in question, the Engine
backtracks to Rule 3 and retries higher-pecking-order items with
different choices.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3565"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3568"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3571"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3574"
></A
>Quantifiers are:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>Maximal</B
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>Minimal</B
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><B
CLASS="emphasis.bold"
>Allowed Range</B
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
>,<EM
CLASS="emphasis"
>m</EM
><CODE
CLASS="literal"
>}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
>,<EM
CLASS="emphasis"
>m</EM
><CODE
CLASS="literal"
>}?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Must occur at least <EM
CLASS="emphasis"
>n</EM
> times but no more than <EM
CLASS="emphasis"
>m</EM
> times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
><CODE
CLASS="literal"
>,}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
><CODE
CLASS="literal"
>,}?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Must occur at least <EM
CLASS="emphasis"
>n</EM
> times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
><CODE
CLASS="literal"
>}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
><CODE
CLASS="literal"
>}?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Must match exactly <EM
CLASS="emphasis"
>n</EM
> times</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>*?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0 or more times (same as <CODE
CLASS="literal"
>{0,}</CODE
>)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>+?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>1 or more times (same as <CODE
CLASS="literal"
>{1,}</CODE
>)</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>?</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>??</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>0 or 1 time (same as <CODE
CLASS="literal"
>{0,1}</CODE
>)</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If a brace occurs in any other context, it is treated as a regular
character.  <EM
CLASS="emphasis"
>n</EM
> and <EM
CLASS="emphasis"
>m</EM
> are
limited to integral values less than 65,536.</P
><P
CLASS="para"
>If you use the
<CODE
CLASS="literal"
>{</CODE
><EM
CLASS="emphasis"
>n</EM
><CODE
CLASS="literal"
>}</CODE
> form,
then there is no choice, and the atom must match exactly that number
of times or not at all.  Otherwise, the atom can match over a range of
quantities, and the Engine keeps track of all the choices so that it
can backtrack if necessary.  But then the question arises as to which
of these choices to try first.  One could start with the maximal
number of matches and work down, or the minimal number of matches and
work up.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3660"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3662"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3665"
></A
>The quantifiers in the left column above try the biggest quantity first.
This is often called &quot;greedy&quot; matching.  To find the greediest match,
the Engine doesn't actually count down from the maximum value, which
after all could be infinity.   What actually happens in this case is
that the Engine first counts up to find out how many atoms it's
possible to match in a row in the current string, and then it
remembers all the shorter choices and starts out from the longest one.  This could fail, of course, in which case it backtracks
to a shorter choice.</P
><P
CLASS="para"
>If you say <CODE
CLASS="literal"
>/.*foo/</CODE
>, for example, it will try to match the maximal
number of &quot;any&quot; characters (represented by the dot) clear out to the end
of the line before it ever tries looking for &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot;, and then when the
&quot;<CODE
CLASS="literal"
>foo</CODE
>&quot; doesn't match there (and it can't, because there's not enough room
for it at the end of the string), the Engine will back off one character
at a time until it finds a &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot;.  If there is more than one &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot; in
the line, it'll stop on the last one, and throw away all the shorter
choices it could have made.</P
><P
CLASS="para"
>By placing a question mark after any of the greedy quantifiers, they
can be made to choose the smallest quantity for the first try.  So if
you say <CODE
CLASS="literal"
>/.*?foo/</CODE
>, the <CODE
CLASS="literal"
>.*?</CODE
> first
tries to match 0 characters, then 1 character, then 2, and so on until
it can match the &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot;.  Instead of backtracking backward, it
backtracks forward, so to speak, and ends up finding the first &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot;
on the line instead of the last.</P
><P
CLASS="para"
><B
CLASS="emphasis.bold"
>Rule 6.</B
> Each atom matches according to
its type, listed below.  If the atom doesn't match (or doesn't allow a
match of the rest of the regular expression), the Engine backtracks to
Rule 5 and tries the next choice for the atom's quantity.</P
><P
CLASS="para"
>Atoms match according to the following types:</P
><UL
CLASS="itemizedlist"
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3685"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3688"
></A
>A regular expression in parentheses, <CODE
CLASS="literal"
>(...)</CODE
>, matches whatever the
regular expression (represented by <CODE
CLASS="literal"
>...</CODE
>) matches according to Rule 2.
Parentheses therefore serve as a grouping operator for quantification.
Parentheses also have the side effect of remembering the matched
substring for later use in a <EM
CLASS="emphasis"
>backreference</EM
> (to be
discussed later).  This side
effect can be suppressed by using <CODE
CLASS="literal"
>(?:...)</CODE
> instead, which has only
the grouping semantics&nbsp;- it doesn't store anything in <B
CLASS="emphasis.bold"
>$1</B
>, <B
CLASS="emphasis.bold"
>$2</B
>, and so on.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3698"
></A
>A &quot;<CODE
CLASS="literal"
>.</CODE
>&quot; matches any character except <CODE
CLASS="literal"
>\n</CODE
>.  (It also matches
<CODE
CLASS="literal"
>\n</CODE
> if you use the <B
CLASS="emphasis.bold"
>/s</B
> modifier.)  The main use of
dot is as a vehicle for a minimal or maximal quantifier.  A
<CODE
CLASS="literal"
>.*</CODE
> matches a maximal number of don't-care characters, while a
<CODE
CLASS="literal"
>.*?</CODE
> matches a minimal number of don't-care characters.  But it's
also sometimes used within parentheses for its width:
<CODE
CLASS="literal"
>/(..):(..):(..)/</CODE
> matches three colon-separated fields, each of
which is two characters long.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3710"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3713"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3716"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3719"
></A
>A list of characters in square brackets (called a <EM
CLASS="emphasis"
>character class</EM
>) matches
any one of the characters in the list.
A caret at the front of the list causes it to match only characters that
are <EM
CLASS="emphasis"
>not</EM
> in the list.  Character ranges may be indicated using the
<CODE
CLASS="literal"
>a-z</CODE
> notation.  You may also use any of <CODE
CLASS="literal"
>\d</CODE
>, <CODE
CLASS="literal"
>\w</CODE
>,
<CODE
CLASS="literal"
>\s</CODE
>, <CODE
CLASS="literal"
>\n</CODE
>, <CODE
CLASS="literal"
>\r</CODE
>, <CODE
CLASS="literal"
>\t</CODE
>, <CODE
CLASS="literal"
>\f</CODE
>, or
<CODE
CLASS="literal"
>\</CODE
><EM
CLASS="emphasis"
>nnn</EM
>, as listed below.  A <CODE
CLASS="literal"
>\b</CODE
> means a backspace
in a character class.  You may use a backslash to protect a hyphen that
would otherwise be interpreted as a range delimiter.  To match a right
square bracket, either backslash it or place it first in the list.  To
match a caret, <EM
CLASS="emphasis"
>don't</EM
> put it first.  Note that most other
metacharacters lose their meta-ness inside square brackets.  In
particular, it's meaningless to specify alternation in a character
class, since the characters are interpreted individually.  For example,
<CODE
CLASS="literal"
>[fee|fie|foe]</CODE
> means the same thing as <CODE
CLASS="literal"
>[feio|]</CODE
>.<A
CLASS="indexterm"
NAME="AUTOID-3738"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3740"
></A
></P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3745"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3747"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3750"
></A
>A backslashed letter matches a special character or character class:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Code</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Matches</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Alarm (beep)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\n</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Newline</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\r</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Carriage return</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\t</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Tab</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Formfeed</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Escape</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\d</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A digit, same as <CODE
CLASS="literal"
>[0-9]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\D</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A nondigit</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\w</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A word character (alphanumeric), same as <CODE
CLASS="literal"
>[a-zA-Z_0-9]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\W</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A nonword character</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A whitespace character, same as <CODE
CLASS="literal"
>[ \t\n\r\f]</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\S</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>A non-whitespace character</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Note that <CODE
CLASS="literal"
>\w</CODE
> matches a character of a word, not a whole word.  Use
<CODE
CLASS="literal"
>\w+</CODE
> to match a word.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3815"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3817"
></A
>A backslashed single-digit number matches whatever the corresponding
parentheses actually matched (except that <CODE
CLASS="literal"
>\0</CODE
> matches a null
character).  This is called a <EM
CLASS="emphasis"
>backreference</EM
> to a substring.  A
backslashed multi-digit number such as <CODE
CLASS="literal"
>\10</CODE
> will be considered a
backreference if the pattern contains at least that many substrings
prior to it, and the number does not start with a <CODE
CLASS="literal"
>0</CODE
>.  Pairs of
parentheses are numbered by counting left parentheses from the left.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3826"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3828"
></A
>A backslashed two- or three-digit octal number such as <CODE
CLASS="literal"
>\033</CODE
> matches the
character with the specified value, unless it would be interpreted as a
backreference.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3834"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3836"
></A
>A backslashed <CODE
CLASS="literal"
>x</CODE
> followed by one or two hexadecimal digits, such as
<CODE
CLASS="literal"
>\x7f</CODE
>, matches the character having that hexadecimal value.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3843"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3845"
></A
>A backslashed <CODE
CLASS="literal"
>c</CODE
> followed by a single character, such as <CODE
CLASS="literal"
>\cD</CODE
>,
matches the corresponding control character.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Any other backslashed character matches that character.</P
></LI
><LI
CLASS="listitem"
><P
CLASS="para"
>Any character not mentioned above matches itself.<A
CLASS="indexterm"
NAME="AUTOID-3854"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3855"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3856"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3857"
></A
></P
></LI
></UL
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4.1.3"
>2.4.1.3 The fine print</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3861"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3863"
></A
>As mentioned above, <CODE
CLASS="literal"
>\1</CODE
>, <CODE
CLASS="literal"
>\2</CODE
>, <CODE
CLASS="literal"
>\3</CODE
>, and so on, are
equivalent to whatever the corresponding set of parentheses matched,
counting opening parentheses from left to right.  (If the particular
pair of parentheses had a quantifier such as <CODE
CLASS="literal"
>*</CODE
> after it, such
that it matched a series of substrings, then only the last match counts
as the backreference.) Note that such a backreference matches whatever
actually matched for the subpattern in the string being examined;
it's not just a shorthand for the rules of that subpattern.  Therefore,
<CODE
CLASS="literal"
>(0|0x)\d*\s\1\d*</CODE
> will match &quot;<CODE
CLASS="literal"
>0x1234 0x4321</CODE
>&quot;, but not &quot;<CODE
CLASS="literal"
>0x1234
01234</CODE
>&quot;, since subpattern <CODE
CLASS="literal"
>1</CODE
> actually matched &quot;<CODE
CLASS="literal"
>0x</CODE
>&quot;, even though the rule
<CODE
CLASS="literal"
>0|0x</CODE
> could potentially match the leading <CODE
CLASS="literal"
>0</CODE
> in the second number.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3878"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3882"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3886"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3889"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3892"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3895"
></A
>Outside of the pattern (in particular, in the replacement of a
substitution operator) you can continue to refer to backreferences by
using <CODE
CLASS="literal"
>$</CODE
> instead of <CODE
CLASS="literal"
>\</CODE
> in front of
the number.  The variables <B
CLASS="emphasis.bold"
>$1</B
>,
<B
CLASS="emphasis.bold"
>$2</B
>, <B
CLASS="emphasis.bold"
>$3</B
> ... are automatically localized, and their
scope (and that of <B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>`</CODE
>, <B
CLASS="emphasis.bold"
>$&amp;</B
>, and <B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>'</CODE
> below) extends to the end of the enclosing block or <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> string, or to the next successful pattern
match, whichever comes first.
(The <CODE
CLASS="literal"
>\1</CODE
> notation sometimes works outside the current pattern, but
should not be relied upon.) <B
CLASS="emphasis.bold"
>$+</B
> returns whatever the last bracket
match matched.  <B
CLASS="emphasis.bold"
>$&amp;</B
> returns the entire matched string. <B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>`</CODE
> returns everything before the matched string.[<A
CLASS="footnote"
HREF="#AUTOID-3914"
>24</A
>]
<B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>'</CODE
> returns everything after the matched string.  For more explanation
of these magical variables (and for a way to write them in English), see
the section &quot;Special Variables&quot; at the end of this chapter.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-3914"
>[24]</A
> In the case of something like
<CODE
CLASS="literal"
>s/pattern/length($`)/eg</CODE
>, which does
multiple replacements if the pattern occurs multiple times, the value of
<B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>`</CODE
> does not include any modifications done by previous replacement
iterations.  To get the other effect, say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>1 while s/pattern/length($`)/e;</PRE
></P
><P
CLASS="para"
>For example, to change all tabs to the corresponding number of spaces,
you could say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>1 while s/\t+/' ' x (length($&amp;) * 8 - length($`) % 8)/e;</PRE
></P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>You may have as many parentheses as you wish.  If you have more
than nine pairs, the variables <B
CLASS="emphasis.bold"
>$10</B
>, <B
CLASS="emphasis.bold"
>$11</B
>, ... refer to the
corresponding substring.  Within the pattern, <CODE
CLASS="literal"
>\10</CODE
>, <CODE
CLASS="literal"
>\11</CODE
>, and so on, refer back
to substrings if there have been at least that many left parentheses before
the backreference.  Otherwise (for backward compatibility) <CODE
CLASS="literal"
>\10</CODE
> is the
same as <CODE
CLASS="literal"
>\010</CODE
>, a backspace, and <CODE
CLASS="literal"
>\11</CODE
> the same as <CODE
CLASS="literal"
>\011</CODE
>, a tab.  And so
on.  (<CODE
CLASS="literal"
>\1</CODE
> through <CODE
CLASS="literal"
>\9</CODE
> are always backreferences.)</P
><P
CLASS="para"
>Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>s/^([^ ]+) +([^ ]+)/$2 $1/;   # swap first two words

/(\w+)\s*=\s*\1/;             # match &quot;foo = foo&quot;

/.{80,}/;                     # match line of at least 80 chars

/^(\d+\.?\d*|\.\d+)$/;        # match valid number

if (/Time: (..):(..):(..)/) { # pull fields out of a line
        $hours   = $1;
        $minutes = $2;
        $seconds = $3;
}</PRE
></P
><P
CLASS="para"
>Hint: instead of writing patterns like <CODE
CLASS="literal"
>/(...)(..)(.....)/</CODE
>, use the
<A
CLASS="xref"
HREF="ch03_182.htm"
TITLE="unpack"
><B
CLASS="xref.cmd"
>unpack</B
></A
> function.  It's more efficient.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3944"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3946"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3949"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3952"
></A
>A word boundary (<CODE
CLASS="literal"
>\b</CODE
>) is defined as a spot between two
characters that has a <CODE
CLASS="literal"
>\w</CODE
> on one side of it and a
<CODE
CLASS="literal"
>\W</CODE
> on the other side of it (in either order), counting the
imaginary characters off the beginning and end of the string as matching
a <CODE
CLASS="literal"
>\W</CODE
>.  (Within character classes <CODE
CLASS="literal"
>\b</CODE
> represents
backspace rather than a word boundary.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3961"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3964"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3967"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3969"
></A
>Normally, the <CODE
CLASS="literal"
>^</CODE
> character is guaranteed to match only at the
beginning of the string, the <CODE
CLASS="literal"
>$</CODE
> character only at the end (or
before the newline at the end), and Perl does certain optimizations with
the assumption that the string contains only one line.  Embedded
newlines will not be matched by <CODE
CLASS="literal"
>^</CODE
> or <CODE
CLASS="literal"
>$</CODE
>.  However, you may
wish to treat a string as a multi-line buffer, such that the
<CODE
CLASS="literal"
>^</CODE
> will also match after any newline within the string, and <CODE
CLASS="literal"
>$</CODE
>
will also match before any newline.  At the cost of a little more overhead,
you can do this by using the <B
CLASS="emphasis.bold"
>/m</B
> modifier on the pattern match
operator.  (Older programs did this by setting <B
CLASS="emphasis.bold"
>$*</B
>, but this
practice is now deprecated.)  <CODE
CLASS="literal"
>\A</CODE
> and <CODE
CLASS="literal"
>\Z</CODE
> are just
like <CODE
CLASS="literal"
>^</CODE
> and <CODE
CLASS="literal"
>$</CODE
> except that they won't match multiple times
when the <B
CLASS="emphasis.bold"
>/m</B
> modifier is used, while <CODE
CLASS="literal"
>^</CODE
> and <CODE
CLASS="literal"
>$</CODE
> will
match at every internal line boundary.  To match the actual end of the
string, not ignoring newline, you can use <CODE
CLASS="literal"
>\Z(?!\n)</CODE
>.  There's
an example of a negative lookahead assertion.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3988"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3990"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3993"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3995"
></A
>To facilitate multi-line substitutions, the <CODE
CLASS="literal"
>.</CODE
> character never matches a
newline unless you use the <B
CLASS="emphasis.bold"
>/s</B
> modifier, which tells Perl to pretend
the string is a single line&nbsp;- even if it isn't.  (The <B
CLASS="emphasis.bold"
>/s</B
> modifier also
overrides the setting of <B
CLASS="emphasis.bold"
>$*</B
>, in case you have some (badly behaved) older
code that sets it in another module.)
In particular, the following leaves a newline on the <B
CLASS="emphasis.bold"
>$_</B
> string:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$_ = &lt;STDIN&gt;;
s/.*(some_string).*/$1/;</PRE
></P
><P
CLASS="para"
>If the newline is unwanted, use any of these:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>s/.*(some_string).*/$1/s;
s/.*(some_string).*\n/$1/;
s/.*(some_string)[^\0]*/$1/;
s/.*(some_string)(.|\n)*/$1/;

chop; s/.*(some_string).*/$1/;
/(some_string)/ &amp;&amp; ($_ = $1);</PRE
></P
><P
CLASS="para"
>Note that all backslashed metacharacters in Perl are
alphanumeric, such as <CODE
CLASS="literal"
>\b</CODE
>, <CODE
CLASS="literal"
>\w</CODE
>,
and <CODE
CLASS="literal"
>\n</CODE
>.  Unlike some regular expression languages, there are no backslashed
symbols that aren't alphanumeric.  So anything that looks like
<CODE
CLASS="literal"
>\\</CODE
>, <CODE
CLASS="literal"
>\(</CODE
>, <CODE
CLASS="literal"
>\)</CODE
>, <CODE
CLASS="literal"
>\&lt;</CODE
>, <CODE
CLASS="literal"
>\&gt;</CODE
>,
<CODE
CLASS="literal"
>\{</CODE
>, or <CODE
CLASS="literal"
>\}</CODE
> is always interpreted as a literal
character, not a metacharacter.  This makes it simple to quote a string
that you want to use for a pattern but that you are afraid might contain
metacharacters.
Just quote all the non-alphanumeric characters:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$pattern =~ s/(\W)/\\$1/g;</PRE
></P
><P
CLASS="para"
>You can also use the built-in <A
CLASS="xref"
HREF="ch03_114.htm"
TITLE="quotemeta"
><B
CLASS="xref.cmd"
>quotemeta</B
></A
> function to do this.
An even easier way to quote metacharacters right in the match operator
is to say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/$unquoted\Q$quoted\E$unquoted/</PRE
></P
><P
CLASS="para"
>Remember that the first and last alternatives (before the first <CODE
CLASS="literal"
>|</CODE
> and
after the last one) tend to gobble up the other elements of the regular
expression on either side, out
to the ends of the expression, unless there are enclosing parentheses.  A
common mistake is to ask for:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/^fee|fie|foe$/</PRE
></P
><P
CLASS="para"
>when you really mean:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>/^(fee|fie|foe)$/</PRE
></P
><P
CLASS="para"
>The first matches &quot;<CODE
CLASS="literal"
>fee</CODE
>&quot; at the beginning of the string, or
&quot;<CODE
CLASS="literal"
>fie</CODE
>&quot; anywhere, or &quot;<CODE
CLASS="literal"
>foe</CODE
>&quot; at the end of the string.  The second
matches any string consisting solely of &quot;<CODE
CLASS="literal"
>fee</CODE
>&quot; or &quot;<CODE
CLASS="literal"
>fie</CODE
>&quot; or
&quot;<CODE
CLASS="literal"
>foe</CODE
>&quot;.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4.1.4"
>2.4.1.4 Regular expression extensions</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4042"
></A
>Perl defines a consistent extension syntax for regular expressions.
You've seen some of them already.
The syntax is a pair of parentheses with a question mark as the first thing
within the parentheses.[<A
CLASS="footnote"
HREF="#AUTOID-4045"
>25</A
>]
The character after the question mark gives the function of the extension.
Several extensions are already supported:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-4045"
>[25]</A
> This was a syntax error in older versions of Perl.  If you try to use this
and have problems, upgrade to the newest version.</P
></DIV
></BLOCKQUOTE
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?#text)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4053"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4055"
></A
>A comment.  The text is ignored.  If the <B
CLASS="emphasis.bold"
>/x</B
> switch is used to enable
whitespace formatting, a simple <CODE
CLASS="literal"
>#</CODE
> will suffice.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?:...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4065"
></A
>This groups things like &quot;<CODE
CLASS="literal"
>(...)</CODE
>&quot; but doesn't make backreferences like &quot;<CODE
CLASS="literal"
>(...)</CODE
>&quot; does.  So:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>split(/\b(?:a|b|c)\b/)</PRE
></P
><P
CLASS="para"
>is like:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>split(/\b(a|b|c)\b/)</PRE
></P
><P
CLASS="para"
>but doesn't actually save anything in <B
CLASS="emphasis.bold"
>$1</B
>, which means
that the first <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
> doesn't spit out extra delimiter fields
as the second one does.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?=...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4083"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4085"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4087"
></A
>A zero-width positive lookahead assertion.  For example, <CODE
CLASS="literal"
>/\w+(?=\t)/</CODE
>
matches a word followed by a tab, without including the tab in <B
CLASS="emphasis.bold"
>$&amp;</B
>.</P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?!...)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4097"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4099"
></A
>A zero-width negative lookahead assertion.  For example <CODE
CLASS="literal"
>/foo(?!bar)/</CODE
>
matches any occurrence of &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot; that isn't followed by &quot;<CODE
CLASS="literal"
>bar</CODE
>&quot;.  Note,
however, that lookahead and lookbehind are <EM
CLASS="emphasis"
>not</EM
> the same thing.  You cannot
use this for lookbehind: <CODE
CLASS="literal"
>/(?!foo)bar/</CODE
> will not find an occurrence of
&quot;<CODE
CLASS="literal"
>bar</CODE
>&quot; that is preceded by something that is not &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot;.  That's because
the <CODE
CLASS="literal"
>(?!foo)</CODE
> is just saying that the next thing cannot be &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot;&nbsp;- and
it's not, it's a &quot;<CODE
CLASS="literal"
>bar</CODE
>&quot;, so &quot;<CODE
CLASS="literal"
>foobar</CODE
>&quot; will match.  You would have to do
something like <CODE
CLASS="literal"
>/(?!foo)</CODE
>...<CODE
CLASS="literal"
>bar/</CODE
> for that.   We say &quot;like&quot; because there's
the case of your &quot;<CODE
CLASS="literal"
>bar</CODE
>&quot; not having three characters before it.  You could
cover that this way: <CODE
CLASS="literal"
>/(?:(?!foo)</CODE
>...<CODE
CLASS="literal"
>|^</CODE
>.<CODE
CLASS="literal"
>{0, 2}bar/</CODE
>.  Sometimes it's still
easier just to say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>if (/bar/ and $` !~ /foo$/)</PRE
></P
></DD
><DT
CLASS="term"
><CODE
CLASS="literal"
>(?imsx)</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4126"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4129"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4131"
></A
>One or more embedded pattern-match modifiers.  This is particularly
useful for patterns that are specified in a table somewhere, some of
which want to be case-sensitive, and some of which don't.  The case-insensitive ones merely need to include <CODE
CLASS="literal"
>(?i)</CODE
> at the front of the
pattern.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># hardwired case insensitivity
$pattern = &quot;buffalo&quot;;
if ( /$pattern/i )

# data-driven case insensitivity
$pattern = &quot;(?i)buffalo&quot;;
if ( /$pattern/ )</PRE
></P
></DD
></DL
><P
CLASS="para"
>We chose to use the question mark for this (and for the new minimal
matching construct) because (1) question mark is pretty rare in older
regular expressions, and (2) whenever you see one, you should stop
and <EM
CLASS="emphasis"
>question</EM
> exactly what is going on.  That's psychology.</P
><A
CLASS="indexterm"
NAME="AUTOID-4139"
></A
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-4.2"
>2.4.2 Pattern-Matching Operators</A
></H3
><P
CLASS="para"
>Now that we've got all that out of the way, here finally are the
quotelike operators (er, terms) that perform pattern matching and related
activities.<A
CLASS="indexterm"
NAME="CH02.MO1"
></A
><A
CLASS="indexterm"
NAME="CH02.MO2"
></A
></P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>m/</CODE
><CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
><CODE
CLASS="literal"
>/gimosx</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
><CODE
CLASS="literal"
>/gimosx</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
>This operator searches a string for a pattern match, and in a scalar context
returns true (<CODE
CLASS="literal"
>1</CODE
>) or false (<CODE
CLASS="literal"
>&quot;&quot;</CODE
>).  If no string is specified via
the <CODE
CLASS="literal"
>=~</CODE
> or <CODE
CLASS="literal"
>!~</CODE
> operator, the
<B
CLASS="emphasis.bold"
>$_</B
> string is searched.  (The string
specified with <CODE
CLASS="literal"
>=~</CODE
> need not be an lvalue&nbsp;- it
may be the result of an expression evaluation, but remember the
<CODE
CLASS="literal"
>=~</CODE
> binds rather tightly, so you may need
parentheses around your expression.)</P
></DD
></DL
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4167"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4169"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4171"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4173"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4176"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4179"
></A
>Modifiers are:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>g</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Match globally, that is, find all occurrences.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>i</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Do case-insensitive pattern matching.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as multiple lines.   <EM
CLASS="emphasis"
>(continued)</EM
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>o</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Only compile pattern once.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as single line.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>If <CODE
CLASS="literal"
>/</CODE
> is the delimiter then the initial <CODE
CLASS="literal"
>m</CODE
> is optional.  With the <CODE
CLASS="literal"
>m</CODE
>
you can use any pair of non-alphanumeric, non-whitespace characters as
delimiters.  This is particularly useful for matching filenames
that contain &quot;<CODE
CLASS="literal"
>/</CODE
>&quot;, thus avoiding LTS (leaning toothpick syndrome).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4219"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4221"
></A
><CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated.  (Note
that <B
CLASS="emphasis.bold"
>$)</B
> and <B
CLASS="emphasis.bold"
>$|</B
> will not be interpolated because they look
like end-of-line tests.)  If you want such a pattern to be compiled only
once, add a <B
CLASS="emphasis.bold"
>/o</B
> after the trailing delimiter.  This avoids
expensive run-time recompilations, and is useful when the value you are
interpolating won't change during execution.  However,
mentioning <B
CLASS="emphasis.bold"
>/o</B
> constitutes a promise that you won't change the
variables in the pattern.  If you do change them, Perl won't even
notice.</P
><P
CLASS="para"
>If the <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> evaluates to a null string, the last successfully
executed regular expression not hidden within an inner block (including
<A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>, <A
CLASS="xref"
HREF="ch03_072.htm"
TITLE="grep"
><B
CLASS="xref.cmd"
>grep</B
></A
>, and <A
CLASS="xref"
HREF="ch03_091.htm"
TITLE="map"
><B
CLASS="xref.cmd"
>map</B
></A
>) is used instead.</P
><P
CLASS="para"
>If used in a context that requires a list value, a pattern match returns
a list consisting of the subexpressions matched by the parentheses in
the pattern&nbsp;- that is, (<B
CLASS="emphasis.bold"
>$1</B
>, <B
CLASS="emphasis.bold"
>$2</B
>, <B
CLASS="emphasis.bold"
>$3</B
> ...). (The variables are
also set.)  If the match fails, a null list is returned.  If the match
succeeds, but there were no parentheses, a list value of (1) is
returned.</P
><P
CLASS="para"
>Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># case insensitive matching
open(TTY, '/dev/tty');
&lt;TTY&gt; =~ /^y/i and foo();    # do foo() if they want it

# pulling a substring out of a line
if (/Version: *([0-9.]+)/) { $version = $1; }

# avoiding Leaning Toothpick Syndrome
next if m#^/usr/spool/uucp#;

# poor man's grep
$arg = shift;
while (&lt;&gt;) {
    print if /$arg/o;       # compile only once
}

# get first two words and remainder as a list
if (($F1, $F2, $Etc) = ($foo =~ /^\s*(\S+)\s+(\S+)\s*(.*)/))</PRE
></P
><P
CLASS="para"
>This last example splits <CODE
CLASS="literal"
>$foo</CODE
> into the first two words and the
remainder of the line, and assigns those three fields to <CODE
CLASS="literal"
>$F1</CODE
>,
<CODE
CLASS="literal"
>$F2</CODE
>, and <CODE
CLASS="literal"
>$Etc</CODE
>.  The conditional is true if any variables
were assigned, that is, if the pattern matched.  Usually, though, one would
just write the equivalent <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>if (($F1, $F2, $Etc) = split(' ', $foo, 3))</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4249"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4251"
></A
>The <B
CLASS="emphasis.bold"
>/g</B
> modifier specifies global pattern matching&nbsp;- that is, matching
as many times as possible within the string.  How it behaves depends on
the context.  In a list context, it returns a list of all the
substrings matched by all the parentheses in the regular expression.
If there are no parentheses, it returns a list of all the matched
strings, as if there were parentheses around the whole pattern.</P
><P
CLASS="para"
>In a scalar context, <B
CLASS="emphasis.bold"
>m//g</B
> iterates through the string, returning true
each time it matches, and false when it eventually runs out of
matches.  (In other words, it remembers where it left off last time and
restarts the search at that point.  You can find the current
match position of a string using the <A
CLASS="xref"
HREF="ch03_109.htm"
TITLE="pos"
><B
CLASS="xref.cmd"
>pos</B
></A
> function&nbsp;- see <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.)
If you modify the string in any way, the match position is reset to the
beginning.  Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># list context--extract three numeric fields from uptime command
($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

# scalar context--count sentences in a document by recognizing
# sentences ending in [.!?], perhaps with quotes or parens on 
# either side.  Observe how dot in the character class is a literal
# dot, not merely any character.
$/ = &quot;&quot;;  # paragraph mode
while ($paragraph = &lt;&gt;) {
    while ($paragraph =~ /[a-z]['&quot;)]*[.!?]+['&quot;)]*\s/g) {
        $sentences++;
    }
}
print &quot;$sentences\n&quot;;

# find duplicate words in paragraphs, possibly spanning line boundaries.
#   Use /x for space and comments, /i to match the both `is' 
#   in &quot;Is is this ok?&quot;, and use /g to find all dups.
$/ = &quot;&quot;;        # paragrep mode again
while (&lt;&gt;) {
    while ( m{
                \b            # start at a word boundary
                (\w\S+)       # find a wordish chunk
                ( 
                    \s+       # separated by some whitespace
                    \1        # and that chunk again
                ) +           # repeat ad lib
                \b            # until another word boundary
             }xig
         ) 
    {
        print &quot;dup word `$1' at paragraph $.\n&quot;;
    } 
}</PRE
><A
CLASS="indexterm"
NAME="AUTOID-4261"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4262"
></A
></P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>?</CODE
><CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
><CODE
CLASS="literal"
>?</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4271"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4273"
></A
>This is just like the
<CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
><CODE
CLASS="literal"
>/</CODE
>
search, except that it matches only once between calls to the
<A
CLASS="xref"
HREF="ch03_124.htm"
TITLE="reset"
><B
CLASS="xref.cmd"
>reset</B
></A
> operator.  This is a useful
optimization when you only want to see the first occurrence of
something in each file of a set of files, for instance.  Only
<CODE
CLASS="literal"
>??</CODE
> patterns local to the current package are reset.</P
></DD
></DL
><P
CLASS="para"
>This usage is vaguely deprecated, and may be removed in some future
version of Perl.  Most people just bomb out of the loop when they
get the match they want.</P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>s/</CODE
><CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>REPLACEMENT</I
></CODE
><CODE
CLASS="literal"
>/egimosx</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.SO1"
></A
><A
CLASS="indexterm"
NAME="CH02.SO2"
></A
>This operator searches a string for <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
>, and if found, replaces
that match with the <CODE
CLASS="replaceable"
><I
>REPLACEMENT</I
></CODE
> text and returns the number of
substitutions made, which can be more than one with the <B
CLASS="emphasis.bold"
>/g</B
> modifier.
Otherwise it returns false (0).</P
></DD
></DL
><P
CLASS="para"
>If no string is specified via the <CODE
CLASS="literal"
>=~</CODE
> or <CODE
CLASS="literal"
>!~</CODE
> operator, the
<B
CLASS="emphasis.bold"
>$_</B
> variable is searched and modified.  (The string specified with
<CODE
CLASS="literal"
>=~</CODE
> must be a scalar variable, an array element, a hash element,
or an assignment to one of those, that is, an lvalue.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4304"
></A
>If the delimiter you choose happens to be a single quote, no variable
interpolation is done on either the <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> or the <CODE
CLASS="replaceable"
><I
>REPLACEMENT</I
></CODE
>.
Otherwise, if the <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> contains a <CODE
CLASS="literal"
>$</CODE
> that looks like a variable rather
than an end-of-string test, the variable will be interpolated into the
<CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> at run-time.  If you want the <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
>
compiled only once, when the
variable is first interpolated, use the <B
CLASS="emphasis.bold"
>/o</B
> option.  If the
<CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> evaluates to a null string, the
last successfully executed
regular expression is used instead.  The <CODE
CLASS="replaceable"
><I
>REPLACEMENT</I
></CODE
> pattern also
undergoes variable interpolation, but it does so each time the <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
>
matches, unlike the <CODE
CLASS="replaceable"
><I
>PATTERN,</I
></CODE
> which just gets interpolated once when
the operator is evaluated.  (The <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> can match multiple times in one
evaluation if you use the <B
CLASS="emphasis.bold"
>/g</B
> option below.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4320"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4322"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4324"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4326"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4328"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4331"
></A
>Modifiers are:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Evaluate the right side as an expression.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>g</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Replace globally, that is, all occurrences.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>i</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Do case-insensitive pattern matching.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as multiple lines.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>o</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Only compile pattern once.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Treat string as single line.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>x</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Use extended regular expressions.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4370"
></A
>Any non-alphanumeric, non-whitespace delimiter may replace the slashes.
If single quotes are used, no interpretation is done on the replacement
string (the <B
CLASS="emphasis.bold"
>/e</B
> modifier overrides this, however). If the <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
> is contained
within naturally paired delimiters (such as parentheses), the
<CODE
CLASS="replaceable"
><I
>REPLACEMENT</I
></CODE
> has its own pair of delimiters, which may or may not be
the same ones used for <CODE
CLASS="replaceable"
><I
>PATTERN</I
></CODE
>&nbsp;- for example, <CODE
CLASS="literal"
>s(foo)(bar)</CODE
> or
<CODE
CLASS="literal"
>s&lt;foo&gt;/bar/</CODE
>.  A <B
CLASS="emphasis.bold"
>/e</B
> will cause the replacement portion to be
interpreted as a full-fledged Perl expression instead of as a
double-quoted string.  (It's kind of like an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>, but its
syntax is checked at compile-time.)</P
><P
CLASS="para"
>Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># don't change wintergreen
s/\bgreen\b/mauve/g;

# avoid LTS with different quote characters
$path =~ s(/usr/bin)(/usr/local/bin);

# interpolated pattern and replacement
s/Login: $foo/Login: $bar/;

# modifying a string &quot;en passant&quot;
($foo = $bar) =~ s/this/that/;

# counting the changes
$count = ($paragraph =~ s/Mister\b/Mr./g);

# using an expression for the replacement
$_ = 'abc123xyz';
s/\d+/$&amp;*2/e;               # yields 'abc246xyz'
s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;  # yields 'abc  246xyz'
s/\w/$&amp; x 2/eg;             # yields 'aabbcc  224466xxyyzz'

# how to default things with /e
s/%(.)/$percent{$1}/g;            # change percent escapes; no /e
s/%(.)/$percent{$1} || $&amp;/ge;     # expr now, so /e
s/^=(\w+)/&amp;pod($1)/ge;            # use function call

# /e's can even nest; this will expand simple embedded variables in $_
s/(\$\w+)/$1/eeg;

# delete C comments
$program =~ s {
    /\*     # Match the opening delimiter.
    .*?     # Match a minimal number of characters.
    \*/     # Match the closing delimiter.
} []gsx;

# trim white space
s/^\s*(.*?)\s*$/$1/;

# reverse 1st two fields
s/([^ ]*) *([^ ]*)/$2 $1/;</PRE
></P
><P
CLASS="para"
>Note the use of <CODE
CLASS="literal"
>$</CODE
> instead of <CODE
CLASS="literal"
>\</CODE
> in the last example.
Some people get a little too used to writing things like:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$pattern =~ s/(\W)/\\\1/g;</PRE
></P
><P
CLASS="para"
>This is grandfathered for the right-hand side of a substitution to avoid
shocking the <EM
CLASS="emphasis"
>sed</EM
> addicts, but it's a dirty habit to get into.[<A
CLASS="footnote"
HREF="#AUTOID-4390"
>26</A
>]
That's because in PerlThink, the right-hand side of a <CODE
CLASS="literal"
>s///</CODE
> is a
double-quoted string.  In an ordinary double-quoted string, <CODE
CLASS="literal"
>\1</CODE
>
would mean a control-A, but for <CODE
CLASS="literal"
>s///</CODE
> the customary UNIX meaning
of <CODE
CLASS="literal"
>\1</CODE
> is kludged in.  (The lexer actually translates it to
<B
CLASS="emphasis.bold"
>$1</B
> on the fly.)  If you start to rely on that, however, you get
yourself into trouble if you then add an <B
CLASS="emphasis.bold"
>/e</B
> modifier:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-4390"
>[26]</A
> Or to not get out of, depending on how you look at it.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>s/(\d+)/ \1 + 1 /eg;   # a scalar reference plus one?</PRE
></P
><P
CLASS="para"
>Or if you try to do:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>s/(\d+)/\1000/;        # &quot;\100&quot; . &quot;0&quot; == &quot;@0&quot;?</PRE
></P
><P
CLASS="para"
>You can't disambiguate that by saying <CODE
CLASS="literal"
>\{1}000</CODE
>, whereas you
<EM
CLASS="emphasis"
>can</EM
> fix it with <CODE
CLASS="literal"
>${1}000</CODE
>.  Basically, the operation of
interpolation should not be confused with the operation of matching a
backreference.  Certainly, interpolation and matching mean two different
things on the <EM
CLASS="emphasis"
>left</EM
> side of the <CODE
CLASS="literal"
>s///</CODE
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4410"
></A
>Occasionally, you can't just use a <B
CLASS="emphasis.bold"
>/g</B
> to get all the changes to
occur, either because the substitutions have to happen right-to-left, or
because you need the length of <B
CLASS="emphasis.bold"
>$</B
><CODE
CLASS="literal"
>`</CODE
> to change between matches.  In this
case you can usually do what you want by calling the substitution
repeatedly.  Here are two common cases:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># put commas in the right places in an integer
1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/;

# expand tabs to 8-column spacing
1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;</PRE
><A
CLASS="indexterm"
NAME="AUTOID-4417"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4418"
></A
></P
><DL
CLASS="variablelist"
><DT
CLASS="term"
><CODE
CLASS="literal"
>tr/</CODE
><CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
><CODE
CLASS="literal"
>/cds</CODE
></DT
><DT
CLASS="term"
><CODE
CLASS="literal"
>y/</CODE
><CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
><CODE
CLASS="literal"
>/</CODE
><CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
><CODE
CLASS="literal"
>/cds</CODE
></DT
><DD
CLASS="listitem"
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4435"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4437"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4439"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4441"
></A
>Strictly speaking, this operator doesn't belong in a section on pattern
matching because it doesn't use regular expressions.  Rather, it scans
a string character by character, and replaces
all occurrences of the characters found in the <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
> 
with the corresponding character in the <CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
>.  It returns
the number of characters replaced or deleted.  If no string is
specified via the <CODE
CLASS="literal"
>=~</CODE
> or <CODE
CLASS="literal"
>!~</CODE
> operator, the <B
CLASS="emphasis.bold"
>$_</B
> string is translated.  (The
string specified with <CODE
CLASS="literal"
>=~</CODE
> must be a scalar variable, an array element,
or an assignment to one of those, that is, an lvalue.)  For <EM
CLASS="emphasis"
>sed</EM
> devotees,
<B
CLASS="emphasis.bold"
>y</B
> is provided as a synonym for <A
CLASS="xref"
HREF="ch03_175.htm"
TITLE="tr///"
><B
CLASS="xref.cmd"
>tr///</B
></A
>.  If the <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
> is
contained within naturally paired delimiters (such as parentheses), the
<CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
> has its own pair of delimiters, which may or may
not be naturally paired ones&nbsp;- for example, <CODE
CLASS="literal"
>tr[A-Z][a-z]</CODE
>
or <CODE
CLASS="literal"
>tr(+-*/)/ABCD/</CODE
>.</P
></DD
></DL
><P
CLASS="para"
>Modifiers:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Modifier</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>c</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Complement the <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
>.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>d</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Delete found but unreplaced characters.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Squash duplicate replaced characters.</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4478"
></A
>If the <B
CLASS="emphasis.bold"
>/c</B
> modifier is specified, the
<CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
> character set is complemented; that
is, the effective search list consists of all the characters
<EM
CLASS="emphasis"
>not</EM
> in <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
>.  If the
<B
CLASS="emphasis.bold"
>/d</B
> modifier is specified, any
characters specified by <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
> but not given
a replacement in <CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
> are deleted.
(Note that this is slightly more flexible than the behavior of some
<A
CLASS="xref"
HREF="ch03_175.htm"
TITLE="tr///"
><B
CLASS="xref.cmd"
>tr///</B
></A
> programs, which delete anything they
find in the <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
>, period.)  If the
<B
CLASS="emphasis.bold"
>/s</B
> modifier is specified, sequences of
characters that were translated to the same character are squashed
down to a single instance of the character.<A
CLASS="indexterm"
NAME="AUTOID-4490"
></A
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4493"
></A
>If the <B
CLASS="emphasis.bold"
>/d</B
> modifier is used, the
<CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
> is always interpreted exactly as
specified.  Otherwise, if the <CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
> is
shorter than the <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
>, the final character
is replicated until it is long enough.  If the
<CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
> is null, the
<CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
> is replicated.  This latter is useful
for counting characters in a class or for squashing character
sequences in a class.</P
><P
CLASS="para"
>Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$ARGV[1] =~ tr/A-Z/a-z/;    # canonicalize to lower case

$cnt = tr/*/*/;             # count the stars in $_

$cnt = $sky =~ tr/*/*/;     # count the stars in $sky

$cnt = tr/0-9//;            # count the digits in $_

tr/a-zA-Z//s;               # bookkeeper -&gt; bokeper

($HOST = $host) =~ tr/a-z/A-Z/;

tr/a-zA-Z/ /cs;             # change non-alphas to single space

tr [\200-\377]
   [\000-\177];             # delete 8th bit</PRE
></P
><P
CLASS="para"
>If multiple translations are given for a character, only the first one is used:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>tr/AAA/XYZ/</PRE
></P
><P
CLASS="para"
>will translate any A to X.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4509"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4512"
></A
>Note that because the translation table is built at compile time, neither
the <CODE
CLASS="replaceable"
><I
>SEARCHLIST</I
></CODE
> nor the <CODE
CLASS="replaceable"
><I
>REPLACEMENTLIST</I
></CODE
>
are subject to double quote
interpolation.  That means that if you want to use variables, you must use
an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>eval &quot;tr/$oldlist/$newlist/&quot;;
die $@ if $@;

eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-4521"
></A
><A
CLASS="indexterm"
NAME="AUTOID-4523"
></A
>One more note: if you want to change your text to uppercase or
lowercase, it's better to use the <CODE
CLASS="literal"
>\U</CODE
> or <CODE
CLASS="literal"
>\L</CODE
> sequences
in a double-quoted string, since they will pay attention to locale
information, but <CODE
CLASS="literal"
>tr/a-z/A-Z/</CODE
> won't.<A
CLASS="indexterm"
NAME="AUTOID-4529"
></A
></P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_03.htm"
TITLE="2.3 Terms"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.3 Terms"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_05.htm"
TITLE="2.5 Operators"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.5 Operators"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>2.3 Terms</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>2.5 Operators</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
