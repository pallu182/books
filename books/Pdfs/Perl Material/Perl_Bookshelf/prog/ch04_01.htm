<HTML
><HEAD
>
<TITLE>[Chapter 4] References and Nested Data Structures</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:57:32Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="index.htm"
TITLE="Programming Perl"><LINK
REL="prev"
HREF="ch03_02.htm"
TITLE="3.2 Perl Functions in Alphabetical Order"><LINK
REL="next"
HREF="ch04_02.htm"
TITLE="4.2 Creating Hard References"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch03_02.htm"
TITLE="3.2 Perl Functions in Alphabetical Order"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 3.2 Perl Functions in Alphabetical Order"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
>Chapter 4</FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_02.htm"
TITLE="4.2 Creating Hard References"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.2 Creating Hard References"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="CHAPTER"
><H1
CLASS="chapter"
><A
CLASS="title"
NAME="PERL2-CH-4"
>4. References and Nested Data Structures</A
></H1
><DIV
CLASS="htmltoc"
><P
><B
>Contents:</B
><BR><A
CLASS="SECT1"
HREF="#PERL2-CH-4-SECT-1"
TITLE="4.1 What Is a Reference?"
>What Is a Reference?</A
><BR><A
CLASS="SECT1"
HREF="ch04_02.htm"
TITLE="4.2 Creating Hard References"
>Creating Hard References</A
><BR><A
CLASS="SECT1"
HREF="ch04_03.htm"
TITLE="4.3 Using Hard References"
>Using Hard References</A
><BR><A
CLASS="SECT1"
HREF="ch04_04.htm"
TITLE="4.4 Symbolic References"
>Symbolic References</A
><BR><A
CLASS="SECT1"
HREF="ch04_05.htm"
TITLE="4.5 Braces, Brackets, and Quoting"
>Braces, Brackets, and Quoting</A
><BR><A
CLASS="SECT1"
HREF="ch04_06.htm"
TITLE="4.6 A Brief Tutorial:  Manipulating Lists of Lists"
>A Brief Tutorial:  Manipulating Lists of Lists</A
><BR><A
CLASS="SECT1"
HREF="ch04_07.htm"
TITLE="4.7 Data Structure Code Examples"
>Data Structure Code Examples</A
></P
><P
></P
></DIV
><P
CLASS="para"
>For both practical and philosophical reasons, Perl has always been<A
CLASS="indexterm"
NAME="AUTOID-14367"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14369"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14371"
></A
>
biased in favor of flat, linear data structures.  And for many
problems, this is exactly what you want.  But occasionally you need to
set up something just a little more complicated and hierarchical.
Under older versions of Perl you could construct complex data
structures indirectly by using <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> or
typeglobs.  </P
><P
CLASS="para"
>Suppose you wanted to build a simple table
(two-dimensional array) showing vital statistics&nbsp;- say, age, eye
color, and weight&nbsp;- for a group of people.  You could do this by
first creating an array for each individual:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@john = (47, &quot;brown&quot;, 186);
@mary = (23, &quot;hazel&quot;, 128);
@bill = (35, &quot;blue&quot;, 157);</PRE
></P
><P
CLASS="para"
>and then constructing a single, additional array consisting of the names
of the other arrays:</P
><PRE
CLASS="programlisting"
>@vitals = ('john', 'mary', 'bill');</PRE
><P
CLASS="para"
>Unfortunately, actually using this table as a
two-dimensional data structure is cumbersome.  To change John's eyes
to &quot;red&quot; after a night on the town, you'd have to say something like:</P
><PRE
CLASS="programlisting"
>$vitals = $vitals[0];
eval &quot;\$${vitals}[1] = 'red'&quot;;</PRE
><P
CLASS="para"
>A much more efficient (but not more readable) way to do
the same thing is to use a typeglob assignment to temporarily
alias one symbol table entry to another:</P
><PRE
CLASS="programlisting"
>local(*array) = $vitals[0];  # Alias *array to *john.
$array[1] = 'red';           # Actually sets $john[1].</PRE
><P
CLASS="para"
>Alternatively, you could avoid the symbol table altogether by doing
everything with a set of parallel hash arrays, emulating pointers
symbolically by doing key lookups in the appropriate hash.  Finally,
you could define all your structures operationally, using <A
CLASS="xref"
HREF="ch03_105.htm"
TITLE="pack"
><B
CLASS="xref.cmd"
>pack</B
></A
> and <A
CLASS="xref"
HREF="ch03_182.htm"
TITLE="unpack"
><B
CLASS="xref.cmd"
>unpack</B
></A
>,
or <A
CLASS="xref"
HREF="ch03_078.htm"
TITLE="join"
><B
CLASS="xref.cmd"
>join</B
></A
> and <A
CLASS="xref"
HREF="ch03_155.htm"
TITLE="split"
><B
CLASS="xref.cmd"
>split</B
></A
>.</P
><P
CLASS="para"
>So even though you could use a variety of techniques to emulate pointers
and data structures, all of them could get to be unwieldy.
To be sure, Perl still supports these older mechanisms, since they
remain quite useful for simple problems.  But now Perl also supports
<EM
CLASS="emphasis"
>references</EM
>.</P
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-4-SECT-1"
>4.1 What Is a Reference?</A
></H2
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH04.REF1"
></A
>In the preceding example using <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
>,
<CODE
CLASS="literal"
>$vitals[0]</CODE
> had the value <CODE
CLASS="literal"
>'john'</CODE
>.
That is, it happened to contain a string that was also the name for
another variable.  You could say that the first variable
<EM
CLASS="emphasis"
>referred</EM
> to the second.  We will speak of this<A
CLASS="indexterm"
NAME="AUTOID-14400"
></A
>
sort of reference as a <EM
CLASS="emphasis"
>symbolic</EM
> reference.  You
can think of it as analogous to symbolic links in UNIX filesystems.
Perl now provides some simplified mechanisms for using symbolic
references; in particular, the need for an <A
CLASS="xref"
HREF="ch03_032.htm"
TITLE="eval"
><B
CLASS="xref.cmd"
>eval</B
></A
> or a typeglob assignment in our example
disappears.  See &quot;Symbolic References&quot; later in this chapter.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-14405"
></A
>The other kind of reference is the <EM
CLASS="emphasis"
>hard</EM
> reference.[<A
CLASS="footnote"
HREF="#AUTOID-14408"
>1</A
>]
A hard reference refers not to the name of another variable (which is
just a container for a value) but rather to an actual value, some
internal glob of data, which we will call a &quot;thingy&quot;, in honor of that
thingy that hangs down in the back of your throat.  (You may also call
it a &quot;referent&quot;, if you prefer to live a joyless existence.)  Suppose,
for example, that you create a hard reference to the thingy contained in
the variable <CODE
CLASS="literal"
>@array</CODE
>.  This hard reference and the thingy it
refers to will continue to exist even after <CODE
CLASS="literal"
>@array</CODE
> goes out of
scope.  Only when the reference count of the thingy itself goes to zero
is the thingy actually destroyed.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-14408"
>[1]</A
> If you like, you can think of hard references as real references, and
symbolic references as fake references.  It's like the difference between
real friendship and mere name-dropping.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>To put it another way, a Perl variable lives in a symbol table and
holds one hard reference to its underlying thingy (which may be a simple
thingy like a number, or a complex thingy like an array or hash, but
there's still only one reference from the variable to the value).  There
may be other hard references to the same thingy, but if so, the variable
doesn't know (or care) about them.  A symbolic reference names another
variable, so there's always a named location involved, but a hard
reference just points to a thingy. It doesn't know (or care)
whether there are any other references to the thingy, or whether any of those
references are through variables.  Hence, a hard reference can refer to
an anonymous thingy.  All such anonymous thingies are accessed through
hard references.  But the converse is not necessarily true&nbsp;- just because
something has a hard reference to it doesn't necessarily mean it's
anonymous.  It might have another reference through a named variable.
(It can even have more than one name, if it is aliased with
typeglobs.)</P
><P
CLASS="para"
>To <EM
CLASS="emphasis"
>reference</EM
> a variable, in the terminology of this chapter, is
to create a hard reference to the thingy underlying
the variable.  (There's a special operator to do this creative act.)  The
hard reference so created is simply a scalar value, which behaves in
all familiar contexts just like any other scalar value should.  To <EM
CLASS="emphasis"
>dereference</EM
><A
CLASS="indexterm"
NAME="AUTOID-14416"
></A
><A
CLASS="indexterm"
NAME="AUTOID-14418"
></A
>
this scalar value is to use it to refer back to the original thingy,
as you must do when reading or writing to the thingy.  Both referencing
and dereferencing occur only when you invoke certain explicit mechanisms;
no implicit referencing or dereferencing occurs in Perl.[<A
CLASS="footnote"
HREF="#AUTOID-14421"
>2</A
>][<A
CLASS="footnote"
HREF="#AUTOID-14425"
>3</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-14421"
>[2]</A
> Actually, a function with a prototype <EM
CLASS="emphasis"
>can</EM
> use implicit pass-by-reference
if explicitly declared that way.
If so, then the caller of the function doesn't need to know he's passing a
reference, but you still have to dereference it explicitly within the
function.  See <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="The Gory Details"
>Chapter 2, <CITE
CLASS="chapter"
>The Gory Details</CITE
></A
>.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-14425"
>[3]</A
> Actually, to be perfectly honest, there's also some mystical automatic
dereferencing when you use certain kinds of filehandles,
but that's for backward compatibility, and is transparent to the
casual user.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Any scalar may hold a hard reference, and such a reference may point to any
data structure.  Since arrays and hashes contain scalars, you can
build arrays of arrays, arrays of hashes, hashes of arrays, arrays of
hashes and functions, and so on.</P
><P
CLASS="para"
>Keep in mind, though, that Perl arrays and hashes are internally
one-dimensional.  They can only hold scalar values (strings, numbers,
and references).  When we use a phrase like &quot;array of arrays&quot;, we really
mean &quot;array of references to arrays&quot;.  But since that's the only way to
implement an array of arrays in Perl, it follows that the shorter,
less accurate phrase is not so inaccurate as to be false, and therefore
should not be totally despised, unless you're into that sort of thing.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch03_02.htm"
TITLE="3.2 Perl Functions in Alphabetical Order"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 3.2 Perl Functions in Alphabetical Order"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch04_02.htm"
TITLE="4.2 Creating Hard References"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 4.2 Creating Hard References"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>3.2 Perl Functions in Alphabetical Order</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>4.2 Creating Hard References</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
