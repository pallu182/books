<HTML
><HEAD
>
<TITLE>[Chapter 1] 1.6 A Stroll Through Perl</TITLE>
<META
NAME="DC.title"
CONTENT="Learning Perl on Win32 Systems"><META
NAME="DC.creator"
CONTENT="Randal L. Schwartz, Erik Olson &amp; Tom Christiansen"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:29:00Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-324-3"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction"><LINK
REL="prev"
HREF="ch01_05.htm"
TITLE="1.5 Basic Concepts"><LINK
REL="next"
HREF="ch01_07.htm"
TITLE="1.7 Exercises"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Learning Perl on Win32 Systems"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,54"
HREF="index.htm"
ALT="Learning Perl on Win32 Systems"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/wsrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_05.htm"
TITLE="1.5 Basic Concepts"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.5 Basic Concepts"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch01_01.htm"
TITLE="1. Introduction"
>Chapter 1<BR>Introduction</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_07.htm"
TITLE="1.7 Exercises"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.7 Exercises"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="ch01-39405"
>1.6 A Stroll Through Perl</A
></H2
><P
CLASS="para"
>We begin our journey through Perl by taking a little stroll. This stroll presents a number of different features by hacking on a small application. The explanations here are extremely brief&nbsp;- each subject area is discussed in <EM
CLASS="emphasis"
>much</EM
> greater detail later in this book. But this little stroll should give you a quick taste for the language, and you can decide if you really want to finish this book instead of reading some more Usenet news or running off to the <A
CLASS="indexterm"
NAME="ch01-idx-1839-0"
></A
>ski slopes.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-1840"
>1.6.1 The "Hello, world" Program</A
></H3
><P
CLASS="para"
>Let's look at a little program that actually <EM
CLASS="emphasis"
>does</EM
> something. Here is your basic <A
CLASS="indexterm"
NAME="ch01-idx-2089-0"
></A
>"Hello, world" program (use any text editor to type it in):</P
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch01-idx-2091-0"
></A
>print (&quot;Hello, world!\n&quot;);</PRE
><P
CLASS="para"
>This single line is the entire program. The built-in function <CODE
CLASS="literal"
>print</CODE
> starts it off, and in this case has just one argument, a C-like text string. Within this string, the character combination <CODE
CLASS="literal"
>\n</CODE
> stands for a newline character, just as it does in C. The <CODE
CLASS="literal"
>print</CODE
> statement is terminated by a semicolon (<CODE
CLASS="literal"
>;</CODE
>). As in Pascal or C, all simple statements in Perl are terminated by a <A
CLASS="indexterm"
NAME="ch01-idx-868857-0"
></A
>semicolon.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869681"
>7</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869681"
>[7]</A
> The semicolon can be omitted when the statement is the last statement of a block, file, or <CODE
CLASS="literal"
>eval</CODE
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>When you invoke this program, the Perl interpreter parses the entire program and then executes the compiled form. The first and only operation is the execution of the <CODE
CLASS="literal"
>print</CODE
> function, which sends any arguments to the standard output. After the program has completed, the Perl process exits, returning a successful exit code to the parent process.</P
><P
CLASS="para"
>Soon, you'll see Perl programs in which <CODE
CLASS="literal"
>print</CODE
> and other functions are sometimes called with parentheses, and sometimes called without them. The rule is simple: in Perl, parentheses for built-in functions are never required nor forbidden. Their use can help or hinder clarity, so use your own judgment.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869100"
>1.6.2 Asking Questions and Remembering the Result</A
></H3
><P
CLASS="para"
>Let's add a bit more sophistication. The <CODE
CLASS="literal"
>Hello, world</CODE
> greeting is a touch cold and inflexible. Let's have the program call you by your name. To do this, we need a place to hold the name, a way to ask for the name, and a way to get a response.</P
><P
CLASS="para"
>One kind of place to hold values (like a name) is a <A
CLASS="indexterm"
NAME="ch01-idx-868858-0"
></A
><EM
CLASS="emphasis"
>scalar variable</EM
>. For this program, we'll use the scalar variable <CODE
CLASS="literal"
>$name</CODE
> to hold your name. In <A
CLASS="xref"
HREF="ch02_01.htm"
TITLE="Scalar Data"
>Chapter 2, <CITE
CLASS="chapter"
>Scalar Data</CITE
></A
>,  we'll go into more detail about what these variables can hold, and what you can do with them. For now, assume that you can hold a single number or string (sequence of characters) in a scalar variable.</P
><P
CLASS="para"
>The program needs to ask for the name. To do that, we need a way to <A
CLASS="indexterm"
NAME="ch01-idx-4474-0"
></A
>prompt and a way to accept input. The previous program showed us how to prompt: use the <CODE
CLASS="literal"
>print</CODE
> function. And the way to get a line from the terminal is with the <CODE
CLASS="literal"
>&lt;STDIN&gt;</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-4475-0"
></A
> construct, which (as we're using it here) grabs one line of input. We assign this input to the <CODE
CLASS="literal"
>$name</CODE
> variable. This gives us the following program:</P
><PRE
CLASS="programlisting"
>print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;</PRE
><P
CLASS="para"
>The value of <CODE
CLASS="literal"
>$name</CODE
> at this point has a terminating newline (<CODE
CLASS="literal"
>Erik</CODE
> comes in as <CODE
CLASS="literal"
>Erik\n</CODE
>). To get rid of the newline, we use the <A
CLASS="indexterm"
NAME="ch01-idx-4192-0"
></A
><CODE
CLASS="literal"
>chomp()</CODE
> function, which takes a scalar variable as its sole argument and removes the trailing newline, if present, from the string:</P
><PRE
CLASS="programlisting"
>chomp $name;</PRE
><P
CLASS="para"
>Now, all we need to do is say <CODE
CLASS="literal"
>Hello,</CODE
> followed by the value of the <CODE
CLASS="literal"
>$name</CODE
> variable, which we can do by embedding the variable inside the <A
CLASS="indexterm"
NAME="ch01-idx-868862-0"
></A
>quoted string:</P
><PRE
CLASS="programlisting"
>print &quot;Hello, $name!\n&quot;;</PRE
><P
CLASS="para"
>Putting it all together, we get:</P
><PRE
CLASS="programlisting"
>print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
print &quot;Hello, $name!\n&quot;;</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869020"
>1.6.3 Adding Choices</A
></H3
><P
CLASS="para"
>Now, let's say we have a special greeting for Erik, but want an ordinary greeting for anyone else. To do this, we need to compare the name that was entered with the string <CODE
CLASS="literal"
>Erik</CODE
>, and if they are identical, do something special. Let's add a C-like <A
CLASS="indexterm"
NAME="ch01-idx-868863-0"
></A
><EM
CLASS="emphasis"
>if-then-else</EM
> branch and a comparison to the program:</P
><PRE
CLASS="programlisting"
>print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Erik&quot;) {
  print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
  print &quot;Hello, $name!\n&quot;; # ordinary greeting
}</PRE
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch01-idx-868864-0"
></A
><CODE
CLASS="literal"
>eq</CODE
> operator compares two strings. If they are equal (character for character, and of the same length), the result is true. (No comparable operator[<A
CLASS="footnote"
HREF="#ch01-pgfId-1665"
>8</A
>] exists in C or C++.)</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-1665"
>[8]</A
> Well, OK, there's a standard <CODE
CLASS="literal"
>C</CODE
> <CODE
CLASS="literal"
>library</CODE
> function. But that's not an operator.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The <CODE
CLASS="literal"
>if</CODE
> statement selects which <A
CLASS="indexterm"
NAME="ch01-idx-868865-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868865-1"
></A
><EM
CLASS="emphasis"
>block</EM
> of statements (between matching curly braces) is executed&nbsp;- if the expression is true, it's the first block, otherwise it's the second block.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-18448"
>1.6.4 Guessing the Secret Word</A
></H3
><P
CLASS="para"
>Well, now that we have the name, let's have the person running the program guess a <A
CLASS="indexterm"
NAME="ch01-idx-868866-0"
></A
>secret word. For everyone except Erik, we'll have the program repeatedly ask for guesses until the person guesses properly. First the program, and then an explanation:</P
><PRE
CLASS="programlisting"
>$secretword = &quot;gecko&quot;; # the secret word
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Erik&quot;) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp $guess;
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp $guess;
    }
}</PRE
><P
CLASS="para"
>First, we define the secret word by putting it into another scalar variable, <CODE
CLASS="literal"
>$secretword</CODE
>. After the greeting, the (non-Erik) person is asked (with another <CODE
CLASS="literal"
>print</CODE
>) for the guess. The guess is compared with the secret word using the <A
CLASS="indexterm"
NAME="ch01-idx-3938-0"
></A
><CODE
CLASS="literal"
>ne</CODE
> operator, which returns true if the strings are not equal (<CODE
CLASS="literal"
>ne</CODE
> is the logical opposite of the <CODE
CLASS="literal"
>eq</CODE
> operator). The result of the comparison controls a <A
CLASS="indexterm"
NAME="ch01-idx-3939-0"
></A
><CODE
CLASS="literal"
>while</CODE
> loop, which executes the block as long as the comparison is true.</P
><P
CLASS="para"
>Of course, this program is not very secure, because anyone who is tired of guessing can merely interrupt the program and get back to the prompt, or even look at the source to determine the word. But, we weren't trying to write a security system, just an example for this book.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869132"
>1.6.5 More than One Secret Word</A
></H3
><P
CLASS="para"
>Let's see how we can modify this program to allow more than one valid secret word. Using what we've already seen, we could compare the guess repeatedly against a series of good answers stored in separate scalar variables. However, such a list would be hard to modify or read in from a file or compute based on the day of the week.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="ch01-idx-868869-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868869-1"
></A
>A better solution is to store all of the possible answers in a data structure called a <EM
CLASS="emphasis"
>list</EM
>, or (preferrably) an <EM
CLASS="emphasis"
>array</EM
>. Each <EM
CLASS="emphasis"
>element</EM
> of the array is a separate scalar variable that can be independently set or accessed. The entire array can also be given a value in one fell swoop. We can <A
CLASS="indexterm"
NAME="ch01-idx-868870-0"
></A
>assign a value to the entire array named <CODE
CLASS="literal"
>@words</CODE
> so that it contains three possible good passwords:</P
><PRE
CLASS="programlisting"
>@words = (&quot;camel&quot;,&quot;gecko&quot;,&quot;alpaca&quot;);</PRE
><P
CLASS="para"
>Array variable names begin with <A
CLASS="indexterm"
NAME="ch01-idx-868871-0"
></A
><CODE
CLASS="literal"
>@</CODE
>, so they are distinct from scalar variable names. Another way to write this so that we don't have to put all those quotemarks there is with the <A
CLASS="indexterm"
NAME="ch01-idx-871913-0"
></A
><CODE
CLASS="literal"
>qw()</CODE
> syntax, like so:</P
><PRE
CLASS="programlisting"
>@words = qw(camel gecko alpaca);</PRE
><P
CLASS="para"
>These mean exactly the same thing; the <CODE
CLASS="literal"
>qw</CODE
> makes it as if we had quoted each of three strings.</P
><P
CLASS="para"
>After the array is assigned, we can <A
CLASS="indexterm"
NAME="ch01-idx-868872-0"
></A
>access each element by using a <A
CLASS="indexterm"
NAME="ch01-idx-868873-0"
></A
>subscript reference (subscripts start at zero). So, <CODE
CLASS="literal"
>$words[0]</CODE
> is <CODE
CLASS="literal"
>camel</CODE
>, <CODE
CLASS="literal"
>$words[1]</CODE
> is <CODE
CLASS="literal"
>gecko</CODE
>, and <CODE
CLASS="literal"
>$words[2]</CODE
> is <CODE
CLASS="literal"
>alpaca</CODE
>. The subscript can be an expression as well, so if we set <CODE
CLASS="literal"
>$i</CODE
> to 2, then <CODE
CLASS="literal"
>$words[$i]</CODE
> is <CODE
CLASS="literal"
>alpaca</CODE
>. (Subscript references start with <CODE
CLASS="literal"
>$</CODE
> rather than <CODE
CLASS="literal"
>@</CODE
>, because they refer to a single element of the array rather than the whole array.) Going back to our previous example:</P
><PRE
CLASS="programlisting"
>@words = qw(camel gecko alpaca);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp $name;
if ($name eq &quot;Erik&quot;) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    $i = 0; # try this word first
    $correct = &quot;maybe&quot;; # is the guess correct or not?
    while ($correct eq &quot;maybe&quot;) { # keep checking til we know
        if ($words[$i] eq $guess) { # right?
        $correct = &quot;yes&quot;; # yes!
    } elsif ($i &lt; 2) { # more words to look at?
        $i = $i + 1; # look at the next word next time
    } else { # no more words, must be bad
        print &quot;Wrong, try again. What is the secret word?&quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
        $i = 0; # start checking at the first word again
    }
  } # end of while not correct
} # end of &quot;not Erik&quot;</PRE
><P
CLASS="para"
>You'll notice we're using the scalar variable <CODE
CLASS="literal"
>$correct</CODE
> to indicate that we are either still looking for a good password, or that we've found one.</P
><P
CLASS="para"
>This program also shows the <A
CLASS="indexterm"
NAME="ch01-idx-3334-0"
></A
><CODE
CLASS="literal"
>elsif</CODE
> block of the <CODE
CLASS="literal"
>if-then-else</CODE
> statement. This exact construct is not present in all programming languages&nbsp;- it's an abbreviation of the <CODE
CLASS="literal"
>else</CODE
> block together with a new <CODE
CLASS="literal"
>if</CODE
> condition, but it does not nest inside yet another pair of curly braces. It's a very Perl-like thing to compare a set of conditions in a cascaded <CODE
CLASS="literal"
>if-elsif-elsif-elsif-else</CODE
> chain. Perl doesn't really have the equivalent of C's <CODE
CLASS="literal"
>switch</CODE
> or Pascal's <CODE
CLASS="literal"
>case</CODE
> statement, although you can build one yourself without too much trouble. See <A
CLASS="olink"
HREF="../prog/ch02_01.htm"
>Chapter 2</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
> or the <EM
CLASS="emphasis"
>perlsyn </EM
> documentation for details.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869163"
>1.6.6 Giving Each Person a Different Secret Word</A
></H3
><P
CLASS="para"
>In the previous program, any person who comes along could guess any of the three words and be successful. If we want the secret word to be different for each person, we'll need a table that matches people with words. <A
CLASS="xref"
HREF="ch01_06.htm#ch01-14760"
TITLE="Matching Persons to Secret Words"
>Table 1.1</A
> does just this.</P
><BR><TABLE
CLASS="table"
BORDER="1"
CELLPADDING="3"
><CAPTION
CLASS="table"
><A
CLASS="title"
NAME="ch01-14760"
>Table 1.1: Matching Persons to Secret Words</A
></CAPTION
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Person</P
></TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Secret Word</P
></TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Fred</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>camel</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Barney</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>gecko</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Betty</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>alpaca</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Wilma</P
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>alpaca</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Notice that both Betty and Wilma have the same secret word. This is fine.</P
><P
CLASS="para"
>The easiest way to store such a table in Perl is with a <A
CLASS="indexterm"
NAME="ch01-idx-868874-0"
></A
><EM
CLASS="emphasis"
>hash</EM
>. Each element of the hash holds a separate scalar value (just like the other type of array), but each hash is referenced by a <A
CLASS="indexterm"
NAME="ch01-idx-868875-0"
></A
><EM
CLASS="emphasis"
>key</EM
>, which can be any scalar value (any string or number, including noninteger and negative values). To create a hash called <CODE
CLASS="literal"
>%words</CODE
> (notice the use of <A
CLASS="indexterm"
NAME="ch01-idx-868876-0"
></A
><CODE
CLASS="literal"
>%</CODE
>, rather than <CODE
CLASS="literal"
>@</CODE
>) with the keys and values given in <A
CLASS="xref"
HREF="ch01_06.htm#ch01-14760"
TITLE="Matching Persons to Secret Words"
>Table 1.1</A
>, we <A
CLASS="indexterm"
NAME="ch01-idx-868877-0"
></A
>assign a value to <CODE
CLASS="literal"
>%words</CODE
> (much as we did earlier with the array):</P
><PRE
CLASS="programlisting"
>%words = qw(
  fred    camel
  barney  gecko
  betty   alpaca
  wilma   alpaca
);</PRE
><P
CLASS="para"
>Each pair of values in the list represents one key and its corresponding value in the hash. Note that we broke this assignment over many lines without any sort of line continuation character. We could do so because whitespace is generally insignificant in a Perl program.</P
><P
CLASS="para"
>To find the secret word for Betty, we need to use Betty as the key in a reference to the hash <CODE
CLASS="literal"
>%words</CODE
>, via some expression such as <CODE
CLASS="literal"
>$words{&quot;betty&quot;}</CODE
>. The value of this reference is <CODE
CLASS="literal"
>alpaca</CODE
>, similar to what we had before with the other array. Also, as before, the key can be any expression, so setting <CODE
CLASS="literal"
>$person</CODE
> to <CODE
CLASS="literal"
>betty</CODE
> and evaluating <CODE
CLASS="literal"
>$words{$person</CODE
>} gives <CODE
CLASS="literal"
>alpaca</CODE
> as well.</P
><P
CLASS="para"
>Putting all this together, we get a program like this:</P
><PRE
CLASS="programlisting"
>%words = qw(
    fred      camel
    barney    gecko
    betty     alpaca
    wilma     alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name eq &quot;Erik&quot;) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><P
CLASS="para"
>Note the lookup of the secret word. If the name is not found, the value of <CODE
CLASS="literal"
>$secretword</CODE
> will be an empty string,[<A
CLASS="footnote"
HREF="#ch01-pgfId-869272"
>9</A
>] which we can then check for if we want to define a default secret word for everyone else. Here's how that process looks:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869272"
>[9]</A
> Well, OK, the value is really the <CODE
CLASS="literal"
>undef</CODE
> value, but it looks like an empty string to the <CODE
CLASS="literal"
>eq</CODE
> operator. You'd get a warning about this value if you used <CODE
CLASS="literal"
>-w</CODE
> on the command line, which is why we omitted it here.</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>[... rest of program deleted ...]
  $secretword = $words{$name}; # get the secret word
  if ($secretword eq &quot;&quot;) { # oops, not found
      $secretword = &quot;groucho&quot;; # sure, why a duck?
  }
  print &quot;What is the secret word? &quot;;
[... rest of program deleted ...]</PRE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869224"
>1.6.7 Handling Varying Input Formats</A
></H3
><P
CLASS="para"
>If we enter <CODE
CLASS="literal"
>Erik Olson</CODE
> or <CODE
CLASS="literal"
>erik</CODE
> rather than <CODE
CLASS="literal"
>Erik</CODE
>, we're lumped in with the rest of the users, because the <CODE
CLASS="literal"
>eq</CODE
> comparison requires an exact equality. Let's look at one way to handle that.</P
><P
CLASS="para"
>Suppose we wanted to look for any string that began with <CODE
CLASS="literal"
>Erik</CODE
>, rather than just a string that was equal to <CODE
CLASS="literal"
>Erik</CODE
>. We could do this with a <A
CLASS="indexterm"
NAME="ch01-idx-868878-0"
></A
>regular expression: a template that defines a collection of strings that match. The regular expression in Perl that matches any string that begins with <CODE
CLASS="literal"
>Erik</CODE
> is <CODE
CLASS="literal"
>^Erik</CODE
>. To match this against the string in <CODE
CLASS="literal"
>$name</CODE
>, we use the <A
CLASS="indexterm"
NAME="ch01-idx-868879-0"
></A
>match operator as follows:</P
><PRE
CLASS="programlisting"
>if ($name =~ /^Erik/) {
    ## yes, it matches
} else {
    ## no, it doesn't
}</PRE
><P
CLASS="para"
>Note that the regular expression is delimited by slashes. Within the slashes, spaces and other whitespace are significant, just as they are within strings.</P
><P
CLASS="para"
>This addition almost meets our needs, but it doesn't handle selecting <CODE
CLASS="literal"
>erik</CODE
> or rejecting <CODE
CLASS="literal"
>eriko</CODE
>. To accept <CODE
CLASS="literal"
>erik</CODE
>, we add the <A
CLASS="indexterm"
NAME="ch01-idx-868880-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868880-1"
></A
><EM
CLASS="emphasis"
>ignore-case</EM
> option, a small <CODE
CLASS="literal"
>i</CODE
> appended after the closing slash. To reject <CODE
CLASS="literal"
>eriko</CODE
>, we add a <A
CLASS="indexterm"
NAME="ch01-idx-868881-0"
></A
><EM
CLASS="emphasis"
>word boundary</EM
> special marker in the form of <CODE
CLASS="literal"
>\b</CODE
> in the regular expression. This ensures that the character following the first <CODE
CLASS="literal"
>k</CODE
> in the regular expression is not another letter. The addition also changes the regular expression to be <CODE
CLASS="literal"
>/^erik\b/i</CODE
>, which means "<CODE
CLASS="literal"
>erik</CODE
> at the beginning of the string, no letter or digit following, and OK to be in either case."</P
><P
CLASS="para"
>When this is added to the rest of the program, the final version looks like this:</P
><PRE
CLASS="programlisting"
>%words = qw(
    fred    camel
    barney  gecko
    betty   alpaca
    wilma   alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^erik\b/i) {
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) { # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
  }
  print &quot;What is the secret word? &quot;;
  $guess = &lt;STDIN&gt;;
  chomp ($guess);
  while ($guess ne $secretword) {
      print &quot;Wrong, try again. What is the secret word? &quot;;
      $guess = &lt;STDIN&gt;;
      chomp ($guess);
  }
}</PRE
><P
CLASS="para"
>As you can see, the program is a far cry from the simple <CODE
CLASS="literal"
>Hello world</CODE
>, but it's still very small and workable, and does quite a bit for being so short. This is The Perl Way.</P
><P
CLASS="para"
>Perl provides nearly every regular expression feature imaginable. In addition, the way Perl handles string matching is about the fastest on the planet, so you don't lose performance. String matching in Perl often compares favorably to hand-coded C programs written specifically for the same purpose.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869113"
>1.6.8 Making It Fair for the Rest</A
></H3
><P
CLASS="para"
>So, now we can enter <CODE
CLASS="literal"
>Erik</CODE
> or <CODE
CLASS="literal"
>erik</CODE
> or <CODE
CLASS="literal"
>Erik</CODE
> <CODE
CLASS="literal"
>Olson</CODE
>, but what about everyone else? Barney still has to say exactly <CODE
CLASS="literal"
>barney</CODE
> (not even <CODE
CLASS="literal"
>barney</CODE
> followed by a space).</P
><P
CLASS="para"
>To be fair to Barney, we need to grab the first word of whatever's entered, and then <A
CLASS="indexterm"
NAME="ch01-idx-868883-0"
></A
>convert it to lowercase <EM
CLASS="emphasis"
>before</EM
> we look up the name in the table. We do this with two operators: the <EM
CLASS="emphasis"
>substitute</EM
><A
CLASS="indexterm"
NAME="ch01-idx-868884-0"
></A
> operator, which finds a regular expression and replaces it with a string, and the <EM
CLASS="emphasis"
>translate</EM
><A
CLASS="indexterm"
NAME="ch01-idx-868885-0"
></A
> operator, which puts the string in lowercase.</P
><P
CLASS="para"
>First, we discuss the substitute operator. We want to take the contents of <CODE
CLASS="literal"
>$name</CODE
>, find the first nonword character, and zap everything from there to the end of the string. <CODE
CLASS="literal"
>/\W.*/</CODE
> is the <A
CLASS="indexterm"
NAME="ch01-idx-868886-0"
></A
>regular expression we are looking for&nbsp;- the <CODE
CLASS="literal"
>\W</CODE
> stands for a nonword character (something besides a letter, digit, or underscore), and <CODE
CLASS="literal"
>.*</CODE
> represents any characters from that point to the end of the line. Now, to zap these characters, we need to take whatever part of the string matches this regular expression and replace it with nothing:</P
><PRE
CLASS="programlisting"
>$name =~ s/\W.*//;</PRE
><P
CLASS="para"
>We're using the same <A
CLASS="indexterm"
NAME="ch01-idx-868887-0"
></A
><CODE
CLASS="literal"
>=~</CODE
> operator that we did before, but now on the right we have a substitute operator: the letter <CODE
CLASS="literal"
>s</CODE
> followed by a slash-delimited regular expression and string. (The string in this example is the empty string between the second and third slashes.) This operator looks and acts very much like the substitution command of various editors.</P
><P
CLASS="para"
>Now, to get whatever's left into lowercase, we translate the string using the <A
CLASS="indexterm"
NAME="ch01-idx-868888-0"
></A
><CODE
CLASS="literal"
>tr</CODE
> operator.[<A
CLASS="footnote"
HREF="#ch01-pgfId-3486"
>10</A
>] This operation takes a list of characters to find, and another list of characters with which to replace them. For our example, to put the contents of <CODE
CLASS="literal"
>$name</CODE
> in lowercase, we use:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-3486"
>[10]</A
> This method doesn't work for characters with accent marks, although the <CODE
CLASS="literal"
>uc</CODE
> function would.</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>$name =~ tr/A-Z/a-z/;</PRE
><P
CLASS="para"
>The slashes delimit the searched-for and replacement character lists. The dash between <CODE
CLASS="literal"
>A</CODE
> and <CODE
CLASS="literal"
>Z</CODE
> stands for all the characters in between, so we have two lists that each contain 26 characters. When the <CODE
CLASS="literal"
>tr</CODE
> operator finds a character from the string in the first list, the character is then replaced with the corresponding character in the second list. So, all uppercase A's become lowercase a's, and so on.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869298"
>11</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869298"
>[11]</A
> <A
CLASS="indexterm"
NAME="ch01-idx-868955-0"
></A
>Experts will note that we could have also constructed something like   <CODE
CLASS="literal"
>s/(\S*).*/\L$1/</CODE
> to do this processing in one fell swoop, but experts probably won't be reading this section.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Putting everything together results in the following:</P
><PRE
CLASS="programlisting"
>%words = qw(
    fred    camel
    barney  gecko
    betty   alpaca
    wilma   alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
$original_name = $name; #save for greeting
$name =~ s/\W.*//; # get rid of everything after first word
$name =~ tr/A-Z/a-z/; # lowercase everything
if ($name eq &quot;erik&quot;) { # ok to compare this way now
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $original_name!\n&quot;; # ordinary greeting
    $secretword = $words{$name}; # get the secret word
    if ($secretword eq &quot;&quot;) { # oops, not found
        $secretword = &quot;groucho&quot;; # sure, why a duck?
    }
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while ($guess ne $secretword) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}</PRE
><P
CLASS="para"
>Notice how the regular expression match for <CODE
CLASS="literal"
>Erik</CODE
> became a simple comparison again. After all, both <CODE
CLASS="literal"
>Erik Olson</CODE
> and <CODE
CLASS="literal"
>Erik</CODE
> become <CODE
CLASS="literal"
>erik</CODE
> after the substitution and translation. And everyone else gets a fair ride, because <CODE
CLASS="literal"
>Fred</CODE
> and <CODE
CLASS="literal"
>Fred Flintstone</CODE
> both become <CODE
CLASS="literal"
>fred</CODE
>, <CODE
CLASS="literal"
>Barney Rubble</CODE
> and <CODE
CLASS="literal"
>Barney, the little guy</CODE
> become <CODE
CLASS="literal"
>barney</CODE
>, and so on.</P
><P
CLASS="para"
>With just a few statements, we've made the program much more user friendly. You'll find that expressing complicated string manipulation with a few keystrokes is one of Perl's many strong points.</P
><P
CLASS="para"
>However, hacking away at the name so that we could compare it and look it up in the table destroyed the name that was entered. So, before the program hacks on the name, it saves it in <CODE
CLASS="literal"
>$original_name</CODE
>. (Like C symbols, Perl <A
CLASS="indexterm"
NAME="ch01-idx-868889-0"
></A
>variable names consist of letters, digits, and underscores and can be of nearly unlimited length.) We can then make references to <CODE
CLASS="literal"
>$original_name</CODE
> later.</P
><P
CLASS="para"
>Perl has many ways to monitor and mangle strings. You'll find out about most of them in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="Regular Expressions"
>Chapter 7, <CITE
CLASS="chapter"
>Regular Expressions</CITE
></A
>, and <A
CLASS="xref"
HREF="ch15_01.htm"
TITLE="Other Data Transformation"
>Chapter 15, <CITE
CLASS="chapter"
>Other Data Transformation</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869299"
>1.6.9 Making It a Bit More Modular</A
></H3
><P
CLASS="para"
>Now that we've added so much to the code, we have to scan through many detailed lines in order to get the overall flow of the program. What we need is to separate the high-level logic (asking for a name, looping based on entered secret words) from the details (comparing a secret word to a known good word). We might do this for clarity, or maybe because one person is writing the high-level part and another is writing (or has already written) the detailed parts.</P
><P
CLASS="para"
>Perl provides <A
CLASS="indexterm"
NAME="ch01-idx-868890-0"
></A
><EM
CLASS="emphasis"
>subroutines</EM
> that have <A
CLASS="indexterm"
NAME="ch01-idx-868891-0"
></A
><EM
CLASS="emphasis"
>parameters</EM
> and <A
CLASS="indexterm"
NAME="ch01-idx-868892-0"
></A
><EM
CLASS="emphasis"
>return values</EM
>. A subroutine is defined once in a program, and can be invoked repeatedly from within any expression.</P
><P
CLASS="para"
>For our small-but-rapidly-growing program, let's create a subroutine called <CODE
CLASS="literal"
>good_word</CODE
> that takes a name and a guessed word, and returns <EM
CLASS="emphasis"
>true</EM
> if the word is correct, and <EM
CLASS="emphasis"
>false</EM
> if not. The definition of such a subroutine looks like this:</P
><PRE
CLASS="programlisting"
>sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # get rid of everything after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;erik&quot;) { # should not need to guess
        return 1; # return value is true
  } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
  } else {
        return 0; # return value is false
  }
}</PRE
><P
CLASS="para"
>First, the definition of a subroutine consists of the reserved word <A
CLASS="indexterm"
NAME="ch01-idx-3497-0"
></A
><CODE
CLASS="literal"
>sub</CODE
>, followed by the subroutine name, followed by a <A
CLASS="indexterm"
NAME="ch01-idx-3499-0"
></A
>block of code (delimited by curly braces). These <A
CLASS="indexterm"
NAME="ch01-idx-3500-0"
></A
>definitions can go anywhere in the program file, but most people put them at the end.</P
><P
CLASS="para"
>The first line within this particular definition is an assignment that copies the values of the two parameters of this subroutine into two local variables named <CODE
CLASS="literal"
>$somename</CODE
> and <CODE
CLASS="literal"
>$someguess</CODE
>. (The <CODE
CLASS="literal"
>my()</CODE
> defines the two variables as private to the enclosing block&nbsp;- in this case, the entire subroutine&nbsp;- and the parameters are initially in a special local array called <A
CLASS="indexterm"
NAME="ch01-idx-3507-0"
></A
><CODE
CLASS="literal"
>@_</CODE
>.)</P
><P
CLASS="para"
>The next two lines clean up the name, just like in the previous version of the program.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>if-elsif-else</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868897-0"
></A
> statement decides whether the guessed word (<CODE
CLASS="literal"
>$someguess</CODE
>) is correct for the name (<CODE
CLASS="literal"
>$somename</CODE
>). <CODE
CLASS="literal"
>Erik</CODE
> should not make it into this subroutine, but even if it does, whatever word was guessed is OK.</P
><P
CLASS="para"
>A <CODE
CLASS="literal"
>return</CODE
> statement can be used to make the subroutine immediately return to its caller with the supplied value. In the absence of an explicit <CODE
CLASS="literal"
>return</CODE
> statement, the last expression evaluated in a subroutine is the return value. We'll see how the return value is used after we finish describing the subroutine definition.</P
><P
CLASS="para"
>The test for the <CODE
CLASS="literal"
>elsif</CODE
> part looks a little complicated&nbsp;- let's break it apart:</P
><PRE
CLASS="programlisting"
>($words{$somename} || &quot;groucho&quot;) eq $someguess</PRE
><P
CLASS="para"
>The first thing inside the parentheses is our familiar hash lookup, yielding some value from <CODE
CLASS="literal"
>%words</CODE
> based on a key of <CODE
CLASS="literal"
>$somename</CODE
>. The operator between that value and the string <CODE
CLASS="literal"
>groucho</CODE
> is the <A
CLASS="indexterm"
NAME="ch01-idx-868898-0"
></A
><CODE
CLASS="literal"
>||</CODE
> (logical-or) operator similar to that used in C. If the lookup from the hash has a value (meaning that the key <CODE
CLASS="literal"
>$somename</CODE
> was in the hash), the value of the expression is that value. If the key could not be found, the string <CODE
CLASS="literal"
>groucho</CODE
> is used instead. This step is a very Perl-like thing to do&nbsp;- specify some expression, and then provide a <A
CLASS="indexterm"
NAME="ch01-idx-3522-0"
></A
>default value using <CODE
CLASS="literal"
>||</CODE
> in case the expression turns out to be false.</P
><P
CLASS="para"
>In any case, whether it's a value from the hash, or the default value <CODE
CLASS="literal"
>groucho</CODE
>, we compare it to whatever was guessed. If the comparison is true, we return 1; otherwise, we return 0.</P
><P
CLASS="para"
>So, expressed as a rule, if the name is <CODE
CLASS="literal"
>erik</CODE
>, or the guess matches the lookup in <CODE
CLASS="literal"
>%words</CODE
> based on the name (with a default of <CODE
CLASS="literal"
>groucho</CODE
> if not found), then the subroutine returns 1; otherwise, it returns 0.</P
><P
CLASS="para"
>Now, let's integrate all these additions with the rest of the program:</P
><PRE
CLASS="programlisting"
>%words = qw(
    fred    camel
    barney  gecko
    betty   alpaca
    wilma   alpaca
);
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^erik\b/i) { # back to the other way :-)
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
  while (! good_word($name,$guess)) {
    print &quot;Wrong, try again. What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp $guess;
  }
}
[... insert definition of good_word() here ...]</PRE
><P
CLASS="para"
>Notice that we've gone back to the <A
CLASS="indexterm"
NAME="ch01-idx-868899-0"
></A
>regular expression to check for <CODE
CLASS="literal"
>Erik</CODE
>, because now the main program does not have to pull apart the first name and convert it to lowercase.</P
><P
CLASS="para"
>The big difference is the <A
CLASS="indexterm"
NAME="ch01-idx-868900-0"
></A
><CODE
CLASS="literal"
>while</CODE
> loop containing <CODE
CLASS="literal"
>good_word</CODE
>. Here, we see an invocation of the subroutine passing two parameters, <CODE
CLASS="literal"
>$name</CODE
> and <CODE
CLASS="literal"
>$guess</CODE
>. Within the subroutine, the value of <CODE
CLASS="literal"
>$somename</CODE
> is set from the first parameter, in this case <CODE
CLASS="literal"
>$name</CODE
>. Likewise, <CODE
CLASS="literal"
>$someguess</CODE
> is set from the second parameter, <CODE
CLASS="literal"
>$guess</CODE
>.</P
><P
CLASS="para"
>The value returned by the subroutine (either 1 or 0, recalling the definition given earlier) is logically inverted with the prefix <A
CLASS="indexterm"
NAME="ch01-idx-868949-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868949-1"
></A
><CODE
CLASS="literal"
>!</CODE
> (logical not) operator. As in C, this operator returns true if the expression following is false, and vice versa. The result of this negation controls the <CODE
CLASS="literal"
>while</CODE
> loop. You can read this as "while it's not a good word..." Many well-written Perl programs read very much like English, provided you take a few liberties with either Perl or English. (But you certainly won't win a Pulitzer that way.)</P
><P
CLASS="para"
>Note that the subroutine assumes that the value of the <CODE
CLASS="literal"
>%words</CODE
> hash is set by the main program.</P
><P
CLASS="para"
>Such a cavalier approach to global variables doesn't scale very well, of course. Generally speaking, variables not created with <CODE
CLASS="literal"
>my</CODE
> are global to the whole program, while those <CODE
CLASS="literal"
>my</CODE
> creates last only until the block in which they were declared exits. Don't worry; Perl does in fact support a rich variety of other kinds of variables, including those private to a file (or package), as well as variables private to a function that retain their values between invocations (which is what we could really use here). However, at this stage in your Perl education, explaining these variables would only complicate your life. When you're ready for such information, check out what <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
> has to say about scoping, subroutines, modules, and objects. Or, see the online documentation in the <EM
CLASS="emphasis"
>perlsub</EM
> , <EM
CLASS="emphasis"
>perlmod</EM
> , <EM
CLASS="emphasis"
>perlobj</EM
> , and <EM
CLASS="emphasis"
>perltoot</EM
>  documentation.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869115"
>1.6.10 Moving the Secret Word List into a Separate File</A
></H3
><P
CLASS="para"
>Suppose we wanted to share the secret word list among three programs. If we store the word list as we have done already, we will need to change all three programs when Betty decides that her secret word should be <CODE
CLASS="literal"
>swine</CODE
> rather than <CODE
CLASS="literal"
>alpaca</CODE
>. This change can get to be a hassle, especially considering how often Betty is likely to change her mind.</P
><P
CLASS="para"
>So, let's put the word list into a file, and then read the file to get the word list into the program. To do so, we need to create an I/O channel called a <A
CLASS="indexterm"
NAME="ch01-idx-868902-0"
></A
><EM
CLASS="emphasis"
>filehandle</EM
>. Your Perl program automatically gets three filehandles called <A
CLASS="indexterm"
NAME="ch01-idx-868903-0"
></A
><CODE
CLASS="literal"
>STDIN</CODE
>, <CODE
CLASS="literal"
>STDOUT</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868904-0"
></A
>, and <A
CLASS="indexterm"
NAME="ch01-idx-868905-0"
></A
><CODE
CLASS="literal"
>STDERR</CODE
>, corresponding to the three standard I/O channels in many programming environments. We've already been using the <CODE
CLASS="literal"
>STDIN</CODE
> handle to read data from the person running the program. Now, we just have to get another handle attached to a file of our own choice.</P
><P
CLASS="para"
>Here's a small chunk of code to do that:</P
><PRE
CLASS="programlisting"
>sub init_words {
    open (WORDSLIST, &quot;wordslist&quot;);
    while (defined ($name = &lt;WORDSLIST&gt;)) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
        $words{$name} = $word;
     }
     close (WORDSLIST);
}</PRE
><P
CLASS="para"
>We're putting this code into a subroutine so that we can keep the main part of the program uncluttered. This organization also means that at a later time (hint: after a few more revisions in this stroll), we can change where the word list is stored, or even the format of the list.</P
><P
CLASS="para"
>The arbitrarily chosen format of the word list is one item per line, with names and words alternating. So, for our current database, we'd have something like this:</P
><PRE
CLASS="programlisting"
>fred
camel
barney
gecko
betty
alpaca
wilma
alpaca</PRE
><P
CLASS="para"
>The <EM
CLASS="emphasis"
></EM
><A
CLASS="indexterm"
NAME="ch01-idx-868906-0"
></A
><CODE
CLASS="literal"
>open </CODE
> function creates a <A
CLASS="indexterm"
NAME="ch01-idx-868956-0"
></A
>filehandle named <CODE
CLASS="literal"
>WORDSLIST</CODE
> by associating it with a file named <CODE
CLASS="literal"
>wordslist</CODE
> in the current directory. Note that the filehandle doesn't have a funny character in front of it as do the three variable types. Also, filehandles are generally <A
CLASS="indexterm"
NAME="ch01-idx-868957-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868957-1"
></A
>uppercase&nbsp;- although they aren't required to be&nbsp;- for reasons detailed later.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>while</CODE
> loop reads lines from the <CODE
CLASS="literal"
>wordslist</CODE
> file (via the <CODE
CLASS="literal"
>WORDSLIST</CODE
> filehandle) one line at a time. Each line is stored into the <CODE
CLASS="literal"
>$name</CODE
> variable. When <A
CLASS="indexterm"
NAME="ch01-idx-868907-0"
></A
>end-of-file is reached, the value returned by the <CODE
CLASS="literal"
>&lt;WORDSLIST&gt;</CODE
> operation is the empty string,[<A
CLASS="footnote"
HREF="#ch01-pgfId-869371"
>12</A
>] which looks false to the <CODE
CLASS="literal"
>while</CODE
> loop, and terminates it. That's how we get out at the end.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869371"
>[12]</A
> Well, technically the value is <CODE
CLASS="literal"
>undef</CODE
> again, but empty string is close enough for this discussion.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>If you were running with the <B
CLASS="emphasis.bold"
>-w</B
> option, you would have to check that the return value read in was actually <CODE
CLASS="literal"
>defined</CODE
>. The empty string returned by the <CODE
CLASS="literal"
>&lt;WORDSLIST&gt;</CODE
> operation isn't merely empty&nbsp;- it's <CODE
CLASS="literal"
>undef</CODE
> again. The <CODE
CLASS="literal"
>defined</CODE
> function is how you test for <CODE
CLASS="literal"
>undef</CODE
> when this matters. In the case of reading lines from a file, you'd test as shown:</P
><PRE
CLASS="programlisting"
> while ( defined ($name = &lt;WORDSLIST&gt;) ) { </PRE
><P
CLASS="para"
>But if you were being that careful, you'd probably also have checked to make sure that <CODE
CLASS="literal"
>open</CODE
> returned a true value. You know, that's probably not a bad idea either. The built-in <CODE
CLASS="literal"
>die</CODE
> function is frequently used to exit the program with an error message in case something goes wrong. We'll see an example of this function in the next revision of the program.</P
><P
CLASS="para"
>On the other hand, the normal case is that we've read a line (including the newline) into <CODE
CLASS="literal"
>$name</CODE
>. First, off comes the newline using the <A
CLASS="indexterm"
NAME="ch01-idx-868908-0"
></A
><CODE
CLASS="literal"
>chomp</CODE
> function. Then, we have to read the next line to get the secret word, holding it in the <CODE
CLASS="literal"
>$word</CODE
> variable. This variable also gets the newline hacked off.</P
><P
CLASS="para"
>The final line of the <CODE
CLASS="literal"
>while</CODE
> loop puts <CODE
CLASS="literal"
>$word</CODE
> into <CODE
CLASS="literal"
>%words</CODE
> with a key of <CODE
CLASS="literal"
>$name</CODE
>, so that the rest of the program can access it later.</P
><P
CLASS="para"
>After the file has been read, the filehandle can be recycled with the <A
CLASS="indexterm"
NAME="ch01-idx-3586-0"
></A
><CODE
CLASS="literal"
>close</CODE
> function. (Filehandles are automatically closed anyway when the program exits, but we're trying to be tidy. If we were <EM
CLASS="emphasis"
>really</EM
> tidy, we'd even check for a true return value from <CODE
CLASS="literal"
>close</CODE
> in case the disk partition which held the file went south, its network filesystem became unreachable, or a similar catastrophe occurred. Yes, these things really do happen. Murphy will always be with us.)</P
><P
CLASS="para"
>This subroutine definition can go after or before the other one. And, we invoke the subroutine instead of setting <CODE
CLASS="literal"
>%words</CODE
> in the beginning of the program. Therefore, you could wrap up all of this as follows:</P
><PRE
CLASS="programlisting"
>init_words();
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
if ($name =~ /^erik\b/i) { # back to the other way :-)
    print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = &lt;STDIN&gt;;
    chomp ($guess);
    while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
    }
}
## subroutines from here down
sub init_words {
    open (WORDSLIST,&quot;wordslist&quot;) || 
            die &quot;can't open wordlist:$!&quot;;
    while (defined ($name = &lt;WORDSLIST&gt;)) {
        chomp ($name);
        $word = &lt;WORDSLIST&gt;;
        chomp ($word);
        $words{$name} = $word;
    }
    close (WORDSLIST);
}
sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # delete everything after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;erik&quot;) { # should not need to guess
        return 1; # return value is true
    } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
    } else {
        return 0; # return value is false
    }
}</PRE
><P
CLASS="para"
>Now our program is starting to look full-grown. Notice the first executable line is an invocation of <CODE
CLASS="literal"
>init_words()</CODE
>. The return value is not used in a further calculation, which is good because we didn't return anything remarkable. In this case, a true value is guaranteed (the value 1, in particular), because if the <CODE
CLASS="literal"
>close</CODE
> had failed, the <CODE
CLASS="literal"
>die</CODE
> would have printed a message to our STDERR error and exited the program. The <CODE
CLASS="literal"
>die</CODE
> function is fully explained in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10, <CITE
CLASS="chapter"
>Filehandles and File Tests</CITE
></A
><EM
CLASS="emphasis"
>,</EM
> but because the return values of anything that might fail must be checked, we'll get into the habit of using the function right from the start. The $! variable (also explained in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10</A
>) contains the system error message explaining why the system call failed.</P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>open </CODE
> function is also used to open files for output, or open programs as files (demonstrated shortly). The full scoop on <CODE
CLASS="literal"
>open</CODE
> comes much later in this book, however, in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869405"
>1.6.11 Ensuring a Modest Amount of Security</A
></H3
><P
CLASS="para"
>"That secret word list has got to change at least once a week!" cries the Chief Director of Secret Word Lists. Well, we can't force the list to be different, but we can at least issue a warning if the secret word list has not been modified in more than a week.</P
><P
CLASS="para"
>The best place for handling this warning is the <CODE
CLASS="literal"
>init_words()</CODE
> subroutine&nbsp;- we're already looking at the file there. The Perl operator <A
CLASS="indexterm"
NAME="ch01-idx-868911-0"
></A
><CODE
CLASS="literal"
>-M</CODE
> returns the <A
CLASS="indexterm"
NAME="ch01-idx-868959-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868959-1"
></A
>age in days since a file or filehandle has last been modified, so we just need to see whether this value is greater than seven for the <CODE
CLASS="literal"
>WORDSLIST</CODE
> filehandle:</P
><PRE
CLASS="programlisting"
>sub init_words {
    open (WORDSLIST,&quot;wordslist&quot;) || 
            die &quot;can't open wordlist:$!&quot;;
    if (-M WORDSLIST &gt; 7.0) { # comply with bureaucratic policy
        die &quot;Sorry, the wordslist is older than seven days.&quot;;
    }
   while (defined ($name = &lt;WORDSLIST&gt;)) {
       chomp ($name);
       $word = &lt;WORDSLIST&gt;;
      chomp ($word);
      $words{$name} = $word;
    }
    close (WORDSLIST) || die &quot;couldn't close wordlist: $!&quot;;
}</PRE
><P
CLASS="para"
>The value of <CODE
CLASS="literal"
>-M WORDSLIST</CODE
> is compared to seven, and if the value is greater, bingo, we've violated policy.</P
><P
CLASS="para"
>The rest of the program remains unchanged, so in the interest of saving a few trees, we won't repeat it here.</P
><P
CLASS="para"
>Besides getting the age of a file, we can also find out its size, access time, and everything else that an operating system maintains about a file. More information about this feature appears in <A
CLASS="xref"
HREF="ch10_01.htm"
TITLE="Filehandles and File Tests"
>Chapter 10</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869118"
>1.6.12 Warning Someone When Things Go Astray</A
></H3
><P
CLASS="para"
>We really ought to know when someone guesses incorrectly so that we can watch for break-in attempts. If we were using a UNIX system, we would probably use the <EM
CLASS="emphasis"
>mail</EM
> command to send an email message to someone about the failed attempt. However, on a Windows workstation, no standard <EM
CLASS="emphasis"
>mail  </EM
>[<A
CLASS="footnote"
HREF="#ch01-pgfId-2130"
>13</A
>] command exists, so we're going to log failures to a file.[<A
CLASS="footnote"
HREF="#ch01-pgfId-2477"
>14</A
>] We need only do a little work to accomplish this task. We'll add a new subroutine and modify only the <CODE
CLASS="literal"
>good_word()</CODE
> subroutine (thanks to modularity), because we have all the information we need:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-2130"
>[13]</A
> Perl for Win32 programmers will encounter this <EM
CLASS="emphasis"
>mail</EM
> comand issue frequently in scripts that they find on the Net.  The solution is to use one of a number of readily available command-line mailers, or to use Perl's network interface to talk to an SMTP server directly.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-2477"
>[14]</A
> We could also use the Win32::EventLog module to log our warnings to the Windows NT Event Log.</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>sub good_word {
    my($somename,$someguess) = @_; # name the parameters
    $somename =~ s/\W.*//; # get rid of stuff after first word
    $somename =~ tr/A-Z/a-z/; # lowercase everything
    if ($somename eq &quot;erik&quot;) { # should not need to guess
        return 1; # return value is true
    } elsif (($words{$somename}||&quot;groucho&quot;) eq $someguess) {
        return 1; # return value is true
    } else {
        log_failure($somename, $someguess);
        return 0; # return value is false
    }
}

sub log_failure {
    my($somename,$someguess) = @_; # name the parameters
    open(LOG, &quot;&gt;&gt;failures.log&quot;) || die &quot;failures.log: $!&quot;;
    print LOG &quot;bad news: $somename guessed $someguess\n&quot;;
    close (LOG)  || die &quot;can't close failures.log: $!&quot;;
}</PRE
><P
CLASS="para"
>Notice the<EM
CLASS="emphasis"
> </EM
><A
CLASS="indexterm"
NAME="ch01-idx-871655-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-871655-2"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-871655-3"
></A
><CODE
CLASS="literal"
>open</CODE
>, which has a redirection symbol (<CODE
CLASS="literal"
>&gt;&gt;</CODE
>) in the filename. This symbol is a special indication that we are appending to a file. The next statement, a <CODE
CLASS="literal"
>print</CODE
>, shows that a <A
CLASS="indexterm"
NAME="ch01-idx-868962-0"
></A
>filehandle between the <A
CLASS="indexterm"
NAME="ch01-idx-868915-0"
></A
><CODE
CLASS="literal"
>print</CODE
> keyword and the values to be printed selects that filehandle for output, rather than <CODE
CLASS="literal"
>STDOUT</CODE
>.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869470"
>15</A
>] This means that the message will be written to the output file that we've opened. Finally, we close the filehandle.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869470"
>[15]</A
> Well, technically, the currently selected filehandle. That's covered much later, though.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869121"
>1.6.13 Many Secret Word Files in the Current Directory</A
></H3
><P
CLASS="para"
>Let's change the definition of the secret word filename slightly. Instead of just the file named <CODE
CLASS="literal"
>wordslist</CODE
>, let's look for anything in the current directory that ends in <CODE
CLASS="literal"
>.sec</CODE
>. At the command prompt, we say:</P
><PRE
CLASS="programlisting"
>&gt; <B
CLASS="emphasis.bold"
>dir /B *.sec</B
></PRE
><P
CLASS="para"
>to get a brief listing of all of these names. As you'll see in a moment, Perl uses a similar wildcard name syntax.</P
><P
CLASS="para"
>Pulling out the <CODE
CLASS="literal"
>init_words()</CODE
> definition again:</P
><PRE
CLASS="programlisting"
>sub init_words {
    while (defined ($filename = glob(&quot;*.sec&quot;)) ) {
        open (WORDSLIST, $filename) || 
                die &quot;can't open $filename:$!&quot;;
        if (-M WORDSLIST &lt;= 7.0) {
            while (defined ($name = &lt;WORDSLIST&gt;)) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
             }
        }
    close (WORDSLIST) || die &quot;couldn't close $filename: $!&quot;;
    }
}</PRE
><P
CLASS="para"
>First, I've wrapped a new <A
CLASS="indexterm"
NAME="ch01-idx-868919-0"
></A
><CODE
CLASS="literal"
>while</CODE
> loop around the bulk of the routine from the previous version. The new thing here is the <CODE
CLASS="literal"
>glob</CODE
> function. This is called a <A
CLASS="indexterm"
NAME="ch01-idx-868916-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868916-1"
></A
><EM
CLASS="emphasis"
>filename glob</EM
>[<A
CLASS="footnote"
HREF="#ch01-pgfId-3355"
>16</A
>] for historical reasons. The function works much like <CODE
CLASS="literal"
>&lt;STDIN&gt;</CODE
>, in that each time it is accessed, it returns the next value: successive filenames that match the pattern, in this case <CODE
CLASS="literal"
>*.sec</CODE
>. When there are no additional filenames to be returned, the filename glob returns an empty string.[<A
CLASS="footnote"
HREF="#ch01-pgfId-869495"
>17</A
>] In Perl on Windows systems, filename globbing[<A
CLASS="footnote"
HREF="#ch01-pgfId-2525"
>18</A
>] is implemented by means of another program, called <EM
CLASS="emphasis"
>PerlGlob.exe</EM
>, which must be somewhere in your search path (this should usually be the case, because <EM
CLASS="emphasis"
>PerlGlob.exe</EM
> is installed in the same directory as your Perl interpreter by default).</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-3355"
>[16]</A
> Glob might be a new word to Win32 programmers.  We'll talk much more about globbing in <A
CLASS="xref"
HREF="ch12_01.htm"
TITLE="Directory Access"
>Chapter 12, <CITE
CLASS="chapter"
>Directory Access</CITE
></A
>.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-869495"
>[17]</A
> Yeah, yeah, <CODE
CLASS="literal"
>undef</CODE
> again.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-2525"
>[18]</A
> If you're using the ISAPI version of Perl, you'll have better luck if you avoid file globbing altogether and use the following equivalent technique:</P
><PRE
CLASS="programlisting"
><CODE
CLASS="literal"
>opendir(DIR, `.');</CODE
>
<CODE
CLASS="literal"
>@files = grep(/\.sec$/, readdir(DIR));</CODE
>
<CODE
CLASS="literal"
>closedir DIR;</CODE
></PRE
><P
CLASS="para"
>This method leaves you with a list (<CODE
CLASS="literal"
>@files</CODE
>) of all filenames in the current directory that contain the <CODE
CLASS="literal"
>.sec</CODE
> pattern.  We'll provide more information on this later.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>So, if the current directory contains <CODE
CLASS="literal"
>fred.sec</CODE
> and <CODE
CLASS="literal"
>barney.sec</CODE
>, then <CODE
CLASS="literal"
>$filename</CODE
> is <CODE
CLASS="literal"
>barney.sec</CODE
> on the first pass through the <CODE
CLASS="literal"
>while</CODE
> loop (the names come out in alphabetically sorted order). On the second pass, <CODE
CLASS="literal"
>$filename</CODE
> is <CODE
CLASS="literal"
>fred.sec</CODE
>. And there is no third pass because the glob returns an empty string the third time it is called, perceived by the <CODE
CLASS="literal"
>while</CODE
> loop to be a false, causing an exit from the subroutine.</P
><P
CLASS="para"
>Within the <CODE
CLASS="literal"
>while</CODE
> loop, we open the file and verify that it is recent enough (less than seven days since the last modification). For the recent-enough files, we scan through as before.</P
><P
CLASS="para"
>Note that if there are no files that match <CODE
CLASS="literal"
>*.sec</CODE
> and are less than seven days old, the subroutine will exit without having set any secret words into the <CODE
CLASS="literal"
>%words</CODE
> array. In such a case, everyone must use the word <CODE
CLASS="literal"
>groucho</CODE
>. Oh well. (For <EM
CLASS="emphasis"
>real</EM
> code, we would have added some check on the number of entries in <CODE
CLASS="literal"
>%words</CODE
> before returning, and <A
CLASS="indexterm"
NAME="ch01-idx-2226-0"
></A
><CODE
CLASS="literal"
>die</CODE
>'d if the check wasn't good. See the <CODE
CLASS="literal"
>keys</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-2227-0"
></A
> function when we get to hashes in <A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Hashes"
>Chapter 5, <CITE
CLASS="chapter"
>Hashes</CITE
></A
>.)</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-2558"
>1.6.14 Listing the Secret Words</A
></H3
><P
CLASS="para"
>Well, the Chief Director of Secret Word Lists wants a <A
CLASS="indexterm"
NAME="ch01-idx-2559-0"
></A
>report of all the secret words currently in use, and how old they are. If we set aside the secret word program for a moment, we'll have time to write a reporting program for the Director.</P
><P
CLASS="para"
>First, let's get all of the secret words, by stealing some code from the <CODE
CLASS="literal"
>init_words()</CODE
> subroutine:</P
><PRE
CLASS="programlisting"
>while ( defined ($filename = glob(&quot;*.sec&quot;)) ) {
    open (WORDSLIST, $filename) || 
            die &quot;can't open $filename: $!&quot;;
    if (-M WORDSLIST &lt;= 7.0) {
        while (defined ($name = &lt;WORDSLIST&gt;) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
            chomp ($word);
            ### new stuff will go here
        }
    }
    close (WORDSLIST) || die &quot;couldn't close $filename: $!&quot;;
}</PRE
><P
CLASS="para"
>At the point marked "new stuff will go here," we know three things: the name of the file (<CODE
CLASS="literal"
>$filename</CODE
>), someone's name (<CODE
CLASS="literal"
>$name</CODE
>), and that person's secret word (<CODE
CLASS="literal"
>$word</CODE
>). Here's a place to use Perl's report generating tools. We define a <A
CLASS="indexterm"
NAME="ch01-idx-868924-0"
></A
>format somewhere in the program (usually near the end, like a subroutine):</P
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch01-idx-868968-0"
></A
>format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.</PRE
><P
CLASS="para"
>The format definition begins with <CODE
CLASS="literal"
>format STDOUT =</CODE
>, and ends with a single period. The other two lines comprise the format itself. The first line of this format is a <A
CLASS="indexterm"
NAME="ch01-idx-868925-0"
></A
><EM
CLASS="emphasis"
>field definition line</EM
> that specifies the number, length, and type of the fields. For this format, we have three fields. The line following a field definition line is always a <A
CLASS="indexterm"
NAME="ch01-idx-868926-0"
></A
><EM
CLASS="emphasis"
>field value line</EM
>. The value line gives a list of expressions that will be evaluated when this format is used, and the results of those expressions will be plugged into the fields defined in the previous line.</P
><P
CLASS="para"
>We invoke this format with the <A
CLASS="indexterm"
NAME="ch01-idx-4557-0"
></A
><CODE
CLASS="literal"
>write</CODE
> function, as shown:</P
><PRE
CLASS="programlisting"
>while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
    open (WORDSLIST, $filename) || 
            die &quot;can't open $filename: $!&quot;;
    if (-M WORDSLIST &lt;= 7.0) {
        while (defined ($name = &lt;WORDSLIST&gt;) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
            chomp ($word);
            write; # invoke format STDOUT to STDOUT
        }
    }
    close (WORDSLIST) || die &quot;couldn't close $filename: $!&quot;;
}
format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.</PRE
><P
CLASS="para"
>When the format is invoked, Perl evaluates the field expressions and generates a line that it sends to the <CODE
CLASS="literal"
>STDOUT</CODE
> filehandle. Because <CODE
CLASS="literal"
>write</CODE
> is invoked once each time through the loop, we'll get a series of lines with text in columns, one line for each secret word entry.</P
><P
CLASS="para"
>Hmm. We haven't labeled the <A
CLASS="indexterm"
NAME="ch01-idx-868969-0"
></A
>columns. That's easy enough. We just need to add a <A
CLASS="indexterm"
NAME="ch01-idx-868928-0"
></A
>top-of-page format, as shown:</P
><PRE
CLASS="programlisting"
>format STDOUT_TOP =
Page @&lt;&lt;
$%

Filename         Name       Word
================ ========== ============
.</PRE
><P
CLASS="para"
>This format is named <CODE
CLASS="literal"
>STDOUT_TOP</CODE
>, and will be used initially at the first invocation of the <CODE
CLASS="literal"
>STDOUT</CODE
> format, and again every time 60 lines of output to <CODE
CLASS="literal"
>STDOUT</CODE
> have been generated. These column headings line up with the columns from the <CODE
CLASS="literal"
>STDOUT</CODE
> format, so everything comes out tidy. </P
><P
CLASS="para"
>The first line of this format shows some constant text (<CODE
CLASS="literal"
>Page</CODE
>) along with a three-character field definition. The following line is a field value line, which in this  case has one expression. This expression is the <A
CLASS="indexterm"
NAME="ch01-idx-868929-0"
></A
><CODE
CLASS="literal"
>$%</CODE
> variable,[<A
CLASS="footnote"
HREF="#ch01-pgfId-3703"
>19</A
>] which holds the number of pages printed&nbsp;- a very useful value in top-of-page formats.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-3703"
>[19]</A
> More mnemonic aliases for these predefined scalar variables are available via the English module, which provides English names for Perl's special variables.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The third line of the format is blank. Because this line does not contain any fields, the line following it is not a field value line. This blank line is copied directly to the output, creating a blank line between the page number and the column headers below.</P
><P
CLASS="para"
>The last two lines of the format also contain no fields, so they are copied as-is, directly to the output. So this format generates four lines, one of which has a part that changes from page to page. </P
><P
CLASS="para"
>Just tack this definition onto the previous program to get it to work. Perl notices the top-of-page format automatically. </P
><P
CLASS="para"
>Perl also has fields that are centered or right justified, and supports a <EM
CLASS="emphasis"
>filled paragraph area</EM
> as well. More on these features when we get to formats in <A
CLASS="xref"
HREF="ch11_01.htm"
TITLE="Formats"
>Chapter 11, <CITE
CLASS="chapter"
>Formats</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869613"
>1.6.15 Making Those Old Word Lists More Noticeable</A
></H3
><P
CLASS="para"
>As we are scanning through the <CODE
CLASS="literal"
>*.sec</CODE
> files in the current directory, we may find files that are too old. So far, we are simply skipping over those files. Let's go one step more&nbsp;- we'll <A
CLASS="indexterm"
NAME="ch01-idx-868930-0"
></A
><A
CLASS="indexterm"
NAME="ch01-idx-868930-1"
></A
>rename them to <CODE
CLASS="literal"
>*.sec.old</CODE
> so that a directory listing will quickly show us which files are too old, simply by name.</P
><P
CLASS="para"
>Here's how the <CODE
CLASS="literal"
>init_words()</CODE
> subroutine looks with this modification:</P
><PRE
CLASS="programlisting"
>sub init_words {
    while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
        open (WORDSLIST, $filename) || 
                die &quot;can't open $filename: $!&quot;;
        if (-M WORDSLIST &lt;= 7.0) {
            while (defined ($name = &lt;WORDSLIST&gt;)) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
            }
            close (WORDSLIST) ||
                    die &quot;can't close $filename: $!&quot;;
        }
        else {
            # must close file before renaming it
            close (WORDSLIST) ||
                    die &quot;can't close $filename.old: $!&quot;
            rename ($filename,&quot;$filename.old&quot;) ||
                    die &quot;can't rename $filename: $!&quot;;
        }
    }
}</PRE
><P
CLASS="para"
>Notice the new <CODE
CLASS="literal"
>else</CODE
> part of the file age check. If the file is older than seven days, it gets renamed with the <A
CLASS="indexterm"
NAME="ch01-idx-868931-0"
></A
><CODE
CLASS="literal"
>rename</CODE
> function. This function takes two parameters, renaming the file named by the first parameter to the name given in the second parameter. </P
><P
CLASS="para"
>Perl has a complete range of file manipulation operators&nbsp;- nearly anything you can do to a file from a C program, you can also do from Perl.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869617"
>1.6.16 Maintaining a Last-Good-Guess Database</A
></H3
><P
CLASS="para"
>Let's keep track of when the most recent correct guess has been made for each user. One data structure that might seem to work at first glance is a hash. For example, the statement:</P
><PRE
CLASS="programlisting"
>$last_good{$name} = <A
CLASS="indexterm"
NAME="ch01-idx-868932-0"
></A
>time;</PRE
><P
CLASS="para"
>assigns the current time in internal format (some large integer above 800 million, incrementing one number per second) to an element of <CODE
CLASS="literal"
>%last_good</CODE
> that has the name for a key. Over time, this method would seem to give us a database indicating the most recent time the secret word was guessed properly for each of the users who had invoked the program.</P
><P
CLASS="para"
>But, the hash doesn't have an existence between invocations of the program. Each time the program is invoked, a new hash is formed, so at most, we create a one-element hash and then immediately forget it when the program exits.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch01-idx-868933-0"
></A
><CODE
CLASS="literal"
>dbmopen</CODE
> function[<A
CLASS="footnote"
HREF="#ch01-pgfId-3724"
>20</A
>] maps a hash out into a disk file (actually a pair of disk files) known as a <A
CLASS="indexterm"
NAME="ch01-idx-868934-0"
></A
>DBM. It's used like this:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-3724"
>[20]</A
> On a specific database, use the more low-level <CODE
CLASS="literal"
>tie</CODE
> function, as detailed in Chapters <A
CLASS="olink"
HREF="../prog/ch05_01.htm"
>5</A
> and <A
CLASS="olink"
HREF="../prog/ch07_01.htm"
>7</A
> of <A
CLASS="citetitle"
HREF="../prog/index.htm"
TITLE="Programming Perl"
><CITE
CLASS="citetitle"
>Programming Perl</CITE
></A
>, or in the <EM
CLASS="emphasis"
>perltie</EM
>  documentation.</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
               die &quot;can't dbmopen lastdb: $!&quot;;
$last_good{$name} = time;
dbmclose (%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;</PRE
><P
CLASS="para"
>The first statement performs the mapping, using the disk filenames of <CODE
CLASS="literal"
>lastdb.dir</CODE
> and <CODE
CLASS="literal"
>lastdb.pag</CODE
> (these names are the normal names for a DBM called <CODE
CLASS="literal"
>lastdb</CODE
>). Showing Perl's UNIX heritage, <A
CLASS="indexterm"
NAME="ch01-idx-4577-0"
></A
><CODE
CLASS="literal"
>dbmopen</CODE
> takes an octal file permission mask as the third argument. Although all Windows filesystems support file attributes of some sort, they are largely incompatible with the UNIX filesystem scheme used by Perl. The UNIX file permissions used for these two files, if the files must be created (as they will the first time through), is <CODE
CLASS="literal"
>0666</CODE
>. This mode means that anyone can read or write the files. This mode is usually the one that you want to use when working with files with read/write attributes.[<A
CLASS="footnote"
HREF="#ch01-pgfId-4580"
>21</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="ch01-pgfId-4580"
>[21]</A
> The Win32::File module provides additional features for setting file attributes.  We'll discuss those features in more detail in <A
CLASS="xref"
HREF="ch13_01.htm"
TITLE="File and Directory Manipulation"
>Chapter 13, <CITE
CLASS="chapter"
>File and Directory Manipulation</CITE
></A
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The Perl file <A
CLASS="indexterm"
NAME="ch01-idx-871653-0"
></A
>permission value is composed of a series of bits with read, write, and execute privileges for the user, the user's group, and everyone else. Traditionally, FAT filesystems only keep track of read and write privileges for the user, along with a few other tidbits of information, like whether the file is a hidden or a system file. We'll discuss file permissions and attributes in detail in <A
CLASS="xref"
HREF="ch13_01.htm"
TITLE="File and Directory Manipulation"
>Chapter 13</A
>. For now, just trust us that you want to use <CODE
CLASS="literal"
>0666</CODE
> for creating DBM files.</P
><P
CLASS="para"
>The second statement shows that we use this mapped hash just like a normal hash. However, creating or updating an element of the hash automatically updates the disk files that form the DBM. And, when the hash is later accessed, the values within the hash come directly from the disk image. This gives the hash a life beyond the current invocation of the program&nbsp;- a persistence of its own.</P
><P
CLASS="para"
>The third statement disconnects the hash from the DBM, much like a file <CODE
CLASS="literal"
>close</CODE
> operation.</P
><P
CLASS="para"
>You can insert these three statements just ahead of the subroutine definitions.</P
><P
CLASS="para"
>Although the inserted statements maintain the database adequately (and even create the database initially), we don't have any way of examining the information yet. To do so, we can create a separate little program that looks something like this:</P
><PRE
CLASS="programlisting"
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                 die &quot;can't dbmopen lastdb: $!&quot;;
foreach $name (sort keys %last_good) {
    $when = $last_good{$name};
     $hours = (time - $when) / 3600; # compute hours ago
     write;
}

format STDOUT =
User @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: last correct guess was @&lt;&lt;&lt; hours ago.
$name, $hours
.</PRE
><P
CLASS="para"
>We've got a few new operations here: a <CODE
CLASS="literal"
>foreach</CODE
><A
CLASS="indexterm"
NAME="ch01-idx-868935-0"
></A
> loop, sorting a list, and getting the keys of an hash.</P
><P
CLASS="para"
>First, the <A
CLASS="indexterm"
NAME="ch01-idx-868936-0"
></A
><CODE
CLASS="literal"
>keys</CODE
> function takes a hash name as an argument and returns a list of all the keys of that hash in some unspecified order. For the <CODE
CLASS="literal"
>%words</CODE
> hash defined earlier, the result is something like <CODE
CLASS="literal"
>fred</CODE
>, <CODE
CLASS="literal"
>barney</CODE
>, <CODE
CLASS="literal"
>betty</CODE
>, <CODE
CLASS="literal"
>wilma</CODE
>, in some unspecified order. For the <CODE
CLASS="literal"
>%last_good</CODE
> hash, the result will be a list of all users who have guessed their own secret word successfully.</P
><P
CLASS="para"
>The <A
CLASS="indexterm"
NAME="ch01-idx-868937-0"
></A
><CODE
CLASS="literal"
>sort</CODE
> function sorts the list alphabetically (just like passing a text file through the <EM
CLASS="emphasis"
>sort</EM
> command). This function makes sure that the list processed by the <CODE
CLASS="literal"
>foreach</CODE
> statement is always in alphabetical order.</P
><P
CLASS="para"
>The Perl <A
CLASS="indexterm"
NAME="ch01-idx-868938-0"
></A
><CODE
CLASS="literal"
>foreach</CODE
> statement takes a list of values and assigns each one in turn to a scalar variable (here, <CODE
CLASS="literal"
>$name</CODE
>), executing the body of the loop (a block) once for each value. So, for five names in the <CODE
CLASS="literal"
>%last_good</CODE
> list, we get five passes through the loop, with <CODE
CLASS="literal"
>$name</CODE
> being a different value each time.</P
><P
CLASS="para"
>The body of the <CODE
CLASS="literal"
>foreach</CODE
> loop loads up a couple of variables used within the <CODE
CLASS="literal"
>STDOUT</CODE
> format, and then invokes the format. Note that we figure out the age of the entry by subtracting the stored system <A
CLASS="indexterm"
NAME="ch01-idx-3759-0"
></A
>time (in the array) from the current time (as returned by <CODE
CLASS="literal"
>time</CODE
>), and then divide that by 3600 (to convert seconds to hours).</P
><P
CLASS="para"
>Perl also provides easy ways to create and maintain text-oriented databases and fixed-length-record databases. These databases are described in <A
CLASS="xref"
HREF="ch17_01.htm"
TITLE="Database Manipulation"
>Chapter 17, <CITE
CLASS="chapter"
>Database Manipulation</CITE
></A
>.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="ch01-pgfId-869201"
>1.6.17 The Final Programs</A
></H3
><P
CLASS="para"
>Here are the programs from this stroll in their final form so that you can play with them.</P
><P
CLASS="para"
>First, the "say hello" program:</P
><PRE
CLASS="programlisting"
>init_words();
print &quot;What is your name? &quot;;
$name = &lt;STDIN&gt;;
chomp ($name);
<A
CLASS="indexterm"
NAME="ch01-idx-868979-0"
></A
>if ($name =~ /^erik\b/i) { # back to the other way :-)
    <A
CLASS="indexterm"
NAME="ch01-idx-868972-0"
></A
>print &quot;Hello, Erik! How good of you to be here!\n&quot;;
} else {
    print &quot;Hello, $name!\n&quot;; # ordinary greeting
    print &quot;What is the secret word? &quot;;
    $guess = <A
CLASS="indexterm"
NAME="ch01-idx-868973-0"
></A
>&lt;STDIN&gt;;
     <A
CLASS="indexterm"
NAME="ch01-idx-868974-0"
></A
>chomp ($guess);
     while (! good_word($name,$guess)) {
        print &quot;Wrong, try again. What is the secret word? &quot;;
        $guess = &lt;STDIN&gt;;
        chomp ($guess);
     }
}
<A
CLASS="indexterm"
NAME="ch01-idx-868975-0"
></A
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                 die &quot;can't dbmopen lastdb: $!&quot;;
$last_good{$name} = time;
<A
CLASS="indexterm"
NAME="ch01-idx-868976-0"
></A
>dbmclose (%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;
<A
CLASS="indexterm"
NAME="ch01-idx-868977-0"
></A
>sub init_words {
    while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
        open (WORDSLIST, $filename) || 
                die &quot;can't open $filename: $!&quot;;
        if (-M WORDSLIST &lt;= 7.0) {
            while (defined ($name = &lt;WORDSLIST&gt;)) {
                chomp ($name);
                $word = &lt;WORDSLIST&gt;;
                chomp ($word);
                $words{$name} = $word;
            }
            close (WORDSLIST) ||
                    die &quot;can't close $filename: $!&quot;;
        }
        else {
            # must close file before renaming it
            close (WORDSLIST) ||
                    die &quot;can't close $filename.old: $!&quot;
            rename ($filename,&quot;$filename.old&quot;) ||
                    die &quot;can't rename $filename: $!&quot;;
        }
    }
}
sub good_word {
  my($somename,$someguess) = @_; # name the parameters
  $somename =~ <A
CLASS="indexterm"
NAME="ch01-idx-868983-0"
></A
>s/\W.*//; # delete everything after first word
  $somename =~ <A
CLASS="indexterm"
NAME="ch01-idx-868984-0"
></A
>tr/A-Z/a-z/; # lowercase everything
  if ($somename <A
CLASS="indexterm"
NAME="ch01-idx-868985-0"
></A
>eq &quot;erik&quot;) { # should not need to guess
    return 1; # <A
CLASS="indexterm"
NAME="ch01-idx-868986-0"
></A
>return value is true
  } elsif (($words{$somename} || &quot;groucho&quot;) eq $someguess) {
    return 1; # return value is true
  } else {
    <A
CLASS="indexterm"
NAME="ch01-idx-868987-0"
></A
>log_failure($somename,$someguess);
    return 0; # return value is false
  }
}

sub log_failure {
    my($somename,$someguess) = @_; # name the parameters
    open(LOG, &quot;&gt;&gt;failures.log&quot;) || die &quot;failures.log: $!&quot;;
    print LOG &quot;bad news: $somename guessed $someguess\n&quot;;
    close (LOG)  || die &quot;can't close failures.log: $!&quot;;
}</PRE
><P
CLASS="para"
>Next, we have the secret word lister:</P
><PRE
CLASS="programlisting"
>while ( defined($filename = glob(&quot;*.sec&quot;)) ) {
    open (WORDSLIST, $filename) || 
               die &quot;can't open $filename: $!&quot;;
    if (-M WORDSLIST &lt;= 7.0) {
        while (defined ($name = &lt;WORDSLIST&gt;)) {
            chomp ($name);
            $word = &lt;WORDSLIST&gt;;
             chomp ($word);
              <A
CLASS="indexterm"
NAME="ch01-idx-4746-0"
></A
>write; # invoke format STDOUT to STDOUT
        }
    }
    close (WORDSLIST) || die &quot;can't close $filename: $!&quot;;
}

<A
CLASS="indexterm"
NAME="ch01-idx-4753-0"
></A
>format STDOUT =
@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
$filename, $name, $word
.
format STDOUT_TOP =
Page @&lt;&lt;
$%

Filename         Name       Word
================ ========== ============
.</PRE
><P
CLASS="para"
>And finally, the last-time-a-word-was-used display program:</P
><PRE
CLASS="programlisting"
><A
CLASS="indexterm"
NAME="ch01-idx-868990-0"
></A
>dbmopen (%last_good,&quot;lastdb&quot;,0666) || 
                 die &quot;can't dbmopen lastdb: $!&quot;;
<A
CLASS="indexterm"
NAME="ch01-idx-868991-0"
></A
>foreach $name (sort keys %last_good) {
    $when = $last_good{$name};
    $hours = (<A
CLASS="indexterm"
NAME="ch01-idx-868992-0"
></A
>time - $when) / 3600; # compute hours ago
    write;
}
dbmclose(%last_good) || die &quot;can't dbmclose lastdb: $!&quot;;
format STDOUT =
User @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;: last correct guess was @&lt;&lt;&lt; hours ago.
$name, $hours
.</PRE
><P
CLASS="para"
>Together with the secret word lists (files named <CODE
CLASS="replaceable"
><I
>something</I
></CODE
><CODE
CLASS="literal"
>.sec</CODE
> in the current directory) and the database, <CODE
CLASS="literal"
>lastdb.dir</CODE
> and <CODE
CLASS="literal"
>lastdb.pag</CODE
>, you'll have all you need.</P
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_05.htm"
TITLE="1.5 Basic Concepts"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 1.5 Basic Concepts"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Learning Perl on Win32 Systems"
><IMG
SRC="../gifs/txthome.gif"
ALT="Learning Perl on Win32 Systems"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="sect1"
HREF="ch01_07.htm"
TITLE="1.7 Exercises"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 1.7 Exercises"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>1.5 Basic Concepts</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>1.7 Exercises</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="../prog/index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
