<HTML
><HEAD
>
<TITLE>[Chapter 2] 2.3 Terms</TITLE>
<META
NAME="DC.title"
CONTENT="Programming Perl"><META
NAME="DC.creator"
CONTENT="Larry Wall, Tom Christiansen &amp; Randal L. Schwartz"><META
NAME="DC.publisher"
CONTENT="O'Reilly &amp; Associates, Inc."><META
NAME="DC.date"
CONTENT="1999-07-02T01:31:27Z"><META
NAME="DC.type"
CONTENT="Text.Monograph"><META
NAME="DC.format"
CONTENT="text/html"
SCHEME="MIME"><META
NAME="DC.source"
CONTENT="1-56592-149-6"
SCHEME="ISBN"><META
NAME="DC.language"
CONTENT="en-US"><META
NAME="generator"
CONTENT="Jade 1.1/O'Reilly DocBook 3.0 to HTML 4.0"><LINK
REV="made"
HREF="mailto:online-books@oreilly.com"
TITLE="Online Books Comments"><LINK
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"><LINK
REL="prev"
HREF="ch02_02.htm"
TITLE="2.2 Built-in Data Types"><LINK
REL="next"
HREF="ch02_04.htm"
TITLE="2.4 Pattern Matching"></HEAD
><BODY
BGCOLOR="#FFFFFF"
TEXT="#000000"
><DIV
CLASS="htmlnav"
><H1
><IMG
SRC="gifs/smbanner.gif"
ALT="Programming Perl"
USEMAP="#srchmap"
BORDER="0"></H1
><MAP
NAME="srchmap"
><AREA
SHAPE="RECT"
COORDS="0,0,466,65"
HREF="index.htm"
ALT="Programming Perl"><AREA
SHAPE="RECT"
COORDS="467,0,514,18"
HREF="../search/psrch.htm"
ALT="Search this book"></MAP
><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_02.htm"
TITLE="2.2 Built-in Data Types"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.2 Built-in Data Types"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><B
><FONT
FACE="ARIEL,HELVETICA,HELV,SANSERIF"
SIZE="-1"
><A
CLASS="chapter"
REL="up"
HREF="ch02_01.htm"
TITLE="2. The Gory Details"
>Chapter 2<BR>The Gory Details</A
></FONT
></B
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_04.htm"
TITLE="2.4 Pattern Matching"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.4 Pattern Matching"
BORDER="0"></A
></TD
></TR
></TABLE
>&nbsp;<HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="sect1"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3"
>2.3 Terms</A
></H2
><P
CLASS="para"
>Now that we've talked about the kinds of data you can represent in Perl,
we'd like to introduce you to the various kinds of terms you can use
to pull that data into expressions.  We'll use the technical term
<EM
CLASS="emphasis"
>term</EM
> when we want to talk in terms of these syntactic units.  (Hmm,
this could get confusing.)  The first terms we'll talk about are
<EM
CLASS="emphasis"
>variables</EM
>.</P
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.1"
>2.3.1 Variables</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.VAR"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2022"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2025"
></A
>There are variable types corresponding to each of the three data types
we mentioned. Each of these is introduced (grammatically speaking) by
what we call a &quot;funny character&quot;. Scalar variables are always named
with an initial <CODE
CLASS="literal"
>$</CODE
>,
even when referring to a scalar that is part of an array or hash.  It works
a bit like the English word &quot;the&quot;. Thus, we have:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Construct</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$days</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Simple scalar value <CODE
CLASS="literal"
>$days</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$days[28]</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>29th element of array <CODE
CLASS="literal"
>@days</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$days{'Feb'}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>&quot;<CODE
CLASS="literal"
>Feb</CODE
>&quot; value from hash <CODE
CLASS="literal"
>%days</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$#days</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Last index of array <CODE
CLASS="literal"
>@days</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>$days-&gt;[28]</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>29th element of array pointed to by reference <CODE
CLASS="literal"
>$days</CODE
></P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2065"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2068"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2071"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2074"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2077"
></A
>Entire arrays or array slices (and also slices of hashes) are named with
<CODE
CLASS="literal"
>@</CODE
>, which works much like the words &quot;these&quot; or &quot;those&quot;:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Construct</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@days</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Same as <CODE
CLASS="literal"
>($days[0], $days[1],... $days[n])</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@days[3, 4, 5]</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Same as <CODE
CLASS="literal"
>($days[3], $days[4], $days[5])</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@days[3..5]</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Same as <CODE
CLASS="literal"
>($days[3], $days[4], $days[5])</CODE
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>@days{'Jan','Feb'}</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Same as <CODE
CLASS="literal"
>($days{'Jan'},$days{'Feb'})</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2109"
></A
>Entire hashes are named by <CODE
CLASS="literal"
>%</CODE
>:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Construct</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>%days</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>(Jan =&gt; 31, Feb =&gt; $leap ? 29 : 28, ...)</CODE
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2126"
></A
>Any of these nine constructs may serve as an <EM
CLASS="emphasis"
>lvalue</EM
>,
that is, they specify a location that you could assign a value to,
among other things.[<A
CLASS="footnote"
HREF="#AUTOID-2129"
>2</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2129"
>[2]</A
>  Assignment itself is an <EM
CLASS="emphasis"
>lvalue</EM
>
in certain contexts&nbsp;- see examples under <B
CLASS="emphasis.bold"
>s///</B
>, <A
CLASS="xref"
HREF="ch03_175.htm"
TITLE="tr///"
><B
CLASS="xref.cmd"
>tr///</B
></A
>,
<B
CLASS="emphasis.bold"
>chop</B
>, and <B
CLASS="emphasis.bold"
>chomp</B
> in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.  </P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2138"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2141"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2144"
></A
>In addition, subroutine calls are named with an initial <CODE
CLASS="literal"
>&amp;</CODE
>,
although this is optional when it's otherwise unambiguous (just as &quot;do&quot; is
often redundant in English).  Symbol table entries can be named with an
initial <CODE
CLASS="literal"
>*</CODE
>, but you don't really care about that yet.</P
><P
CLASS="para"
>Every variable type has its own namespace.  You can, without fear of
conflict, use the same name for a scalar variable, an array, or a hash
(or, for that matter, a filehandle, a subroutine name, a label, or your
pet llama).  This means that <CODE
CLASS="literal"
>$foo</CODE
> and <CODE
CLASS="literal"
>@foo</CODE
> are two
different variables.  It also means that <CODE
CLASS="literal"
>$foo[1]</CODE
> is an element
of <CODE
CLASS="literal"
>@foo</CODE
>, not a part of <CODE
CLASS="literal"
>$foo</CODE
>.  This may seem a bit weird,
but that's okay, because it is weird.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2156"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2159"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2162"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2165"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2167"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2170"
></A
>Since variable names always start with <CODE
CLASS="literal"
>$</CODE
>, <CODE
CLASS="literal"
>@</CODE
>, or
<CODE
CLASS="literal"
>%</CODE
>, the reserved words can't conflict with variable names.  But
they can conflict with nonvariable identifiers, such as labels and
filehandles, which don't have an
initial funny character.  Since reserved words are always entirely
lowercase, we recommend that you pick label and filehandle names that do not
appear all in lowercase.  For example, you could say
<CODE
CLASS="literal"
>open(LOG,'logfile')</CODE
> rather
than the regrettable <CODE
CLASS="literal"
>open(log,'logfile')</CODE
>.[<A
CLASS="footnote"
HREF="#AUTOID-2177"
>3</A
>]
Using uppercase filehandles also improves readability and protects you from
conflict with future reserved words.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2177"
>[3]</A
> Regrettable because <CODE
CLASS="literal"
>log</CODE
> is a predefined function returning 
the base <EM
CLASS="emphasis"
>e</EM
> logarithm of its argument, or of <CODE
CLASS="literal"
>$_</CODE
> if 
its argument is missing, as it is in this case.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2183"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2185"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2188"
></A
>Case <EM
CLASS="emphasis"
>is</EM
> significant&nbsp;- <CODE
CLASS="literal"
>FOO</CODE
>,
<CODE
CLASS="literal"
>Foo</CODE
> and <CODE
CLASS="literal"
>foo</CODE
> are all different
names.  Names that start with a letter or underscore may be of any
length (well, 255 characters, at least) and may contain letters, digits, and
underscores.  Names that start with a digit may only contain more
digits.  Names that start with anything else are limited to that one
character (like <B
CLASS="emphasis.bold"
>$?</B
> or <B
CLASS="emphasis.bold"
>$$</B
>), and generally have a predefined significance
to Perl.  For example, just as in the Bourne shell, <B
CLASS="emphasis.bold"
>$$</B
> is the current process ID and <B
CLASS="emphasis.bold"
>$?</B
> the exit status of your last child process.</P
><P
CLASS="para"
>Sometimes you want to name something indirectly.  It is possible to
replace an alphanumeric name with an expression that returns a reference
to the actual variable (see <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4, <CITE
CLASS="chapter"
>References and Nested Data Structures</CITE
></A
>).<A
CLASS="indexterm"
NAME="AUTOID-2201"
></A
></P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2"
>2.3.2 Scalar Values</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.SCALAR"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2207"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2211"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2215"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2219"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2223"
></A
>Whether it's named directly or indirectly, or is just a temporary value
on a stack, a scalar always contains a single value.  This value may be
a number,[<A
CLASS="footnote"
HREF="#AUTOID-2225"
>4</A
>]
a string,[<A
CLASS="footnote"
HREF="#AUTOID-2228"
>5</A
>]
or a reference to another piece of data.  (Or there may be no value at
all, in which case the scalar is said to be <EM
CLASS="emphasis"
>undefined</EM
>.) While we might
speak of a scalar as &quot;containing&quot; a number or a string, scalars are
essentially typeless; there's no way to declare a scalar to be of type
&quot;number&quot; or &quot;string&quot;.  Perl converts between the various subtypes as
needed, so you can treat a number as a string or a string as a number,
and Perl will do the Right Thing.[<A
CLASS="footnote"
HREF="#AUTOID-2231"
>6</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2225"
>[4]</A
> Perl stores numbers as signed integers if possible, or as double-precision
floating-point values in the machine's native format otherwise.
Floating-point values are not infinitely precise.  This is very
important to remember, since comparisons like <CODE
CLASS="literal"
>(10/3 == 1/3*10)</CODE
> tend to
fail mysteriously.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2228"
>[5]</A
> Perl stores strings as sequences of bytes, with no arbitrary constraints
on length or content.  In human terms, you don't have to decide in
advance how long your strings are going to get, and you can include any
characters including null characters within your string.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2231"
>[6]</A
> To convert from string to number, Perl uses C's <EM
CLASS="emphasis"
>atof</EM
>(3) function.  To
convert from number to string, it does the equivalent of an
<EM
CLASS="emphasis"
>sprintf</EM
>(3) with a format of <CODE
CLASS="literal"
>&quot;%.14g&quot;</CODE
> on most machines.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>While strings and numbers are interchangeable for nearly all intents and 
purposes, references are a bit different.  They're strongly typed,
uncastable[<A
CLASS="footnote"
HREF="#AUTOID-2237"
>7</A
>]
pointers with built-in reference-counting and destructor invocation.
You can use them to create complex data types, including user-defined
objects.  But they're still scalars, for all that.  See <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
> for
more on references.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2237"
>[7]</A
> By which we mean that you can't, for instance, convert a reference to an
array into a reference to a hash.  References are not castable to other
pointer types.  However, if you use a reference as a number or a string,
you will get a numeric or string value, which is guaranteed to retain the
uniqueness of the reference even though the &quot;referenceness&quot; of the value
is lost when the value is copied from the real reference.  You can compare
such values or test whether they are defined.  But you can't do much else with
the values, since there's no way to convert numbers or strings into
references.  In general this is not a problem, since Perl doesn't force you
to do pointer arithmetic&nbsp;- or even allow it.</P
></DIV
></BLOCKQUOTE
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.1"
>2.3.2.1 Numeric literals</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2243"
></A
>Numeric literals are specified in any of several customary[<A
CLASS="footnote"
HREF="#AUTOID-2245"
>8</A
>]
floating point or integer formats:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2245"
>[8]</A
> Customary in UNIX culture, that is.  If you're from a different culture,
welcome to ours!</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>12345               # integer
12345.67            # floating point
6.02E23             # scientific notation
0xffff              # hexadecimal
0377                # octal
4_294_967_296       # underline for legibility</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2250"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2253"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2256"
></A
>Since Perl uses the comma as a list separator, you cannot use it to delimit
the triples in a large number.  To improve legibility, Perl does allow you
to use an underscore character instead.  The underscore only
works within literal numbers specified in your program, not for strings
functioning as numbers or data read from somewhere else.  Similarly, the
leading <CODE
CLASS="literal"
>0x</CODE
> for hex and <CODE
CLASS="literal"
>0</CODE
> for octal work only for literals.
The automatic conversion of a string to a number does not recognize these
prefixes&nbsp;- you must do an explicit conversion[<A
CLASS="footnote"
HREF="#AUTOID-2261"
>9</A
>]
with the <A
CLASS="xref"
HREF="ch03_101.htm"
TITLE="oct"
><B
CLASS="xref.cmd"
>oct</B
></A
> function (which works for hex-looking data, too, as it
happens).</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2261"
>[9]</A
> Sometimes people think Perl should convert all incoming data for them.  But
there are far too many decimal numbers with leading zeroes in the world
to make Perl do this automatically.  For example, the zip code for O'Reilly
&amp; Associates' office in Cambridge, MA is <CODE
CLASS="literal"
>02140</CODE
>.  The postmaster would
get upset if your mailing label program turned <CODE
CLASS="literal"
>02140</CODE
> into <CODE
CLASS="literal"
>1120</CODE
>
decimal.</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.2"
>2.3.2.2 String literals</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.STRING"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2272"
></A
>String literals are usually delimited by either single or double quotes.
They work much like UNIX shell quotes: double-quoted string literals
are subject to backslash and variable interpolation; single-quoted
strings are not (except for <CODE
CLASS="literal"
>\'</CODE
> and <CODE
CLASS="literal"
>\\</CODE
>, so that you
can put single quotes and backslashes into single-quoted strings).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2278"
></A
>You can also embed newlines directly in your strings; that is, they can
begin and end on different lines.  This is nice for many reasons,
but it also means that if you forget a trailing quote, the error will
not be reported until Perl finds another line containing the quote
character, which may be much further on in the script.  Fortunately,
this usually causes an immediate syntax error on the same line, and Perl
is then smart enough to warn you that you might have a runaway string.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2282"
></A
>Note that a single-quoted string must be separated from a preceding word by
a space, since a single quote is a valid (though deprecated) character in
an identifier; see <A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Packages, Modules, and Object Classes"
>Chapter 5</A
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2287"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2289"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2291"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2293"
></A
>With double-quoted strings, the usual C-style backslash rules apply for
inserting characters such as newline, tab, and so on.  You may also specify
characters in octal and hexadecimal, or as control characters:<A
CLASS="indexterm"
NAME="AUTOID-2295"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2297"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2299"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2301"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2303"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2307"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2311"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2315"
></A
></P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Code</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\n</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Newline</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\r</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Carriage return</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\t</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Horizontal tab</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Form feed</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\b</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Backspace</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\a</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Alert (bell)</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\e</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ESC character</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\033</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>ESC in octal</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\x7f</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>DEL in hexadecimal</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\cC</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Control-C</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2367"
></A
>In addition, there are escape sequences to modify the case of subsequent
characters, as with the substitution operator in the <EM
CLASS="emphasis"
>vi</EM
> editor:</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Code</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\u</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force next character to uppercase.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\l</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force next character to lowercase.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\U</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force all following characters to uppercase.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\L</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Force all following characters to lowercase.</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\Q</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>Backslash all following non-alphanumeric characters.</P
></TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>\E</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><P
CLASS="para"
>End <CODE
CLASS="literal"
>\U</CODE
>, <CODE
CLASS="literal"
>\L</CODE
>, or <CODE
CLASS="literal"
>\Q</CODE
>.</P
></TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2410"
></A
>Besides the backslash escapes listed above, double-quoted strings are
subject to <EM
CLASS="emphasis"
>variable interpolation</EM
> of scalar and list values.  
This means that you can insert the values of certain variables directly
into a string literal.  It's really just a handy form of string
concatenation.

Variable interpolation may only be done for scalar variables, entire arrays (but not
hashes), single elements from an array or hash, or slices (multiple
subscripts) of an array or hash.  In other words, you may only interpolate
expressions that begin with <CODE
CLASS="literal"
>$</CODE
> or <CODE
CLASS="literal"
>@</CODE
>, because those are the
two characters (along with backslash) that the string parser looks for.[<A
CLASS="footnote"
HREF="#AUTOID-2415"
>10</A
>]
Although a complete hash specified with a <CODE
CLASS="literal"
>%</CODE
> may not be interpolated
into the string, single hash values and hash slices are okay, because they
begin with <CODE
CLASS="literal"
>$</CODE
> and <CODE
CLASS="literal"
>@</CODE
> respectively.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2415"
>[10]</A
> Inside strings a literal <CODE
CLASS="literal"
>@</CODE
> that is not part of an array or slice
identifier must be escaped with a backslash (<CODE
CLASS="literal"
>\@</CODE
>), or else a
compilation error
will result.  See <A
CLASS="xref"
HREF="ch09_01.htm"
TITLE="Diagnostic Messages"
>Chapter 9, <CITE
CLASS="chapter"
>Diagnostic Messages</CITE
></A
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>The following code segment prints out: &quot;<CODE
CLASS="literal"
>The price is $100.</CODE
>&quot;</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$Price = '$100';                    # not interpolated
print &quot;The price is $Price.\n&quot;;     # interpolated</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2428"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2431"
></A
>As in some shells, you can put braces around the identifier to
distinguish it from following alphanumerics: <CODE
CLASS="literal"
>&quot;How ${verb}able!&quot;</CODE
>.
In fact, an identifier within such braces is
forced to be a string, as is any single identifier within a hash subscript.
For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$days{'Feb'}</PRE
></P
><P
CLASS="para"
>can be written as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$days{Feb}</PRE
></P
><P
CLASS="para"
>and the quotes will be assumed automatically.  But anything more complicated
in the subscript will be interpreted as an expression.</P
><P
CLASS="para"
>Apart from the subscripts of interpolated array and hash variables,
there are no multiple levels of interpolation.  In particular, contrary
to the expectations of shell programmers, backquotes do not
interpolate within double quotes, nor do single quotes impede evaluation
of variables when used within double quotes.<A
CLASS="indexterm"
NAME="AUTOID-2442"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.3"
>2.3.2.3 Pick your own quotes</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.QUOTE"
></A
>While we usually think of quotes as literal values, in Perl they
function more like operators, providing various kinds of interpolating
and pattern matching capabilities.  Perl provides the customary quote
characters for these behaviors, but also provides a way for you to
choose your quote character for any of them.</P
><TABLE
CLASS="informaltable"
BORDER="1"
CELLPADDING="3"
><THEAD
CLASS="thead"
><TR
CLASS="row"
VALIGN="TOP"
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Customary</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Generic</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Meaning</TH
><TH
CLASS="entry"
ALIGN="LEFT"
ROWSPAN="1"
COLSPAN="1"
>Interpolates</TH
></TR
></THEAD
><TBODY
CLASS="tbody"
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>''</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>q//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Literal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>No</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>&quot;&quot;</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>qq//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Literal</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>``</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>qx//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Command</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>()</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>qw//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Word list</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>No</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>m//</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Pattern match</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>s///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Substitution</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Yes</TD
></TR
><TR
CLASS="row"
VALIGN="TOP"
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>y///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
><CODE
CLASS="literal"
>tr///</CODE
></TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>Translation</TD
><TD
CLASS="entry"
ROWSPAN="1"
COLSPAN="1"
>No</TD
></TR
></TBODY
></TABLE
><P
CLASS="para"
>Some of these are simply forms of &quot;syntactic sugar&quot; to let you avoid
putting too many backslashes into quoted strings.  Any non-alphanumeric,
non-whitespace delimiter can be used in place of <CODE
CLASS="literal"
>/</CODE
>.[<A
CLASS="footnote"
HREF="#AUTOID-2508"
>11</A
>]
If the delimiters are single quotes, no variable interpolation is done
on the pattern. If the opening delimiter is a parenthesis, bracket, brace, or angle
bracket, the closing delimiter will be the matching construct.
(Embedded occurrences of the delimiters must match in pairs.)
Examples:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2508"
>[11]</A
> In particular, the newline and space characters are not allowed as
delimiters.  (Ancient versions of Perl allowed this.)</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$single = q!I said, &quot;You said, 'She said it.'&quot;!;
$double = qq(Can't we get some &quot;good&quot; $variable?);
$chunk_of_code = q {
    if ($condition) {
        print &quot;Gotcha!&quot;;
    }
};</PRE
></P
><P
CLASS="para"
>Finally, for two-string constructs like <CODE
CLASS="literal"
>s///</CODE
> and <CODE
CLASS="literal"
>tr///</CODE
>, if the
first pair of quotes is a bracketing pair, then the second part gets its
own starting quote character, which needn't be the same as the first
pair.  So you can write things like <CODE
CLASS="literal"
>s{foo}(bar)</CODE
> or <CODE
CLASS="literal"
>tr[a-z][A-Z]</CODE
>.
Whitespace is allowed between the two inner quote characters, so you
could even write that last one as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>tr [a-z]
   [A-Z];</PRE
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.4"
>2.3.2.4 Or leave the quotes out entirely</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2522"
></A
>A word that has no other interpretation in the grammar will be treated as
if it were a quoted string.  These are known as <EM
CLASS="emphasis"
>barewords</EM
>.[<A
CLASS="footnote"
HREF="#AUTOID-2525"
>12</A
>]
For example:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2525"
>[12]</A
> As with filehandles and labels, a bareword that consists entirely of
lowercase letters risks conflict with future reserved words.  If you use
the <B
CLASS="emphasis.bold"
>-w</B
> switch, Perl will warn you about barewords.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@days = (Mon,Tue,Wed,Thu,Fri);
print STDOUT hello, ' ', world, &quot;\n&quot;;</PRE
></P
><P
CLASS="para"
>sets the array <CODE
CLASS="literal"
>@days</CODE
> to the short form of the weekdays and prints
<CODE
CLASS="literal"
>hello world</CODE
> followed by a newline on <CODE
CLASS="literal"
>STDOUT</CODE
>.  If you leave the
filehandle out, Perl tries to interpret <CODE
CLASS="literal"
>hello</CODE
> as a filehandle,
resulting in a syntax error.  Because this is so error-prone, some people
may wish to outlaw barewords entirely.  If you say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>use strict 'subs';</PRE
></P
><P
CLASS="para"
>then any bareword that would not be interpreted as a subroutine call
produces a compile-time error instead.  The restriction lasts to the
end of the enclosing block.  An inner block may countermand this 
by saying:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>no strict 'subs';</PRE
></P
><P
CLASS="para"
>Note that the bare identifiers in constructs like:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>&quot;${verb}able&quot;
$days{Feb}</PRE
></P
><P
CLASS="para"
>are not considered barewords, since they're allowed by explicit rule
rather than by having &quot;no other interpretation in the grammar&quot;.<A
CLASS="indexterm"
NAME="AUTOID-2544"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.5"
>2.3.2.5 Interpolating array values</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2548"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2552"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2555"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2558"
></A
>Array variables are interpolated into double-quoted strings by joining all
the elements of the array with the delimiter specified in the
<B
CLASS="emphasis.bold"
>$&quot;</B
> variable[<A
CLASS="footnote"
HREF="#AUTOID-2562"
>13</A
>]
(which is a space by default).  The following are equivalent:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2562"
>[13]</A
> <CODE
CLASS="literal"
>$LIST_SEPARATOR</CODE
> if you use the English library module.
See <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7, <CITE
CLASS="chapter"
>The Standard Perl Library</CITE
></A
>.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$temp = join($&quot;,@ARGV);
print $temp;

print &quot;@ARGV&quot;;</PRE
></P
><P
CLASS="para"
>Within search patterns (which also undergo double-quotish interpolation)
there is a bad ambiguity:  Is <CODE
CLASS="literal"
>/$foo[bar]/</CODE
> to be interpreted as
<CODE
CLASS="literal"
>/${foo}[bar]/</CODE
> (where <CODE
CLASS="literal"
>[bar]</CODE
> is a character class for the regular
expression) or as <CODE
CLASS="literal"
>/${foo[bar]}/</CODE
> (where <CODE
CLASS="literal"
>[bar]</CODE
> is the
subscript to array <CODE
CLASS="literal"
>@foo</CODE
>)?  If <CODE
CLASS="literal"
>@foo</CODE
> doesn't otherwise exist,
then it's obviously a character class.  If <CODE
CLASS="literal"
>@foo</CODE
> exists, Perl takes
a good guess about <CODE
CLASS="literal"
>[bar]</CODE
>, and is almost always right.[<A
CLASS="footnote"
HREF="#AUTOID-2578"
>14</A
>]
If it does guess wrong, or if you're just plain paranoid, you can force the
correct interpretation with braces as above.  Even if you're merely
prudent, it's probably not a bad idea.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2578"
>[14]</A
> The guesser is too boring to describe in full, but basically takes a
weighted average of all the things that look like character classes
(<CODE
CLASS="literal"
>a-z, \w,</CODE
> initial <CODE
CLASS="literal"
>^</CODE
>) versus things that look like expressions
(variables or reserved words).</P
></DIV
></BLOCKQUOTE
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.6"
>2.3.2.6 &quot;Here&quot; documents</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2585"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2587"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2589"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2592"
></A
>A line-oriented form of quoting is based on the shell's <EM
CLASS="emphasis"
>here-document</EM
>
syntax.[<A
CLASS="footnote"
HREF="#AUTOID-2595"
>15</A
>]
Following a <CODE
CLASS="literal"
>&lt;&lt;</CODE
> you specify a string to terminate the
quoted material, and all lines following the current line down to the
terminating string are quoted.  The terminating string
may be either an identifier (a word), or some quoted text.  If quoted,
the type of quote you use determines the treatment of the text, just as
in regular quoting.  An unquoted identifier works like double quotes.
There must be no space between the <CODE
CLASS="literal"
>&lt;&lt;</CODE
> and the identifier.  (If
you insert a space, it will be treated as a null identifier, which is valid
but deprecated, and matches the first blank line&nbsp;- see the first <CODE
CLASS="literal"
>Hurrah!</CODE
>
example below.)  The terminating string must appear by itself (unquoted
and with no surrounding whitespace) on the terminating line.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2595"
>[15]</A
> It's line-oriented in the sense that delimiters are lines rather than
characters.  The starting delimiter is the current line, and the terminating
delimiter is a line consisting of the string you specify.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>    print &lt;&lt;EOF;    # same as earlier example    
The price is $Price.
EOF

    print &lt;&lt;&quot;EOF&quot;;  # same as above, with explicit quotes
The price is $Price.
EOF

    print &lt;&lt;'EOF';    # single-quoted quote
All things (e.g. a camel's journey through
A needle's eye) are possible, it's true.
But picture how the camel feels, squeezed out
In one long bloody thread, from tail to snout.
                                -- C.S. Lewis
EOF

    print &lt;&lt; x 10;    # print next line 10 times
The camels are coming!  Hurrah!  Hurrah!

    print &lt;&lt;&quot;&quot; x 10;  # the preferred way to write that
The camels are coming!  Hurrah!  Hurrah!

    print &lt;&lt;`EOC`;    # execute commands
echo hi there
echo lo there
EOC

    print &lt;&lt;&quot;dromedary&quot;, &lt;&lt;&quot;camelid&quot;; # you can stack them
I said bactrian.
dromedary
She said llama.
camelid</PRE
></P
><P
CLASS="para"
>Just don't forget that you have to put a semicolon on the end 
to finish the statement, as Perl doesn't know you're not going to 
try to do this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>print &lt;&lt;ABC
179231
ABC
    + 20;   # prints 179251</PRE
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.2.7"
>2.3.2.7 Other literal tokens</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2608"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2610"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2613"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2615"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2618"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2620"
></A
>Two special literals are __<CODE
CLASS="literal"
>LINE</CODE
>__ and __<CODE
CLASS="literal"
>FILE</CODE
>__, which represent
the current line number and filename at that point in your program.
They may only be used as separate tokens; they will not be interpolated
into strings.  In addition, the token __<CODE
CLASS="literal"
>END</CODE
>__ may be used to indicate
the logical end of the script before the actual end of file.  Any
following text is ignored, but may be read via the <CODE
CLASS="literal"
>DATA</CODE
> filehandle.<A
CLASS="indexterm"
NAME="AUTOID-2626"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2628"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2630"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2632"
></A
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2636"
></A
>The __<CODE
CLASS="literal"
>DATA</CODE
>__ token functions similarly to the __<CODE
CLASS="literal"
>END</CODE
>__ token, but
opens the <CODE
CLASS="literal"
>DATA</CODE
> filehandle within the current package's namespace, so that
<A
CLASS="xref"
HREF="ch03_123.htm"
TITLE="require"
><B
CLASS="xref.cmd"
>require</B
></A
>d files can each have their own <CODE
CLASS="literal"
>DATA</CODE
> filehandles open
simultaneously.  For more information, see <A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Packages, Modules, and Object Classes"
>Chapter 5</A
>.<A
CLASS="indexterm"
NAME="AUTOID-2644"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.3"
>2.3.3 Context</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.CON"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2650"
></A
>Until now we've seen a number of terms that can produce scalar values.
Before we can discuss terms further, though, we must come to terms
with the notion of <EM
CLASS="emphasis"
>context</EM
>.</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.3.1"
>2.3.3.1 Scalar and list context</A
></H4
><P
CLASS="para"
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.LCON"
></A
><A
CLASS="indexterm"
NAME="CH02.SCON"
></A
>Every operation[<A
CLASS="footnote"
HREF="#AUTOID-2662"
>16</A
>]
that you invoke in a Perl script is evaluated in a
specific context, and how that operation behaves may depend on
the requirements of that context.  There are two major contexts:
<EM
CLASS="emphasis"
>scalar</EM
> and <EM
CLASS="emphasis"
>list</EM
>.  For example, assignment to a scalar variable
evaluates the right-hand side in a scalar context, while assignment to an
array or a hash (or slice of either) evaluates the right-hand side in a
list context.  Assignment to a list of scalars would also provide a list
context to the right-hand side.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2662"
>[16]</A
> Here we use the term &quot;operation&quot; loosely to mean either an operator or a term.
The two concepts fuzz into each other when you start talking about
functions that parse like terms but look like unary operators.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>You will be miserable until you learn the difference between scalar and
list context, because certain operators know which context they are in,
and return lists in contexts wanting a list, and scalar values in
contexts wanting a scalar.  (If this is true of an operation, it will be
mentioned in the documentation for that operation.)  In computer lingo,
the functions are <EM
CLASS="emphasis"
>overloaded</EM
> on the type of their return value.  But
it's a very simple kind of overloading, based only on the
distinction between singular and plural values, and nothing else.<A
CLASS="indexterm"
NAME="AUTOID-2668"
></A
></P
><P
CLASS="para"
>Other operations <EM
CLASS="emphasis"
>supply</EM
> the list contexts to their operands, and you
can tell which ones they are because they all have <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> in their
syntactic descriptions.  Generally it's quite intuitive.[<A
CLASS="footnote"
HREF="#AUTOID-2674"
>17</A
>]
If necessary, you can force a scalar context in the middle of a <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> by
using the <A
CLASS="xref"
HREF="ch03_131.htm"
TITLE="scalar"
><B
CLASS="xref.cmd"
>scalar</B
></A
> function.  (Perl provides no way to force a list
context in a scalar context, because anywhere you would want a list
context it's already provided by the <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> of some controlling function.)</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2674"
>[17]</A
> Note, however, that the list context of a 
<CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> can propagate down through subroutine calls, so it's not always obvious by inspection whether a
given simple statement is going to be evaluated in a scalar or list
context.  The program can find out its context within a subroutine by
using the <A
CLASS="xref"
HREF="ch03_191.htm"
TITLE="wantarray"
><B
CLASS="xref.cmd"
>wantarray</B
></A
> function.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
>Scalar context can be further classified into string context, numeric
context, and don't-care context.  Unlike the scalar versus list
distinction we just made, operations never know which scalar context
they're in.  They simply return whatever kind of scalar value they want to,
and let Perl translate numbers to strings in string context, and strings to
numbers in numeric context.
Some scalar contexts don't care whether a string or number is returned,
so no conversion will happen.  (This happens, for example, when you are
assigning the value to another variable.  The new variable just takes
on the same subtype as the old value.)</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.3.2"
>2.3.3.2 Boolean context</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2685"
></A
>One special scalar context is called <EM
CLASS="emphasis"
>Boolean context</EM
>.  Boolean context is
simply any place where an expression is being evaluated to see whether it's
true or false.  We sometimes write true and false when we mean
the technical definition that Perl uses: a scalar value is
true if it is not the null string or the number 0 (or its string
equivalent, <CODE
CLASS="literal"
>&quot;0&quot;</CODE
>).  References are always true.</P
><P
CLASS="para"
>A Boolean context is a don't-care context in the sense that it never
causes any conversions to happen (at least, no conversions beyond what
scalar context would impose).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2692"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2695"
></A
>We said that a null string is false, but there are actually
two varieties of null scalars: defined and undefined.
Boolean context doesn't distinguish between defined and undefined
scalars.  Undefined null scalars are returned when there is no real
value for something, such as when there was an error, or at end of
file, or when you refer to an uninitialized variable or element of an
array.  An undefined null scalar may become defined the first time you
use it as if it were defined, but prior to that you can use the
<A
CLASS="xref"
HREF="ch03_025.htm"
TITLE="defined"
><B
CLASS="xref.cmd"
>defined</B
></A
> operator to determine whether the value is defined or not.
(The return value of <A
CLASS="xref"
HREF="ch03_025.htm"
TITLE="defined"
><B
CLASS="xref.cmd"
>defined</B
></A
> is always defined, but not always true.)</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.3.3"
>2.3.3.3 Void context</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2703"
></A
>Another peculiar kind of scalar context is the <EM
CLASS="emphasis"
>void</EM
> context.  This
context not only doesn't care what the return value is, it doesn't even
<EM
CLASS="emphasis"
>want</EM
> a return value.  From the standpoint of how functions work, it's
no different from an ordinary scalar context.  But if you use the <B
CLASS="emphasis.bold"
>-w</B
>
command-line switch, the Perl compiler will warn you if you use an
expression with no side effects in a place that doesn't want a value,
such as in a statement that doesn't return a value.  For example, if you
use a string as a statement:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>&quot;Camel Lot&quot;;</PRE
></P
><P
CLASS="para"
>you may get a warning like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>Useless use of a constant in void context in myprog line 123;</PRE
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.3.4"
>2.3.3.4 Interpolative context</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2716"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2718"
></A
>We mentioned that double-quoted literal strings do backslash
interpretation and variable interpolation, but the interpolative context
(often called &quot;double-quote context&quot;) applies to more than just
double-quoted strings.  Some other double-quotish constructs are the
generalized backtick operator <CODE
CLASS="literal"
>qx//</CODE
>, the pattern match operator
<CODE
CLASS="literal"
>m//</CODE
>, and the substitution operator <CODE
CLASS="literal"
>s///</CODE
>.  In fact, the
substitution operator does interpolation on its left side before doing a
pattern match, and then does interpolation on its right side each time
the left side matches.<A
CLASS="indexterm"
NAME="AUTOID-2723"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2725"
></A
></P
><P
CLASS="para"
>The interpolative context only happens inside quotes, or things that
work like quotes, so perhaps it's not fair to call it a context in
the same sense as scalar and list context.  (Then again, maybe it is.)<A
CLASS="indexterm"
NAME="AUTOID-2728"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2729"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2730"
></A
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.4"
>2.3.4 List Values and Arrays</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2734"
></A
><A
CLASS="indexterm"
NAME="CH02.LISTS"
></A
><A
CLASS="indexterm"
NAME="CH02.LVAL"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2742"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2745"
></A
><A
CLASS="indexterm"
NAME="CH02.ARRAY"
></A
>Now that we've talked about context, we can talk about list values, and
how they behave in context.
List values are denoted by separating individual values by commas
(and enclosing the list in parentheses where precedence requires it):</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(<CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>)</PRE
></P
><P
CLASS="para"
>In a list context, the value of the list literal is all the values of
the list in order.  In a scalar context, the value of a list literal is
the value of the final element, as with the C comma operator, which
always throws away the value on the left and returns the value on the
right.  (In terms of what we discussed earlier, the left side of the
comma operator provides a void context.)  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@stuff = (&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</PRE
></P
><P
CLASS="para"
>assigns the entire list value to array <CODE
CLASS="literal"
>@stuff</CODE
>, but:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$stuff = (&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</PRE
></P
><P
CLASS="para"
>assigns only the value <CODE
CLASS="literal"
>three</CODE
> to variable <CODE
CLASS="literal"
>$stuff</CODE
>.  The comma operator
knows whether it is in a scalar or a list context.  An actual
array variable also knows its context.  In a list context, it
would return its entire contents, but in a scalar context it returns only
the length of the array (which works out nicely if you mention the
array in a conditional).  The following assigns to <CODE
CLASS="literal"
>$stuff</CODE
> the value 3:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@stuff = (&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);
$stuff = @stuff;      # $stuff gets 3, not &quot;three&quot;</PRE
></P
><P
CLASS="para"
>Until now we've pretended that <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>s are just lists of literals.
But in fact, any expressions that return values may be used within
lists.  The values so used may either be scalar values or list values.
<CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>s do automatic interpolation of sublists.
That is, when a <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> is
evaluated, each element of the list is evaluated in a list context, and
the resulting list value is interpolated into <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
> just as if each
individual element were a member of <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>.  Thus arrays lose their
identity in a <CODE
CLASS="replaceable"
><I
>LIST</I
></CODE
>.  The list:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>(@foo,@bar,&amp;SomeSub)</PRE
></P
><P
CLASS="para"
>contains all the elements of <CODE
CLASS="literal"
>@foo</CODE
>, followed by all the elements of
<CODE
CLASS="literal"
>@bar</CODE
>, followed by all the elements returned by the subroutine named
<CODE
CLASS="literal"
>SomeSub</CODE
> when it's called in a list context.  You can use a reference
to an array if you do not want it to interpolate.  See <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
>, yet again.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2782"
></A
>The null list is represented by <CODE
CLASS="literal"
>()</CODE
>.  Interpolating it in a list has
no effect.  Thus, <CODE
CLASS="literal"
>((),(),())</CODE
> is equivalent to <CODE
CLASS="literal"
>()</CODE
>.  Similarly, interpolating
an array with no elements is the same as if no array had been interpolated
at that point.</P
><P
CLASS="para"
>You may place an optional comma at the end of any list value.
This makes it easy to come back later and add more elements.</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@numbers = (
    1,
    2,
    3,
);</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2792"
></A
>Another way to specify a literal list is with the <B
CLASS="emphasis.bold"
>qw</B
> (quote words)
syntax we mentioned earlier.  This construct is equivalent to splitting
a single-quoted string on whitespace.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@foo = qw(
    apple       banana      carambola
    coconut     guava       kumquat
    mandarin    nectarine   peach
    pear        persimmon   plum
);</PRE
></P
><P
CLASS="para"
>(Note that those parentheses are behaving as quote characters, not
ordinary parentheses.  We could just as easily have picked angle
brackets or braces or slashes.)</P
><P
CLASS="para"
>A list value may also be subscripted like a normal array.  You must put the
list in parentheses (real ones) to avoid ambiguity.  Examples:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
># Stat returns list value.
$modification_time = (stat($file))[9];

# SYNTAX ERROR HERE.
$modification_time = stat($file)[9];  # OOPS, FORGOT PARENS

# Find a hex digit.
$hexdigit = ('a','b','c','d','e','f')[$digit-10];

# A &quot;reverse comma operator&quot;.
return (pop(@foo),pop(@foo))[0];</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2802"
></A
>Lists may be assigned to if and only if each element of the list
is legal to assign to:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($a, $b, $c) = (1, 2, 3);

($map{red}, $map{green}, $map{blue}) = (0x00f, 0x0f0, 0xf00);</PRE
></P
><P
CLASS="para"
>List assignment in a scalar context returns the number of elements
produced by the expression on the right side of the assignment:</P
><PRE
CLASS="programlisting"
>$x = ( ($foo,$bar) = (7,7,7) );       # set $x to 3, not 2
$x = ( ($foo,$bar) = f() );           # set $x to f()'s return count</PRE
><P
CLASS="para"
>This is handy when you want to do a list assignment in a Boolean
context, since most list functions return a null list when finished, which
when assigned produces a 0, which is interpreted as false. The final list element may be an array or a hash:</P
><PRE
CLASS="programlisting"
>($a, $b, @rest) = split;
my ($a, $b, %rest) = @arg_list;</PRE
><P
CLASS="para"
>You can actually put an array or hash anywhere in the list you assign
to, but the first one in the list will soak up all the values, and
anything after it will get an undefined value.  This may be useful in a
<A
CLASS="xref"
HREF="ch03_087.htm"
TITLE="local"
><B
CLASS="xref.cmd"
>local</B
></A
> or <A
CLASS="xref"
HREF="ch03_097.htm"
TITLE="my"
><B
CLASS="xref.cmd"
>my</B
></A
>, where you probably want the arrays initialized
to be empty anyway.</P
><P
CLASS="para"
>You may find the number of elements in the array <CODE
CLASS="literal"
>@days</CODE
> by 
evaluating <CODE
CLASS="literal"
>@days</CODE
> in a scalar context, such as:</P
><PRE
CLASS="programlisting"
>@days + 0;      # implicitly force @days into a scalar context
scalar(@days)   # explicitly force @days into a scalar context</PRE
><P
CLASS="para"
>Note that this only works for arrays.  It does not work for list values
in general.  A comma-separated list evaluated in a scalar context will return the last
value, like the C comma operator.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2819"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2821"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2824"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2827"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2830"
></A
>Closely related to the scalar evaluation of <CODE
CLASS="literal"
>@days</CODE
> is <CODE
CLASS="literal"
>$#days</CODE
>.
This will return the subscript of the last element of the array, or one
less than the length, since there is (ordinarily) a 0th element.[<A
CLASS="footnote"
HREF="#AUTOID-2835"
>18</A
>]
Assigning to <CODE
CLASS="literal"
>$#days</CODE
> changes the length of the array.  Shortening an
array by this method destroys intervening values.  You can gain some
measure of efficiency by pre-extending an array that is going to get big.
(You can also extend an array by assigning to an element that is off the
end of the array.) You can truncate an array down to nothing by assigning
the null list <CODE
CLASS="literal"
>()</CODE
> to it.[<A
CLASS="footnote"
HREF="#AUTOID-2840"
>19</A
>]
The following two statements are equivalent:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2835"
>[18]</A
> For historical reasons, the special variable <B
CLASS="emphasis.bold"
>$[</B
> can be used to change
the array base.  Its use is not recommended, however.  In fact, this is
the last we'll even mention it.  Just don't use it.</P
></DIV
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2840"
>[19]</A
> In the current version of Perl, re-extending a truncated array does
not recover the values in the array.  (It did in earlier versions.)</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>@whatever = ();
$#whatever = -1;</PRE
><P
CLASS="para"
>And the following is always true:[<A
CLASS="footnote"
HREF="#AUTOID-2844"
>20</A
>]</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-2844"
>[20]</A
> Unless you've diddled the deprecated <B
CLASS="emphasis.bold"
>$[</B
>
variable. Er, <EM
CLASS="emphasis"
>this</EM
> is the last time we'll mention
it ...</P
></DIV
></BLOCKQUOTE
><PRE
CLASS="programlisting"
>scalar(@whatever) == $#whatever + 1;</PRE
><A
CLASS="indexterm"
NAME="AUTOID-2849"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2850"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2851"
></A
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.5"
>2.3.5 Hashes (Associative Arrays)</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2855"
></A
>As we indicated previously, a hash is just a funny kind of array in which
you look values up using key strings instead of numbers.  It defines
associations between keys and values, so hashes are often called
associative arrays.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2858"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2861"
></A
>There really isn't any such thing as a hash literal in Perl, but
if you assign an ordinary list to a hash, each pair of values in the
list will be taken to indicate one key/value association:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>%map = ('red',0x00f,'green',0x0f0,'blue',0xf00);</PRE
></P
><P
CLASS="para"
>This has the same effect as:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>%map = ();            # clear the hash first
$map{red}   = 0x00f;
$map{green} = 0x0f0;
$map{blue}  = 0xf00;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2870"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2873"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2877"
></A
>It is often more readable to use the <CODE
CLASS="literal"
>=&gt;</CODE
> operator between key/value
pairs.  The <CODE
CLASS="literal"
>=&gt;</CODE
> operator is just a synonym for a comma, but it's
more visually distinctive, and it also quotes any bare identifiers to
the left of it (just like the identifiers in braces above), which makes
it nice for initializing hash variables:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>%map = (
    red   =&gt; 0x00f,
    green =&gt; 0x0f0,
    blue  =&gt; 0xf00,
);</PRE
></P
><P
CLASS="para"
>or for initializing anonymous hash references to be used as records:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$rec = {
    witch =&gt; 'Mable the Merciless',
    cat   =&gt; 'Fluffy the Ferocious',
    date  =&gt; '10/31/1776',
};</PRE
></P
><P
CLASS="para"
>or for using call-by-named-parameter to invoke complicated functions:<A
CLASS="indexterm"
NAME="AUTOID-2888"
></A
></P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$field = $query-&gt;radio_group( 
                    NAME      =&gt; 'group_name',
                    VALUES    =&gt; ['eenie','meenie','minie'],
                    DEFAULT   =&gt; 'meenie',
                    LINEBREAK =&gt; 'true',
                    LABELS    =&gt; \%labels,
                );</PRE
></P
><P
CLASS="para"
>But we're getting ahead of ourselves.  Back to hashes.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2896"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2899"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2902"
></A
>You can use a hash variable (<CODE
CLASS="literal"
>%hash</CODE
>) in a list context, in which case it
interpolates all the key/value pairs into the list.  But just because
the hash was initialized in a particular order doesn't mean that the
values come back in that order.  Hashes are implemented internally using
hash tables for speedy lookup, which means that the order in which
entries are stored is dependent on the nature of the hash function used
to calculate positions in the hash table, and not on anything
interesting.  So the entries come back in a seemingly random order.
(The two elements of each key/value pair come out in the right order, of
course.)  
For examples of how to arrange for an output ordering, see the 
<B
CLASS="emphasis.bold"
>keys</B
> 
entry in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>, or <CODE
CLASS="literal"
>DB_BTREE</CODE
>
description in the DB_File documentation in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
>.</P
><P
CLASS="para"
>If you evaluate a hash variable in a scalar context, it returns a value
that is true if and only if the hash contains any key/value pairs.  (If
there are any key/value pairs, the value returned is a string consisting
of the number of used buckets and the number of allocated buckets,
separated by a slash.  This is pretty much only useful to find out
whether Perl's (compiled in) hashing algorithm is performing poorly on
your data set.  For example, you stick 10,000 things in a hash, but
evaluating <CODE
CLASS="literal"
>%HASH</CODE
> in scalar context reveals &quot;<CODE
CLASS="literal"
>1/8</CODE
>&quot;, which means only
one out of eight buckets has been touched, and presumably that one
bucket contains all 10,000 of your items.  This isn't supposed to
happen.)</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.6"
>2.3.6 Typeglobs and Filehandles</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2916"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2919"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2921"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2924"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2927"
></A
>Perl uses an internal type called a <EM
CLASS="emphasis"
>typeglob</EM
> to hold an entire
symbol table entry.  The type prefix of a typeglob is a <CODE
CLASS="literal"
>*</CODE
>, because
it represents all types.  This used to be the preferred way to 
pass arrays and hashes by reference into a function, but now that
we have real references, this mechanism is seldom needed.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2933"
></A
>Typeglobs (or references thereto) are still used
for passing or storing filehandles.  If you want to save away
a filehandle, do it this way:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$fh = *STDOUT;</PRE
></P
><P
CLASS="para"
>or perhaps as a real reference, like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$fh = \*STDOUT;</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2942"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2945"
></A
>This is also the way to create a local filehandle.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>sub newopen {
    my $path = shift;
    local *FH;  # not my!
    open (FH, $path) || return undef;
    return *FH;
}
$fh = newopen('/etc/passwd');</PRE
></P
><P
CLASS="para"
>See the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> entry in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
> and
the FileHandle module in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
>, for how to
generate new filehandles.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2955"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2958"
></A
>But the main use of typeglobs nowadays is to alias one symbol table
entry to another symbol table entry.  If you say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>*foo = *bar;</PRE
></P
><P
CLASS="para"
>it makes everything named &quot;<CODE
CLASS="literal"
>foo</CODE
>&quot; a synonym for every corresponding
thing named &quot;<CODE
CLASS="literal"
>bar</CODE
>&quot;.  You can alias just one of the variables in a
typeglob by assigning a reference instead:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>*foo = \$bar;</PRE
></P
><P
CLASS="para"
>makes <CODE
CLASS="literal"
>$foo</CODE
> an alias for <CODE
CLASS="literal"
>$bar</CODE
>,
but doesn't make <CODE
CLASS="literal"
>@foo</CODE
> an alias for
<CODE
CLASS="literal"
>@bar</CODE
>, or <CODE
CLASS="literal"
>%foo</CODE
> an alias for
<CODE
CLASS="literal"
>%bar</CODE
>.  Aliasing variables like this may seem like a
silly thing to want to do, but it turns out that the entire module
export/import mechanism is built around this feature, since there's
nothing that says the symbol you're aliasing has to be in your
namespace.  See <A
CLASS="xref"
HREF="ch04_01.htm"
TITLE="References and Nested Data Structures"
>Chapter 4</A
> and <A
CLASS="xref"
HREF="ch05_01.htm"
TITLE="Packages, Modules, and Object Classes"
>Chapter 5</A
> for more discussion on typeglobs.</P
></DIV
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.7"
>2.3.7 Input Operators</A
></H3
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.IO"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2983"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2986"
></A
>There are several input operators we'll discuss here because they parse
as terms.  In fact, sometimes we call them pseudo-literals because they
act like quoted strings in many ways.  (Output operators like <A
CLASS="xref"
HREF="ch03_110.htm"
TITLE="print"
><B
CLASS="xref.cmd"
>print</B
></A
>
parse as list operators and are discussed in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
>.)</P
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.7.1"
>2.3.7.1 Command input (backtick) operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-2995"
></A
><A
CLASS="indexterm"
NAME="AUTOID-2998"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3001"
></A
>First of all, we have the command input operator, also known as the
backticks operator, because it looks like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$info = `finger $user`;</PRE
></P
><P
CLASS="para"
>A string enclosed by backticks (grave accents) first undergoes
variable interpolation just like a double-quoted string.  The result of
that is then interpreted as a command by the shell, and the output of
that command becomes the value of the pseudo-literal.  (This is modeled
after a similar operator in some of the UNIX shells.)  In scalar
context, a single string consisting of all the output is returned.  In
list context, a list of values is returned, one for each line of output.
(You can set <B
CLASS="emphasis.bold"
>$/</B
> to use a different line terminator.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3009"
></A
>The command is executed each time the pseudo-literal is evaluated.
The numeric status value of the command is saved in <B
CLASS="emphasis.bold"
>$?</B
> (see the section
&quot;Special Variables&quot; later in this chapter for the interpretation of <B
CLASS="emphasis.bold"
>$?</B
>).  Unlike the <EM
CLASS="emphasis"
>csh</EM
> version
of this command, no translation is done on the return
data&nbsp;- newlines remain newlines.  Unlike any of the shells, single
quotes do not hide variable names in the command from interpretation.
To pass a <CODE
CLASS="literal"
>$</CODE
> through to the shell you need to hide
it with a backslash.  The <CODE
CLASS="literal"
>$user</CODE
> in our example
above is interpolated by Perl, not by the shell.  (Because the command
undergoes shell processing, see <A
CLASS="xref"
HREF="ch06_01.htm"
TITLE="Social Engineering"
>Chapter 6, <CITE
CLASS="chapter"
>Social Engineering</CITE
></A
>, for
security concerns.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3020"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3022"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3025"
></A
>The generalized form of backticks is <CODE
CLASS="literal"
>qx//</CODE
> (for &quot;quoted execution&quot;), but
the operator works exactly the same way as ordinary backticks.  You just
get to pick your quote characters.</P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.7.2"
>2.3.7.2 Line input (angle) operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="CH02.AB1"
></A
><A
CLASS="indexterm"
NAME="CH02.AB2"
></A
><A
CLASS="indexterm"
NAME="CH02.AO"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3040"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3043"
></A
>The most heavily used input operator is the line input operator, also
known as the angle operator.
Evaluating a filehandle in angle brackets (<CODE
CLASS="literal"
>&lt;STDIN&gt;</CODE
>, for example)
yields the next line from the associated
file.  (The newline is included, so according to Perl's criteria for
truth, a freshly input line is always true, up until end of file, at
which point an undefined value is returned, which is false.)  Ordinarily
you would assign the input value to a variable, but there is one situation
where an automatic assignment happens.  If and only if the line input
operator is the only thing inside the conditional of a <B
CLASS="emphasis.bold"
>while</B
> loop, the
value is automatically assigned to the special variable <B
CLASS="emphasis.bold"
>$_</B
>.  The assigned
value is
then tested to see whether it is defined.  (This may seem like an odd thing to
you, but you'll use the construct in almost every Perl script you write.)
Anyway, the following lines are equivalent to each other:<A
CLASS="indexterm"
NAME="AUTOID-3049"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3053"
></A
></P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while (defined($_ = &lt;STDIN&gt;)) { print $_; }   # the long way
while (&lt;STDIN&gt;) { print; }                    # the short way
for (;&lt;STDIN&gt;;) { print; }                    # while loop in disguise
print $_ while defined($_ = &lt;STDIN&gt;);         # long statement modifier
print while &lt;STDIN&gt;;                          # short statement modifier</PRE
></P
><P
CLASS="para"
>Remember that this special magic requires a <B
CLASS="emphasis.bold"
>while</B
> loop.  If you use
the input operator anywhere else, you must assign the result explicitly
if you want to keep the value:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>if (&lt;STDIN&gt;)      { print; }   # WRONG, prints old value of $_
if ($_ = &lt;STDIN&gt;) { print; }   # okay</PRE
></P
><P
CLASS="para"
>The filehandles <CODE
CLASS="literal"
>STDIN</CODE
>, <CODE
CLASS="literal"
>STDOUT</CODE
>, and <CODE
CLASS="literal"
>STDERR</CODE
>
are predefined and pre-opened.[<A
CLASS="footnote"
HREF="#AUTOID-3066"
>21</A
>]
Additional filehandles may be created with the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> function.  See
the <A
CLASS="xref"
HREF="ch03_102.htm"
TITLE="open"
><B
CLASS="xref.cmd"
>open</B
></A
> entry in <A
CLASS="xref"
HREF="ch03_01.htm"
TITLE="Functions"
>Chapter 3</A
> for details on this.  Some
object modules also create object references that can be used as filehandles.
See the FileHandle module in <A
CLASS="xref"
HREF="ch07_01.htm"
TITLE="The Standard Perl Library"
>Chapter 7</A
>.</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-3066"
>[21]</A
> The filehandles <CODE
CLASS="literal"
>stdin</CODE
>, <CODE
CLASS="literal"
>stdout</CODE
>, and <CODE
CLASS="literal"
>stderr</CODE
>
will also work except in packages, where they would be interpreted as
local identifiers rather than global.  They're only there for
compatibility with very old scripts, so use the uppercase versions.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3076"
></A
>In the <B
CLASS="emphasis.bold"
>while</B
> loops above, we were evaluating the line input operator in
a scalar context, so it returned each line separately.  However,
if you use it in a list context, a
list consisting of all the remaining input lines is returned, one line
per list element.  It's easy to make a <EM
CLASS="emphasis"
>large</EM
> data space this way, so
use this feature with care:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$one_line = &lt;MYFILE&gt;;   # Get first line.
@all_lines = &lt;MYFILE&gt;;  # Get the rest of the lines.</PRE
></P
><P
CLASS="para"
>There is no <B
CLASS="emphasis.bold"
>while</B
> magic associated with the list form of the input
operator, because the condition of a <B
CLASS="emphasis.bold"
>while</B
> loop is always a scalar
context (as is any conditional).</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3087"
></A
>Using the null filehandle within the angle operator is special and can be used to
emulate the command-line behavior of typical UNIX filter programs such as
<EM
CLASS="emphasis"
>sed</EM
> and <EM
CLASS="emphasis"
>awk</EM
>.  When you read
lines from <CODE
CLASS="literal"
>&lt;&gt;</CODE
>, it magically gives you all the
lines from all the files mentioned on the command line.  If no files
were mentioned, it gives you standard input instead, so your program
is easy to insert into the middle of a pipeline of processes.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3095"
></A
>Here's how it works: the first time <CODE
CLASS="literal"
>&lt;&gt;</CODE
> is
evaluated, the <B
CLASS="emphasis.bold"
>@ARGV</B
> array is checked,
and if it is null, <CODE
CLASS="literal"
>$ARGV[0]</CODE
> is set to &quot;<CODE
CLASS="literal"
>-</CODE
>&quot;, which
when opened gives you standard input.  The <B
CLASS="emphasis.bold"
>@ARGV</B
> array is then processed as a list of
filenames.  The loop:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while (&lt;&gt;) {
    ...                     # code for each line
}</PRE
></P
><P
CLASS="para"
>is equivalent to the following Perl-like pseudocode:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@ARGV = ('-') unless @ARGV;
while ($ARGV = shift) {
    open(ARGV, $ARGV) or warn &quot;Can't open $ARGV: $!\n&quot;;
    while (&lt;ARGV&gt;) {
        ...         # code for each line
    }
}</PRE
></P
><P
CLASS="para"
>except that it isn't so cumbersome to say, and will actually work.  It
really does shift array <B
CLASS="emphasis.bold"
>@ARGV</B
> and put
the current filename into variable <CODE
CLASS="literal"
>$ARGV</CODE
>.  It also
uses filehandle <B
CLASS="emphasis.bold"
>ARGV</B
>
internally&nbsp;- <CODE
CLASS="literal"
>&lt;&gt;</CODE
> is just a synonym for
<CODE
CLASS="literal"
>&lt;ARGV&gt;</CODE
>, which is magical.  (The pseudocode
above doesn't work because it treats <CODE
CLASS="literal"
>&lt;ARGV&gt;</CODE
>
as non-magical.)</P
><P
CLASS="para"
>You can modify <B
CLASS="emphasis.bold"
>@ARGV</B
> before the first
<CODE
CLASS="literal"
>&lt;&gt;</CODE
> as long as the array ends up containing
the list of filenames you really want.  Line numbers (<B
CLASS="emphasis.bold"
>$.</B
>) continue as if the input were one big happy
file.  (But see the example under <A
CLASS="xref"
HREF="ch03_031.htm"
TITLE="eof"
><B
CLASS="xref.cmd"
>eof</B
></A
> for
how to reset line numbers on each file.)</P
><P
CLASS="para"
>If you want to set <B
CLASS="emphasis.bold"
>@ARGV</B
> to your own list of files, go right ahead.
If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while ($_ = $ARGV[0], /^-/) {
    shift;
    last if /^--$/;
    if (/^-D(.*)/) { $debug = $1 }
    if (/^-v/)     { $verbose++  }
    ...             # other switches
}
while (&lt;&gt;) {
    ...             # code for each line
}</PRE
></P
><P
CLASS="para"
>The <CODE
CLASS="literal"
>&lt;&gt;</CODE
> symbol will return false only once.  If you call it again after
this it will assume you are processing another <B
CLASS="emphasis.bold"
>@ARGV</B
> list, and if you
haven't set <B
CLASS="emphasis.bold"
>@ARGV</B
>, it will input from <CODE
CLASS="literal"
>STDIN</CODE
>.</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3129"
></A
>If the string inside the angle brackets is a scalar
variable (for example, <CODE
CLASS="literal"
>&lt;$foo&gt;</CODE
>),
then that variable contains the name of the
filehandle to input from, or a reference to the same.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$fh = \*STDIN;
$line = &lt;$fh&gt;;</PRE
><A
CLASS="indexterm"
NAME="AUTOID-3134"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3135"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3136"
></A
></P
></DIV
><DIV
CLASS="sect3"
><H4
CLASS="sect3"
><A
CLASS="title"
NAME="PERL2-CH-2-SECT-3.7.3"
>2.3.7.3 Filename globbing operator</A
></H4
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3140"
></A
><A
CLASS="indexterm"
NAME="CH02.GF"
></A
><A
CLASS="indexterm"
NAME="CH02.GO"
></A
><A
CLASS="indexterm"
NAME="CH02.ABG1"
></A
><A
CLASS="indexterm"
NAME="CH02.ABG2"
></A
>You might wonder what happens to a line input operator if you put something
fancier inside the angle brackets.  What happens is that it mutates into
a different operator.
If the string inside the angle brackets is anything other than a
filehandle name or a scalar variable (even if there are just extra spaces),
it is interpreted as a filename pattern to be &quot;globbed&quot;.[<A
CLASS="footnote"
HREF="#AUTOID-3153"
>22</A
>]
The pattern is matched against the files in the current directory (or
the directory specified as part of the glob pattern), and the filenames
so matched are returned by the operator.  As with line input, the
names are returned one at a time in scalar context, or all at once
in list context.  In fact, the latter usage is more prevalent.  You
generally see things like:</P
><BLOCKQUOTE
CLASS="footnote"
><DIV
CLASS="footnote"
><P
CLASS="para"
><A
CLASS="footnote"
NAME="AUTOID-3153"
>[22]</A
> This has nothing to do with the previously mentioned typeglobs, other than
that they both use the <CODE
CLASS="literal"
>*</CODE
> character in a wildcard fashion.  The
<CODE
CLASS="literal"
>*</CODE
> character has the nickname &quot;glob&quot; when used like this.  With typeglobs
you're globbing symbols with the same name from the symbol table.  With
a filename glob, you're doing wildcard matching on the filenames in
a directory, just as the various shells do.</P
></DIV
></BLOCKQUOTE
><P
CLASS="para"
><PRE
CLASS="programlisting"
>my @files = &lt;*.html&gt;;</PRE
></P
><P
CLASS="para"
>As with other kinds of pseudo-literals, one level of variable
interpolation is done first, but you can't say <CODE
CLASS="literal"
>&lt;$foo&gt;</CODE
> because
that's an indirect filehandle as explained earlier.
(In older versions of Perl, programmers would insert braces to
force interpretation as a filename glob: <CODE
CLASS="literal"
>&lt;${foo}&gt;</CODE
>.  These days,
it's considered cleaner to call the internal function directly as
<CODE
CLASS="literal"
>glob($foo)</CODE
>, which is probably the right way to have invented it in the
first place.)</P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3164"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3166"
></A
>Whether you use the <A
CLASS="xref"
HREF="ch03_069.htm"
TITLE="glob"
><B
CLASS="xref.cmd"
>glob</B
></A
> function or
the old angle-bracket form, the globbing operator also does <B
CLASS="emphasis.bold"
>while</B
> magic like the line input operator, and
assigns the result to <B
CLASS="emphasis.bold"
>$_</B
>.  For example:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>while (&lt;*.c&gt;) {
    chmod 0644, $_;
}</PRE
></P
><P
CLASS="para"
>is equivalent to:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);
while (&lt;FOO&gt;) {
    chop;
    chmod 0644, $_;
}</PRE
></P
><P
CLASS="para"
>In fact, it's currently implemented that way, more or less.  (Which
means it will not work on filenames with spaces in them unless you have
<EM
CLASS="emphasis"
>csh</EM
>(1) on your machine.)  Of course, the shortest way to do the
above is:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>chmod 0644, &lt;*.c&gt;;</PRE
></P
><P
CLASS="para"
>Because globbing invokes a subshell, it's often faster to call
<A
CLASS="xref"
HREF="ch03_117.htm"
TITLE="readdir"
><B
CLASS="xref.cmd"
>readdir</B
></A
> yourself and just do your own
<A
CLASS="xref"
HREF="ch03_072.htm"
TITLE="grep"
><B
CLASS="xref.cmd"
>grep</B
></A
> on the filenames.  Furthermore,
due to its current implementation of using a shell, the <A
CLASS="xref"
HREF="ch03_069.htm"
TITLE="glob"
><B
CLASS="xref.cmd"
>glob</B
></A
> routine may get &quot;<CODE
CLASS="literal"
>Arg list too long</CODE
>&quot; errors
(unless you've installed <EM
CLASS="emphasis"
>tcsh</EM
>(1) as
<EM
CLASS="emphasis"
>/bin/csh</EM
>).</P
><P
CLASS="para"
>A glob evaluates its (embedded) argument only when it is starting a new
list.  All values must be read before it will start over.  In a list
context this isn't important, because you automatically get them all
anyway.  In a scalar context, however, the operator returns the next value
each time it is called, or a false value if you've just run out.  Again,
false is returned only once.  So if you're expecting a single value from
a glob, it is much better to say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>($file) = &lt;blurch*&gt;;  # list context</PRE
></P
><P
CLASS="para"
>than to say:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>$file = &lt;blurch*&gt;;    # scalar context</PRE
></P
><P
CLASS="para"
>because the former slurps all the matched filenames and resets the
operator, while the latter will alternate between returning a filename
and returning false.</P
><P
CLASS="para"
>It you're trying to do variable interpolation, it's definitely better
to use the <A
CLASS="xref"
HREF="ch03_069.htm"
TITLE="glob"
><B
CLASS="xref.cmd"
>glob</B
></A
> operator, because the
older notation can cause people to become confused with the indirect
filehandle notation.  But with things like this, it begins to become
apparent that the borderline between terms and operators is a bit
mushy:</P
><P
CLASS="para"
><PRE
CLASS="programlisting"
>@files = glob(&quot;$dir/*.[ch]&quot;);   # call glob as function
@files = glob $some_pattern;    # call glob as operator</PRE
></P
><P
CLASS="para"
><A
CLASS="indexterm"
NAME="AUTOID-3201"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3204"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3207"
></A
>We left the parentheses off of the second example to illustrate that
<A
CLASS="xref"
HREF="ch03_069.htm"
TITLE="glob"
><B
CLASS="xref.cmd"
>glob</B
></A
> can be used as a
<EM
CLASS="emphasis"
>unary</EM
> operator; that is, a prefix operator that
takes a single argument.  The <A
CLASS="xref"
HREF="ch03_069.htm"
TITLE="glob"
><B
CLASS="xref.cmd"
>glob</B
></A
>
operator is an example of a <EM
CLASS="emphasis"
>named unary operator</EM
>,
which is just one of the kinds of operators we'll talk about in the
section &quot;Operators&quot; later in this chapter.  But first we're going to talk about pattern
matching operations, which also parse like terms but operate like
operators.<A
CLASS="indexterm"
NAME="AUTOID-3213"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3214"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3215"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3216"
></A
><A
CLASS="indexterm"
NAME="AUTOID-3217"
></A
></P
></DIV
></DIV
></DIV
><DIV
CLASS="htmlnav"
><P
></P
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><TABLE
WIDTH="515"
BORDER="0"
CELLSPACING="0"
CELLPADDING="0"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_02.htm"
TITLE="2.2 Built-in Data Types"
><IMG
SRC="../gifs/txtpreva.gif"
ALT="Previous: 2.2 Built-in Data Types"
BORDER="0"></A
></TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="book"
HREF="index.htm"
TITLE="Programming Perl"
><IMG
SRC="../gifs/txthome.gif"
ALT="Programming Perl"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
><A
CLASS="SECT1"
HREF="ch02_04.htm"
TITLE="2.4 Pattern Matching"
><IMG
SRC="../gifs/txtnexta.gif"
ALT="Next: 2.4 Pattern Matching"
BORDER="0"></A
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="172"
>2.2 Built-in Data Types</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
WIDTH="171"
><A
CLASS="index"
HREF="index/idx_0.htm"
TITLE="Book Index"
><IMG
SRC="../gifs/index.gif"
ALT="Book Index"
BORDER="0"></A
></TD
><TD
ALIGN="RIGHT"
VALIGN="TOP"
WIDTH="172"
>2.4 Pattern Matching</TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="515"
TITLE="footer"><P
CLASS="nav"
><FONT
SIZE="-1"
>[ <A
HREF="../index.htm"
TITLE="The Perl CD Bookshelf"
>Library Home</A
> | <A
HREF="../perlnut/index.htm"
TITLE="Perl in a Nutshell"
>Perl in a Nutshell</A
> | <A
HREF="../learn/index.htm"
TITLE="Learning Perl"
>Learning Perl</A
> | <A
HREF="../learn32/index.htm"
TITLE="Learning Perl on Win32 Systems"
>Learning Perl on Win32</A
> | <A
HREF="index.htm"
TITLE="Programming Perl"
>Programming Perl</A
> | <A
HREF="../advprog/index.htm"
TITLE="Advanced Perl Programming"
>Advanced Perl Programming</A
> | <A
HREF="../cookbook/index.htm"
TITLE="Perl Cookbook"
>Perl Cookbook</A
> ]</FONT
></P
></DIV
></BODY
></HTML
>
