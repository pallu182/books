<HTML>
<HEAD>
<TITLE>h2xs - convert .h C header files to Perl extensions</TITLE>
<LINK REL="stylesheet" HREF="../Active.css" TYPE="text/css">
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;h2xs - convert .h C header files to Perl extensions</P></STRONG></FONT>
</TD></TR>
</TABLE>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#options">OPTIONS</A></LI>
	<LI><A HREF="#examples">EXAMPLES</A></LI>
	<UL>

		<LI><A HREF="#extension based on .h and .c files">Extension based on <EM>.h</EM> and <EM>.c</EM> files</A></LI>
	</UL>

	<LI><A HREF="#environment">ENVIRONMENT</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#diagnostics">DIAGNOSTICS</A></LI>
	<LI><A HREF="#limitations of x">LIMITATIONS of <STRONG>-x</STRONG></A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>h2xs - convert .h C header files to Perl extensions</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<P><STRONG>h2xs</STRONG> [<STRONG>-ACOPXacdfkmx</STRONG>] [<STRONG>-F</STRONG> addflags] [<STRONG>-M</STRONG> fmask] [<STRONG>-n</STRONG> module_name] [<STRONG>-o</STRONG> tmask] [<STRONG>-p</STRONG> prefix] [<STRONG>-s</STRONG> subs] [<STRONG>-v</STRONG> version] [headerfile ... [extra_libraries]]</P>
<P><STRONG>h2xs</STRONG> <STRONG>-h</STRONG></P>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><EM>h2xs</EM> builds a Perl extension from C header files.  The extension
will include functions which can be used to retrieve the value of any
#define statement which was in the C header files.</P>
<P>The <EM>module_name</EM> will be used for the name of the extension.  If
module_name is not supplied then the name of the first header file
will be used, with the first character capitalized.</P>
<P>If the extension might need extra libraries, they should be included
here.  The extension Makefile.PL will take care of checking whether
the libraries actually exist and how they should be loaded.
The extra libraries should be specified in the form -lm -lposix, etc,
just as on the cc command line.  By default, the Makefile.PL will
search through the library path determined by Configure.  That path
can be augmented by including arguments of the form <STRONG>-L/another/library/path</STRONG>
in the extra-libraries argument.</P>
<P>
<HR>
<H1><A NAME="options">OPTIONS</A></H1>
<DL>
<DT><STRONG><A NAME="item_%2DA"><STRONG>-A</STRONG></A></STRONG><BR>
<DD>
Omit all autoload facilities.  This is the same as <STRONG>-c</STRONG> but also removes the
<CODE>use&nbsp;AutoLoader</CODE> statement from the .pm file.
<P></P>
<DT><STRONG><A NAME="item_%2DC"><STRONG>-C</STRONG></A></STRONG><BR>
<DD>
Omits creation of the <EM>Changes</EM> file, and adds a HISTORY section to
the POD template.
<P></P>
<DT><STRONG><A NAME="item_%2DF_addflags"><STRONG>-F</STRONG> <EM>addflags</EM></A></STRONG><BR>
<DD>
Additional flags to specify to C preprocessor when scanning header for
function declarations.  Should not be used without <STRONG>-x</STRONG>.
<P></P>
<DT><STRONG><A NAME="item_%2DM_regular_expression"><STRONG>-M</STRONG> <EM>regular expression</EM></A></STRONG><BR>
<DD>
selects functions/macros to process.
<P></P>
<DT><STRONG><A NAME="item_%2DO"><STRONG>-O</STRONG></A></STRONG><BR>
<DD>
Allows a pre-existing extension directory to be overwritten.
<P></P>
<DT><STRONG><A NAME="item_%2DP"><STRONG>-P</STRONG></A></STRONG><BR>
<DD>
Omit the autogenerated stub POD section.
<P></P>
<DT><STRONG><A NAME="item_%2DX"><STRONG>-X</STRONG></A></STRONG><BR>
<DD>
Omit the XS portion.  Used to generate templates for a module which is not
XS-based.  <A HREF="#item_%2Dc"><CODE>-c</CODE></A> and <A HREF="#item_%2Df"><CODE>-f</CODE></A> are implicitly enabled.
<P></P>
<DT><STRONG><A NAME="item_%2Da"><STRONG>-a</STRONG></A></STRONG><BR>
<DD>
Generate an accessor method for each element of structs and unions. The
generated methods are named after the element name; will return the current
value of the element if called without additional arguments; and will set
the element to the supplied value (and return the new value) if called with
an additional argument. Embedded structures and unions are returned as a
pointer rather than the complete structure, to facilitate chained calls.
<P>These methods all apply to the Ptr type for the structure; additionally
two methods are constructed for the structure type itself, <CODE>_to_ptr</CODE>
which returns a Ptr type pointing to the same structure, and a <CODE>new</CODE>
method to construct and return a new structure, initialised to zeroes.</P>
<P></P>
<DT><STRONG><A NAME="item_%2Dc"><STRONG>-c</STRONG></A></STRONG><BR>
<DD>
Omit <CODE>constant()</CODE> from the .xs file and corresponding specialised
<CODE>AUTOLOAD</CODE> from the .pm file.
<P></P>
<DT><STRONG><A NAME="item_%2Dd"><STRONG>-d</STRONG></A></STRONG><BR>
<DD>
Turn on debugging messages.
<P></P>
<DT><STRONG><A NAME="item_%2Df"><STRONG>-f</STRONG></A></STRONG><BR>
<DD>
Allows an extension to be created for a header even if that header is
not found in standard include directories.
<P></P>
<DT><STRONG><A NAME="item_%2Dh"><STRONG>-h</STRONG></A></STRONG><BR>
<DD>
Print the usage, help and version for this h2xs and exit.
<P></P>
<DT><STRONG><A NAME="item_%2Dk"><STRONG>-k</STRONG></A></STRONG><BR>
<DD>
For function arguments declared as <CODE>const</CODE>, omit the const attribute in the
generated XS code.
<P></P>
<DT><STRONG><A NAME="item_%2Dm"><STRONG>-m</STRONG></A></STRONG><BR>
<DD>
<STRONG>Experimental</STRONG>: for each variable declared in the header file(s), declare
a perl variable of the same name magically tied to the C variable.
<P></P>
<DT><STRONG><A NAME="item_%2Dn_module_name"><STRONG>-n</STRONG> <EM>module_name</EM></A></STRONG><BR>
<DD>
Specifies a name to be used for the extension, e.g., -n&nbsp;RPC::DCE
<P></P>
<DT><STRONG><A NAME="item_%2Do_regular_expression"><STRONG>-o</STRONG> <EM>regular expression</EM></A></STRONG><BR>
<DD>
Use ``opaque'' data type for the C types matched by the regular
expression, even if these types are <CODE>typedef</CODE>-equivalent to types
from typemaps.  Should not be used without <STRONG>-x</STRONG>.
<P>This may be useful since, say, types which are <CODE>typedef</CODE>-equivalent
to integers may represent OS-related handles, and one may want to work
with these handles in OO-way, as in <CODE>$handle-&gt;do_something()</CODE>.
Use <CODE>-o .</CODE> if you want to handle all the <CODE>typedef</CODE>ed types as opaque types.</P>
<P>The type-to-match is whitewashed (except for commas, which have no
whitespace before them, and multiple <CODE>*</CODE> which have no whitespace
between them).</P>
<P></P>
<DT><STRONG><A NAME="item_%2Dp_prefix"><STRONG>-p</STRONG> <EM>prefix</EM></A></STRONG><BR>
<DD>
Specify a prefix which should be removed from the Perl function names, e.g., -p&nbsp;sec_rgy_ 
This sets up the XS <STRONG>PREFIX</STRONG> keyword and removes the prefix from functions that are
autoloaded via the <CODE>constant()</CODE> mechanism.
<P></P>
<DT><STRONG><A NAME="item_%2Ds_sub1%2Csub2"><STRONG>-s</STRONG> <EM>sub1,sub2</EM></A></STRONG><BR>
<DD>
Create a perl subroutine for the specified macros rather than autoload with the <CODE>constant()</CODE> subroutine.
These macros are assumed to have a return type of <STRONG>char *</STRONG>, e.g., -s&nbsp;sec_rgy_wildcard_name,sec_rgy_wildcard_sid.
<P></P>
<DT><STRONG><A NAME="item_%2Dv_version"><STRONG>-v</STRONG> <EM>version</EM></A></STRONG><BR>
<DD>
Specify a version number for this extension.  This version number is added
to the templates.  The default is 0.01.
<P></P>
<DT><STRONG><A NAME="item_%2Dx"><STRONG>-x</STRONG></A></STRONG><BR>
<DD>
Automatically generate XSUBs basing on function declarations in the
header file.  The package <CODE>C::Scan</CODE> should be installed. If this
option is specified, the name of the header file may look like
<CODE>NAME1,NAME2</CODE>. In this case NAME1 is used instead of the specified string,
but XSUBs are emitted only for the declarations included from file NAME2.
<P>Note that some types of arguments/return-values for functions may
result in XSUB-declarations/typemap-entries which need
hand-editing. Such may be objects which cannot be converted from/to a
pointer (like <CODE>long long</CODE>), pointers to functions, or arrays.  See
also the section on <A HREF="#limitations of b<x>">LIMITATIONS of <STRONG>-x</STRONG></A>.</P>
<P></P>
<DT><STRONG><A NAME="item_%2Db_version"><STRONG>-b</STRONG> <EM>version</EM></A></STRONG><BR>
<DD>
Generates a .pm file which is backwards compatible with the specified
perl version.
<P>For versions &lt; 5.6.0, the changes are.
    - no use of 'our' (uses 'use vars' instead)
    - no 'use warnings'</P>
<P>Specifying a compatibility version higher than the version of perl you
are using to run h2xs will have no effect.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="examples">EXAMPLES</A></H1>
<PRE>
        # Default behavior, extension is Rusers
        h2xs rpcsvc/rusers</PRE>
<PRE>
        # Same, but extension is RUSERS
        h2xs -n RUSERS rpcsvc/rusers</PRE>
<PRE>
        # Extension is rpcsvc::rusers. Still finds &lt;rpcsvc/rusers.h&gt;
        h2xs rpcsvc::rusers</PRE>
<PRE>
        # Extension is ONC::RPC.  Still finds &lt;rpcsvc/rusers.h&gt;
        h2xs -n ONC::RPC rpcsvc/rusers</PRE>
<PRE>
        # Without constant() or AUTOLOAD
        h2xs -c rpcsvc/rusers</PRE>
<PRE>
        # Creates templates for an extension named RPC
        h2xs -cfn RPC</PRE>
<PRE>
        # Extension is ONC::RPC.
        h2xs -cfn ONC::RPC</PRE>
<PRE>
        # Makefile.PL will look for library -lrpc in 
        # additional directory /opt/net/lib
        h2xs rpcsvc/rusers -L/opt/net/lib -lrpc</PRE>
<PRE>
        # Extension is DCE::rgynbase
        # prefix &quot;sec_rgy_&quot; is dropped from perl function names
        h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase</PRE>
<PRE>
        # Extension is DCE::rgynbase
        # prefix &quot;sec_rgy_&quot; is dropped from perl function names
        # subroutines are created for sec_rgy_wildcard_name and sec_rgy_wildcard_sid
        h2xs -n DCE::rgynbase -p sec_rgy_ \
        -s sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase</PRE>
<PRE>
        # Make XS without defines in perl.h, but with function declarations
        # visible from perl.h. Name of the extension is perl1.
        # When scanning perl.h, define -DEXT=extern -DdEXT= -DINIT(x)=
        # Extra backslashes below because the string is passed to shell.
        # Note that a directory with perl header files would 
        #  be added automatically to include path.
        h2xs -xAn perl1 -F &quot;-DEXT=extern -DdEXT= -DINIT\(x\)=&quot; perl.h</PRE>
<PRE>
        # Same with function declaration in proto.h as visible from perl.h.
        h2xs -xAn perl2 perl.h,proto.h</PRE>
<PRE>
        # Same but select only functions which match /^av_/
        h2xs -M '^av_' -xAn perl2 perl.h,proto.h</PRE>
<PRE>
        # Same but treat SV* etc as &quot;opaque&quot; types
        h2xs -o '^[S]V \*$' -M '^av_' -xAn perl2 perl.h,proto.h</PRE>
<P>
<H2><A NAME="extension based on .h and .c files">Extension based on <EM>.h</EM> and <EM>.c</EM> files</A></H2>
<P>Suppose that you have some C files implementing some functionality,
and the corresponding header files.  How to create an extension which
makes this functionality accessable in Perl?  The example below
assumes that the header files are <EM>interface_simple.h</EM> and
<EM>interface_hairy.h</EM>, and you want the perl module be named as
<CODE>Ext::Ension</CODE>.  If you need some preprocessor directives and/or
linking with external libraries, see the flags <CODE>-F</CODE>, <CODE>-L</CODE> and <CODE>-l</CODE>
in <A HREF="#options">OPTIONS</A>.</P>
<DL>
<DT><STRONG><A NAME="item_Find_the_directory_name">Find the directory name</A></STRONG><BR>
<DD>
Start with a dummy run of h2xs:
<PRE>
  h2xs -Afn Ext::Ension</PRE>
<P>The only purpose of this step is to create the needed directories, and
let you know the names of these directories.  From the output you can
see that the directory for the extension is <EM>Ext/Ension</EM>.</P>
<P></P>
<DT><STRONG><A NAME="item_Copy_C_files">Copy C files</A></STRONG><BR>
<DD>
Copy your header files and C files to this directory <EM>Ext/Ension</EM>.
<P></P>
<DT><STRONG><A NAME="item_Create_the_extension">Create the extension</A></STRONG><BR>
<DD>
Run h2xs, overwriting older autogenerated files:
<PRE>
  h2xs -Oxan Ext::Ension interface_simple.h interface_hairy.h</PRE>
<P>h2xs looks for header files <EM>after</EM> changing to the extension
directory, so it will find your header files OK.</P>
<P></P>
<DT><STRONG><A NAME="item_Archive_and_test">Archive and test</A></STRONG><BR>
<DD>
As usual, run
<PRE>
  cd Ext/Ension
  perl Makefile.PL
  make dist
  make
  make test</PRE>
<P></P>
<DT><STRONG><A NAME="item_Hints">Hints</A></STRONG><BR>
<DD>
It is important to do <CODE>make dist</CODE> as early as possible.  This way you
can easily <CODE>merge(1)</CODE> your changes to autogenerated files if you decide
to edit your <CODE>.h</CODE> files and rerun h2xs.
<P>Do not forget to edit the documentation in the generated <EM>.pm</EM> file.</P>
<P>Consider the autogenerated files as skeletons only, you may invent
better interfaces than what h2xs could guess.</P>
<P>Consider this section as a guideline only, some other options of h2xs
may better suit your needs.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="environment">ENVIRONMENT</A></H1>
<P>No environment variables are used.</P>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Larry Wall and others</P>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P><A HREF="../lib/Pod/perl.html">the perl manpage</A>, <A HREF="../lib/Pod/perlxstut.html">the perlxstut manpage</A>, <A HREF="../lib/ExtUtils/MakeMaker.html">the ExtUtils::MakeMaker manpage</A>, and <A HREF="../lib/AutoLoader.html">the AutoLoader manpage</A>.</P>
<P>
<HR>
<H1><A NAME="diagnostics">DIAGNOSTICS</A></H1>
<P>The usual warnings if it cannot read or write the files involved.</P>
<P>
<HR>
<H1><A NAME="limitations of x">LIMITATIONS of <STRONG>-x</STRONG></A></H1>
<P><EM>h2xs</EM> would not distinguish whether an argument to a C function
which is of the form, say, <CODE>int *</CODE>, is an input, output, or
input/output parameter.  In particular, argument declarations of the
form</P>
<PRE>
    int
    foo(n)
        int *n</PRE>
<P>should be better rewritten as</P>
<PRE>
    int
    foo(n)
        int &amp;n</PRE>
<P>if <A HREF="../lib/Pod/perlguts.html#item_n"><CODE>n</CODE></A> is an input parameter.</P>
<P>Additionally, <EM>h2xs</EM> has no facilities to intuit that a function</P>
<PRE>
   int
   foo(addr,l)
        char *addr
        int   l</PRE>
<P>takes a pair of address and length of data at this address, so it is better
to rewrite this function as</P>
<PRE>
    int
    foo(sv)
            SV *addr
        PREINIT:
            STRLEN len;
            char *s;
        CODE:
            s = SvPV(sv,len);
            RETVAL = foo(s, len);
        OUTPUT:
            RETVAL</PRE>
<P>or alternately</P>
<PRE>
    static int
    my_foo(SV *sv)
    {
        STRLEN len;
        char *s = SvPV(sv,len);</PRE>
<PRE>
        return foo(s, len);
    }</PRE>
<PRE>
    MODULE = foo        PACKAGE = foo   PREFIX = my_</PRE>
<PRE>
    int
    foo(sv)
        SV *sv</PRE>
<P>See <A HREF="../lib/Pod/perlxs.html">the perlxs manpage</A> and <A HREF="../lib/Pod/perlxstut.html">the perlxstut manpage</A> for additional details.</P>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;h2xs - convert .h C header files to Perl extensions</P></STRONG></FONT>
</TD></TR>
</TABLE>

</BODY>

</HTML>
